### 第 31 章 信号量总结

在第 31 章中，信号量作为一种关键的同步原语被介绍。它由 Edsger Dijkstra 引入，用于解决各种并发问题，尤其是那些涉及到多个线程或进程需要协调访问共享资源的情况。

#### 31.1 信号量的定义

信号量是一个包含整数值的对象，可以通过两个基本操作来改变它的值：`sem_wait()` 和 `sem_post()`。这两个操作的行为如下：

- `sem_wait(sem_t *s)`：这个函数会将信号量的值减一。如果信号量的值在调用时大于或等于 1，那么 `sem_wait()` 立即返回；如果信号量的值为 0 或负数，调用线程将被阻塞，直到信号量的值再次变为正数（通过另一个线程调用 `sem_post()` 来增加信号量的值）。
- `sem_post(sem_t *s)`：这个函数会将信号量的值增加一，并且如果有线程正在等待该信号量（即信号量的值为负数），它会唤醒其中的一个线程。

信号量的工作机制依赖于它的整数值。初始值的设定决定了信号量的行为。例如，如果将信号量的初始值设为 1，它就可以充当一个简单的互斥锁，确保同一时间只有一个线程能够进入临界区。

### 信号量的使用

信号量可以用于多种同步场景，包括但不限于以下几种：

1. **互斥锁（Binary Semaphore）**：通过初始化信号量值为 1，可以将其用作互斥锁。这保证了同一时间只有一个线程能够进入临界区。
2. **计数信号量（Counting Semaphore）**：通过初始化信号量值为大于 1 的值，可以允许多个线程同时进入临界区，直到达到一个预定的最大值。
3. **条件变量替代品**：信号量还可以用来实现条件同步机制。例如，在生产者/消费者问题中，可以通过信号量来协调生产者和消费者对缓冲区的访问。

### 实现信号量的要点

在信号量的实现中，最关键的是确保 `sem_wait()` 和 `sem_post()` 操作的原子性。这意味着在执行这两个操作时，必须防止其他线程对信号量值的同时修改，以避免竞态条件。这通常通过锁和条件变量来实现。

在信号量的工作原理中，负的信号量值表示有多少线程在等待该信号量。因此，当多个线程调用 `sem_wait()` 时，它们会被排队等待，直到一个 `sem_post()` 操作将它们唤醒。

通过信号量，可以有效地管理和控制多线程环境中的资源访问，防止数据竞争和死锁等常见并发问题。

### 31.2 二值信号量（锁）总结

在 31.2 节中，讨论了如何使用信号量作为锁来实现线程同步。信号量是一种更加通用的同步原语，二值信号量（即信号量的值为 0 或 1）是其中一种特定用途，常用于实现互斥锁。

#### 信号量的使用

二值信号量的基本用法非常简单。在使用信号量作为锁时，我们需要初始化信号量，并通过 `sem_wait()` 和 `sem_post()` 函数对临界区进行保护。

- **初始化信号量**: 在信号量作为锁使用时，通常将信号量的初始值设为 1，这表示锁未被持有。图 31.3 展示了代码的初始化部分：

  ```
  c复制代码sem_t m;
  sem_init(&m, 0, 1); // 初始化信号量为 1，表示锁未被持有
  ```

- **进入临界区**: 在线程进入临界区之前，它会调用 `sem_wait()`，该操作会将信号量的值减 1。如果信号量的值变为负数，则表示锁已被持有，线程会进入等待状态，直到有另一个线程释放锁为止。

- **离开临界区**: 当线程离开临界区时，它会调用 `sem_post()`，该操作会将信号量的值加 1。如果有其他线程在等待该信号量，则其中一个线程会被唤醒并继续执行。

#### 工作流程示例

以下是两个线程在使用信号量作为锁时的一个场景：

1. **单线程场景**:
   - 线程 0 调用 `sem_wait()`，信号量的值从 1 变为 0，表示锁已被线程 0 持有。
   - 线程 0 进入临界区，执行完成后调用 `sem_post()`，将信号量的值恢复为 1，表示锁未被持有。
2. **多线程场景**:
   - 线程 0 先调用 `sem_wait()`，信号量的值减为 0 并进入临界区。
   - 线程 1 尝试进入临界区时调用 `sem_wait()`，信号量的值变为 -1，线程 1 进入等待状态。
   - 线程 0 退出临界区后调用 `sem_post()`，信号量的值变为 0，并唤醒等待的线程 1，线程 1 得以进入临界区。

表 31.2 提供了这种情况下的线程调度和信号量值变化的详细跟踪，展示了信号量如何有效地管理多个线程对临界区的访问。

#### 二值信号量的实现

在这种用法中，信号量被称为二值信号量，因为它在任一时刻只能持有两个状态（0 和 1）。当信号量的初始值为 1 时，表示锁未被持有，线程可以自由进入临界区；当值为 0 时，表示锁已被持有，其他线程必须等待。

通过这种方式，二值信号量可以实现简单的互斥锁，确保只有一个线程在任意时刻能够进入受保护的临界区，避免数据竞争和其他并发问题。

### 31.3 信号量用作条件变量总结

在 31.3 节中，讨论了如何使用信号量来实现条件变量的功能。信号量不仅可以用作锁，还可以用作条件变量来管理线程间的同步，尤其是在一个线程需要等待某个条件满足时。

#### 信号量作为条件变量的基本原理

信号量在用作条件变量时，主要用于在线程之间传递信号。例如，一个线程在执行到某一阶段时，需要等待另一个线程完成特定的操作。在这种情况下，等待的线程会调用 `sem_wait()` 进入等待状态，而执行操作的线程在完成后会调用 `sem_post()` 来通知等待的线程继续执行。

#### 代码示例：父线程等待子线程

下面是一个简单的例子，展示了父线程如何等待子线程完成执行（见图 31.4）：

```
c复制代码sem_t s;

void *child(void *arg) {
    printf("child\n");
    sem_post(&s); // 子线程完成后发送信号
    return NULL;
}

int main(int argc, char *argv[]) {
    sem_init(&s, 0, 0); // 初始化信号量为 0
    printf("parent: begin\n");
    pthread_t c;
    Pthread_create(&c, NULL, child, NULL);
    sem_wait(&s); // 等待子线程完成
    printf("parent: end\n");
    return 0;
}
```

在该程序中，信号量 `s` 的初始值设置为 0，这意味着父线程在执行 `sem_wait()` 时，会立即进入等待状态，直到子线程执行 `sem_post()` 并将信号量的值增加为 1，唤醒父线程。

#### 两种可能的执行场景

1. **子线程在父线程之前运行**：
   - 如果子线程在父线程调用 `sem_wait()` 之前运行并执行 `sem_post()`，信号量的值将从 0 变为 1。此时，当父线程执行 `sem_wait()` 时，信号量的值会减少为 0，父线程无需等待，可以直接继续执行。
2. **父线程在子线程之前运行**：
   - 如果父线程先执行 `sem_wait()`，信号量的值会从 0 减少为 -1，表示父线程进入等待状态。随后，子线程执行 `sem_post()` 时，信号量的值会增加为 0，并唤醒父线程，父线程从 `sem_wait()` 返回，继续执行。

在这两种情况下，信号量都能保证线程间的同步，确保父线程在子线程完成后再继续执行。

#### 关键点

- **信号量初始值设置为 0**：这确保了等待线程在调用 `sem_wait()` 时会立即进入等待状态，直到信号量的值被 `sem_post()` 增加为正数。
- **信号量的使用**：通过 `sem_wait()` 和 `sem_post()`，可以有效地控制线程的执行顺序，避免竞态条件，实现线程间的同步。

这个例子展示了信号量用作条件变量的简单而有效的方式，适用于需要线程间同步的各种场景。

### 31.4 生产者/消费者（有界缓冲区）问题总结

在 31.4 节中，讨论了使用信号量解决经典的生产者/消费者问题（有界缓冲区问题）。生产者/消费者问题是多线程编程中的常见问题之一，涉及如何安全地在多个线程之间共享一个有限的缓冲区。

#### 初次尝试

最初的解决方案使用了两个信号量：`empty` 和 `full`，分别表示缓冲区中的空槽和已满槽的数量。具体的 `put()` 和 `get()` 函数如图 31.5 所示：

```
c复制代码int buffer[MAX];
int fill = 0;
int use = 0;

void put(int value) {
    buffer[fill] = value;
    fill = (fill + 1) % MAX;
}

int get() {
    int tmp = buffer[use];
    use = (use + 1) % MAX;
    return tmp;
}
```

对应的生产者和消费者代码如图 31.6 所示：

```
c复制代码sem_t empty;
sem_t full;

void *producer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&empty); // 等待空槽
        put(i); // 放入数据
        sem_post(&full); // 增加已满槽数
    }
}

void *consumer(void *arg) {
    int i, tmp = 0;
    while (tmp != -1) {
        sem_wait(&full); // 等待已满槽
        tmp = get(); // 取出数据
        sem_post(&empty); // 增加空槽数
        printf("%d\n", tmp);
    }
}
```

在这种初次尝试中，信号量 `empty` 的初值为 `MAX`，表示缓冲区最初是空的，而 `full` 的初值为 0，表示最初没有数据。在这个方案中，生产者在空槽数为 0 时等待，消费者在满槽数为 0 时等待。

#### 问题：竞态条件

当 `MAX > 1` 时，多生产者/消费者情况下会产生竞态条件。假设两个生产者几乎同时执行 `put()` 操作，而其中一个在更新 `fill` 索引前被中断，另一个生产者可能会覆盖之前的数据，导致数据丢失。

#### 解决方案：增加互斥锁

为了解决竞态条件，增加了一个二值信号量 `mutex` 作为锁，以保护 `put()` 和 `get()` 的临界区（见图 31.7）：

```
c复制代码sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&mutex); // 获得锁
        sem_wait(&empty); // 等待空槽
        put(i); // 放入数据
        sem_post(&full); // 增加已满槽数
        sem_post(&mutex); // 释放锁
    }
}

void *consumer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&mutex); // 获得锁
        sem_wait(&full); // 等待已满槽
        int tmp = get(); // 取出数据
        sem_post(&empty); // 增加空槽数
        sem_post(&mutex); // 释放锁
        printf("%d\n", tmp);
    }
}
```

#### 问题：死锁

这个方案虽然解决了竞态条件，但引入了死锁风险。当一个线程持有锁并等待信号量时，另一个线程也可能在等待锁，从而导致两个线程相互等待，形成死锁。

#### 终极解决方案：缩小锁的作用域

最终的解决方案是缩小互斥锁的作用域，仅在对共享资源进行实际访问时使用锁（见图 31.8）：

```
c复制代码sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&empty); // 等待空槽
        sem_wait(&mutex); // 获得锁
        put(i); // 放入数据
        sem_post(&mutex); // 释放锁
        sem_post(&full); // 增加已满槽数
    }
}

void *consumer(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
        sem_wait(&full); // 等待已满槽
        sem_wait(&mutex); // 获得锁
        int tmp = get(); // 取出数据
        sem_post(&mutex); // 释放锁
        sem_post(&empty); // 增加空槽数
        printf("%d\n", tmp);
    }
}
```

在该方案中，互斥锁仅用于保护 `put()` 和 `get()` 的临界区，而 `full` 和 `empty` 信号量的等待和唤醒操作都在锁的外面进行，从而避免了死锁并确保程序的正确性。

#### 结论

通过逐步改进，最终方案解决了生产者/消费者问题中的竞态条件和死锁问题，实现了一个有效的多线程有界缓冲区。

### 31.5 读者-写者锁

在 31.5 节中，讨论了一种更灵活的锁定机制——读者-写者锁（reader-writer lock）。这种锁的设计初衷是为了优化对数据结构的并发访问，特别是在一些场景下，读操作可以并发执行，而写操作则需要独占资源。

#### 问题背景

在并发程序设计中，某些数据结构可能需要同时支持多个读者（读取数据的线程）访问，而只允许一个写者（修改数据的线程）进行操作。例如，一个并发链表中，插入操作会修改链表的状态，需要独占访问权限；而查找操作仅是读取链表，可以允许多个线程并发执行。

#### 读者-写者锁的实现

读者-写者锁的基本思想是，多个读者可以同时获取读锁，而写者只能独占获取写锁。实现这一机制的代码如图 31.9 所示：

```
c复制代码typedef struct _rwlock_t { 
    sem_t lock; // binary semaphore (basic lock) 
    sem_t writelock; // used to allow ONE writer or MANY readers 
    int readers; // count of readers reading in critical section 
} rwlock_t;

void rwlock_init(rwlock_t *rw) { 
    rw->readers = 0; 
    sem_init(&rw->lock, 0, 1); 
    sem_init(&rw->writelock, 0, 1); 
}

void rwlock_acquire_readlock(rwlock_t *rw) { 
    sem_wait(&rw->lock); 
    rw->readers++; 
    if (rw->readers == 1) 
        sem_wait(&rw->writelock); // first reader acquires writelock 
    sem_post(&rw->lock); 
}

void rwlock_release_readlock(rwlock_t *rw) { 
    sem_wait(&rw->lock); 
    rw->readers--; 
    if (rw->readers == 0) 
        sem_post(&rw->writelock); // last reader releases writelock 
    sem_post(&rw->lock); 
}

void rwlock_acquire_writelock(rwlock_t *rw) { 
    sem_wait(&rw->writelock); 
}

void rwlock_release_writelock(rwlock_t *rw) { 
    sem_post(&rw->writelock); 
}
```

#### 代码解析

1. **数据结构**：
   - `lock`: 用于保护对 `readers` 计数器的访问，是一个二值信号量。
   - `writelock`: 确保只有一个写者或者多个读者可以访问数据，是一个二值信号量。
   - `readers`: 计数当前正在读取数据的读者数量。
2. **读锁的获取和释放**：
   - 获取读锁时，线程首先获取 `lock` 信号量，增加 `readers` 计数。如果当前是第一个读者（即 `readers == 1`），它还需要获取 `writelock` 信号量，阻止写者进入临界区。然后释放 `lock`，允许其他读者进入。
   - 释放读锁时，线程再次获取 `lock`，减少 `readers` 计数。如果当前是最后一个读者（即 `readers == 0`），它会释放 `writelock` 信号量，允许等待中的写者进入。
3. **写锁的获取和释放**：
   - 获取写锁的线程直接尝试获取 `writelock` 信号量。如果成功，表示没有其他写者或读者正在访问临界区，它可以进入。
   - 释放写锁时，线程释放 `writelock` 信号量，允许其他等待的读者或写者进入。

#### 优缺点分析

- **优点**：
  - 读者-写者锁允许多个读者并发访问，从而提高读操作的并发性。
  - 在读操作较多而写操作较少的场景下，这种锁机制可以显著提高系统的吞吐量。
- **缺点**：
  - 读者容易饿死写者：在高频率的读操作下，写者可能长期得不到执行的机会，因为读者在不断地获取和释放读锁。
  - 性能开销：相比简单的互斥锁，读者-写者锁引入了更多的复杂性和开销，可能在某些情况下反而降低性能。

#### 总结

读者-写者锁是一种在某些特定场景下非常有用的并发控制机制。它展示了信号量的强大之处，通过组合和巧妙设计，可以实现灵活的锁定策略。然而，正如提示中所指出的那样，简单的方案往往是最有效的，在选择使用读者-写者锁时，需要权衡其复杂性和潜在的性能开销。

### 31.6 哲学家就餐问题

哲学家就餐问题（Dining Philosopher’s Problem）是由 Edsger Dijkstra 提出的经典并发问题，虽然其实际应用不多，但因为它在研究并发编程中的同步问题时非常有趣，所以广为人知。这一问题的重要性不仅体现在学术研究中，甚至在一些编程面试中也经常出现。

#### 问题描述

在哲学家就餐问题中，假设有五位哲学家围坐在一张圆桌旁，每两位哲学家之间放置了一把餐叉，因此共有五把餐叉。哲学家们有时会思考，不需要餐叉；有时会吃饭，而一位哲学家只有同时拿到左手边和右手边的两把餐叉，才能进食。餐叉的争夺以及同步问题就是这个问题的核心所在。

哲学家们的基本循环代码如下：

```
c复制代码while (1) { 
    think(); 
    getforks(); 
    eat(); 
    putforks(); 
}
```

关键的挑战在于如何实现 `getforks()` 和 `putforks()` 函数，以保证：

1. 没有死锁发生。
2. 没有哲学家会饿死（即长时间得不到两把餐叉）。
3. 并发度尽可能高（让尽可能多的哲学家同时进食）。

#### 辅助函数

为了解决这个问题，我们使用一些辅助函数，帮助定位哲学家左右手的餐叉编号：

```
c复制代码int left(int p) { return p; } 
int right(int p) { return (p + 1) % 5; }
```

对于哲学家 `p`，`left(p)` 返回左手边餐叉的编号，`right(p)` 返回右手边餐叉的编号。模运算解决了最后一位哲学家右手边餐叉编号的问题。

我们还需要一些信号量来解决这个问题，假设需要 5 个信号量，每把餐叉一个：`sem_t forks[5]`。

#### 有问题的解决方案

首先，我们尝试一个简单的解决方案：每个哲学家依次获取左手边和右手边的餐叉。如果拿到了两把餐叉，哲学家可以进食；进食完后，释放餐叉。

实现如下：

```
c复制代码void getforks() { 
    sem_wait(forks[left(p)]); 
    sem_wait(forks[right(p)]); 
}

void putforks() { 
    sem_post(forks[left(p)]); 
    sem_post(forks[right(p)]); 
}
```

这个方案的思路很直接：哲学家首先尝试拿起左手边的餐叉，再尝试拿起右手边的餐叉。然而，这种方案存在一个严重问题：**死锁**。

假设每位哲学家都成功拿到了左手边的餐叉，但在尝试拿起右手边的餐叉时却发现右手边的餐叉已经被其他哲学家占用了，这时就会发生死锁——所有哲学家都在等待另一个餐叉，无法继续进食，程序将陷入僵局。

#### 解决方案：打破循环依赖

为了解决死锁问题，我们可以调整哲学家获取餐叉的顺序。具体来说，假设最后一位哲学家（编号为 4 的哲学家）先拿右手边的餐叉，再拿左手边的餐叉，而其他哲学家依然保持原来的顺序。这样可以打破循环等待，从而避免死锁。

代码如下：

```
c复制代码void getforks() { 
    if (p == 4) { 
        sem_wait(forks[right(p)]); 
        sem_wait(forks[left(p)]); 
    } else { 
        sem_wait(forks[left(p)]); 
        sem_wait(forks[right(p)]); 
    } 
}
```

通过这种调整，最后一个哲学家会先尝试拿右手边的餐叉，这样可以防止所有哲学家都拿着一把餐叉互相等待的情况，从而避免死锁。

#### 总结

哲学家就餐问题是并发编程中的经典问题，虽然实际应用较少，但其对理解并发控制、死锁避免等问题具有重要意义。通过调整获取资源的顺序，可以有效避免死锁。然而，其他类似的并发问题，如吸烟者问题、理发师问题等，也提供了丰富的并发控制思路和技术。

### 31.7 如何实现信号量

在这一节中，我们将用底层的同步原语（锁和条件变量）来实现自己的信号量，称之为 Zemaphore。这个实现相对简单，核心代码如下：

```
c复制代码typedef struct _Zem_t { 
    int value; 
    pthread_cond_t cond; 
    pthread_mutex_t lock; 
} Zem_t; 

// 只允许一个线程调用初始化函数
void Zem_init(Zem_t *s, int value) { 
    s->value = value; 
    pthread_cond_init(&s->cond, NULL); 
    pthread_mutex_init(&s->lock, NULL); 
} 

void Zem_wait(Zem_t *s) { 
    pthread_mutex_lock(&s->lock); 
    while (s->value <= 0) 
        pthread_cond_wait(&s->cond, &s->lock); 
    s->value--; 
    pthread_mutex_unlock(&s->lock); 
} 

void Zem_post(Zem_t *s) { 
    pthread_mutex_lock(&s->lock); 
    s->value++; 
    pthread_cond_signal(&s->cond); 
    pthread_mutex_unlock(&s->lock); 
} 
```

在这个实现中，我们使用了一把锁、一个条件变量和一个表示信号量值的状态变量。这种实现与 Dijkstra 定义的信号量稍有不同，主要区别在于我们没有让信号量的值为负数来反映等待线程的数量。事实上，在这个实现中，信号量的值永远不会小于 0，这种行为更加容易实现，并且符合现有的 Linux 实现。

**提示：小心泛化**

在系统设计中，抽象和泛化是非常有用的技术，一个好的想法可以通过适当的扩展来解决更大范围的问题。然而，泛化时要小心，正如 Lampson 所提醒的那样：“不要泛化。泛化通常都是错的。”【L83】。

我们可以将信号量视为锁和条件变量的泛化形式，但这种泛化是否必要？考虑到使用信号量来实现条件变量的难度，可能这种泛化并没有我们想象的那么通用。

实际上，使用信号量实现锁和条件变量是一个相对棘手的问题。一些有经验的并发程序员曾在 Windows 环境下尝试过，结果导致了许多缺陷【B04】。你可以自己尝试一下，看看能否理解为什么使用信号量实现条件变量比看起来要困难得多。

### 31.8 小结

信号量是一个非常强大且灵活的并发编程原语。有些程序员因为信号量的简单实用，可能只使用信号量，而不使用锁和条件变量。

在本章中，我们展示了几个经典的并发问题及其解决方案。如果你对这些内容感兴趣，还有很多资料可以参考。Allen Downey 的关于并发和信号量编程的书籍【D08】是一本非常好的参考资料（而且是免费的）。这本书包含了许多谜题，研究它们可以帮助你更深入地理解信号量以及一般的并发编程知识。成为一名并发编程专家需要多年的努力，学习本课程之外的内容无疑是掌握这一领域的关键。