### 7. 引言：进程调度概述

在前几章中，我们探讨了实现进程切换和CPU虚拟化的底层机制，如上下文切换。现在，我们将讨论操作系统使用的上层策略，即调度策略。这些策略决定了在任何给定时刻，应该运行哪个进程。

### 7.1 工作负载假设

在探讨各种调度策略之前，我们需要对系统中运行的进程（即工作负载）做出一些假设。这些假设尽管不完全现实，但有助于我们构建和分析调度策略。具体的假设包括：

1. 每个任务的运行时间相同。
2. 所有任务同时到达系统。
3. 任务一旦开始，就会持续运行直到完成。
4. 所有任务都只使用CPU，不涉及I/O操作。
5. 每个任务的运行时间是已知的。

虽然这些假设并不完全反映真实世界的工作负载，但它们为我们提供了一个简化的模型，可以在此基础上开发调度策略。随着研究的深入，我们将放宽这些假设，逐步引入更加现实的调度策略。

### 7.2 调度指标

为了比较不同的调度策略，我们需要选择合适的调度指标。在本章中，我们主要关注一个指标：**周转时间**（turnaround time）。周转时间定义为任务完成的时间减去任务到达系统的时间。更正式的表示为：

T周转时间=T完成时间−T到达时间T_{\text{周转时间}} = T_{\text{完成时间}} - T_{\text{到达时间}}T周转时间=T完成时间−T到达时间

在我们当前的假设下，所有任务的到达时间为零，因此周转时间等于完成时间。随着我们放宽假设，这一情况将会改变。

虽然本章主要关注性能指标（如周转时间），但公平性（fairness）也是一个重要的调度指标。例如，优化性能的调度策略可能会牺牲某些任务的公平性。

### 7.3 先进先出（FIFO）调度

最基本的调度算法是先进先出（FIFO），也称为先到先服务（FCFS）。FIFO调度策略的特点是简单易实现，对于某些假设下的工作负载，它的表现也相当不错。

#### FIFO 示例：

假设有三个任务A、B和C，它们在同一时间到达系统，每个任务的运行时间为10秒。FIFO的调度顺序是先运行A，再运行B，最后运行C。结果是A在10秒完成，B在20秒完成，C在30秒完成。平均周转时间为：

平均周转时间=10+20+303=20秒\text{平均周转时间} = \frac{10 + 20 + 30}{3} = 20 \text{秒}平均周转时间=310+20+30=20秒

#### FIFO 的问题：

当任务的运行时间不同时，FIFO的表现可能会变差。例如，如果任务A的运行时间为100秒，而B和C的运行时间为10秒，那么FIFO会导致较长的平均周转时间：

平均周转时间=100+110+1203=110秒\text{平均周转时间} = \frac{100 + 110 + 120}{3} = 110 \text{秒}平均周转时间=3100+110+120=110秒

这种现象被称为“护航效应”（convoy effect），即较短的任务被较长的任务阻塞，导致系统效率降低。

#### SJF 原则：

最短任务优先（SJF）是一种可以改善这种情况的调度原则。该原则指出，优先处理较短的任务可以减少平均周转时间。在日常生活中，SJF原则也广泛应用于排队系统中，如超市的“快速结账通道”。

### 结论

FIFO调度虽然简单，但在处理不同长度任务时表现不佳。为了解决这些问题，我们需要开发更加复杂和高效的调度算法，这也是接下来的讨论重点。

### 7.4 最短任务优先（SJF）

最短任务优先（SJF）是一种有效的调度策略，旨在解决先进先出（FIFO）调度中出现的“护航效应”问题。SJF 的核心思想是优先调度运行时间最短的任务，这样可以显著降低系统的平均周转时间。

#### SJF 示例：

以之前的例子为基础，如果我们使用 SJF 来调度三个任务 A、B 和 C，其中 A 需要运行 100s，B 和 C 各需要运行 10s。SJF 会优先调度 B 和 C，最后再调度 A。这将大幅降低平均周转时间，从 FIFO 的 110s 降至 50s。

SJF 在所有任务同时到达的情况下是最优的调度策略，因为它可以最小化总的等待时间。然而，SJF 仍然存在局限性，尤其是当任务随时到达时，可能会出现调度问题。

### 7.5 最短完成时间优先（STCF）

为了解决任务随时到达的情况，我们可以引入抢占机制，从而发展出最短完成时间优先（STCF）调度策略。STCF 是 SJF 的扩展，它允许调度程序在新任务到达时，重新评估当前运行的任务和新任务的剩余时间。如果新任务的完成时间更短，则会中断当前任务，优先运行新任务。

#### STCF 示例：

假设 A 在 t = 0 时到达，需要运行 100s，B 和 C 在 t = 10 时到达，各需要运行 10s。在 STCF 策略下，调度程序会在 B 和 C 到达时中断 A，先运行 B 和 C，最后再完成 A 的剩余部分。这样，平均周转时间从之前 SJF 下的 103.33s 降至 50s。

STCF 是抢占式调度的一种，它在工作任务长度已知的情况下，是最优的调度策略。

### 7.6 新度量指标：响应时间

随着分时系统的发展，系统的交互性变得越来越重要。这催生了一个新的调度指标：**响应时间**。响应时间是从任务到达系统到首次运行的时间间隔。它直接影响了用户的体验，尤其是在交互性强的系统中。

#### 响应时间的影响：

例如，在 STCF 调度下，如果三个任务 A、B 和 C 同时到达，任务 A 和 B 可能很快就会被调度，但任务 C 可能需要等待较长时间才会被执行。这种情况导致任务 C 的响应时间较长，即使它的总周转时间较短，这对于需要及时反馈的系统来说是不理想的。

因此，在追求良好的响应时间的同时，需要开发新的调度策略，使系统能够快速响应用户的操作，同时保持较好的总体性能。

### 结论

虽然 SJF 和 STCF 都是优化系统周转时间的有效策略，但它们在处理响应时间时可能表现不佳。为了构建一个能够平衡周转时间和响应时间的调度程序，下一步的研究将涉及开发对响应时间敏感的调度算法。这种算法能够更好地满足用户的需求，尤其是在实时交互系统中。

### 7.7 轮转（Round-Robin）

为了同时优化响应时间和周转时间，出现了轮转（Round-Robin，RR）调度算法。RR 的基本思路是将每个任务分配一个固定的时间片（time slice，也称为调度量子），在这个时间片内运行该任务，然后切换到下一个任务。RR 持续重复这一过程，直到所有任务完成。与 SJF 和 STCF 相比，RR 提供了更好的响应时间，尤其是在处理多任务时。

#### 轮转调度的示例

假设有三个任务 A、B 和 C，它们都需要运行 5s，并且同时到达系统。SJF 调度会先运行 A，再运行 B 和 C，如图 7.6 所示。这会导致较差的响应时间。而使用 1s 时间片的 RR 调度，则会循环运行这三个任务，如图 7.7 所示。最终的响应时间是：（0 + 1 + 2）/ 3 = 1，而 SJF 的平均响应时间是 5。这表明，RR 在响应时间方面表现更好。

#### 时间片的影响

RR 的效果与时间片的长度密切相关。时间片越短，RR 在响应时间上的表现越好。然而，过短的时间片会导致频繁的上下文切换，增加系统的开销，进而影响整体性能。因此，设计者需要在响应时间和上下文切换的开销之间找到一个平衡点。一般来说，时间片长度应当足够长，以摊销上下文切换的成本，同时又不会导致系统响应变慢。

**提示：摊销成本**

当系统某些操作的固定成本较高时，采用摊销技术可以减少总成本。通过增加时间片的长度，系统可以减少上下文切换的频率，从而降低因频繁切换带来的性能损失。例如，如果上下文切换的开销为 1ms，而时间片长度为 10ms，那么 10% 的 CPU 时间会用于切换。如果时间片长度增加到 100ms，切换的开销就只有 1%，从而提高了系统的整体性能。

#### RR 的局限性

尽管 RR 在响应时间上表现出色，但它在周转时间上的表现则较差。由于 RR 在每个任务上都只运行一小段时间，然后切换到下一个任务，整个任务完成的时间被延长了。例如，对于三个每个需要 5s 的任务 A、B 和 C，RR 的平均周转时间会高达 14s，而 SJF 则为 10s。

这反映了一个固有的权衡问题：如果追求响应时间，周转时间就会受损；如果追求周转时间，响应时间又会变差。系统设计者必须在这两者之间做出权衡，根据具体的应用场景选择最合适的调度策略。

### 7.8 结合 I/O

在现实世界中，程序并非只使用 CPU，它们还需要执行 I/O 操作。调度程序必须在任务发起 I/O 请求时做出决定，因为此时任务将被阻塞，无法继续使用 CPU。这意味着调度程序可以将 CPU 分配给其他任务，以提高系统的利用率。

**示例：结合 I/O 的调度**

假设有两个任务 A 和 B。A 每 10ms 发起一次 I/O 请求，而 B 则是一个 50ms 的纯 CPU 任务。在这种情况下，调度程序可以通过将 A 的每次 CPU 使用看作一个独立的任务来优化调度。这样，在 A 等待 I/O 完成时，B 可以利用这段时间继续执行，从而最大化 CPU 的利用率。

### 7.9 无法预知

到目前为止，我们的讨论都假设调度程序知道每个任务的运行时间。但实际上，操作系统通常无法预见任务的运行时长。因此，调度程序如何在未知任务长度的情况下做出有效的调度决策？

这是一个复杂的问题，需要调度程序基于过去的经验来预测未来的工作负载。这种策略将在下一章介绍，我们将讨论一种名为多级反馈队列的调度程序，它能够在没有任务长度信息的情况下，做出高效的调度决策。

### 7.10 小结

我们介绍了几种调度策略，包括优化周转时间的 SJF 和 STCF 以及优化响应时间的 RR。这些策略各有优劣，系统设计者需要根据具体应用场景选择合适的调度算法。同时，我们也初步讨论了如何将 I/O 结合到调度中，以及在无法预见任务长度的情况下如何进行调度。接下来的章节将介绍一种更复杂的调度算法——多级反馈队列，进一步探索调度的复杂性和可能性。