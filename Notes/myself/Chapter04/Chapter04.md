### 第 4 章 抽象：进程

本章讨论了操作系统提供的基本抽象——进程。通过对进程的理解，我们可以明白操作系统如何管理和虚拟化计算资源，使得多个程序能够并发执行。

#### 进程的定义

- **进程的概念**：进程就是运行中的程序。程序本身只是存储在磁盘上的一组指令，只有当它们被操作系统加载并执行时，才成为进程。
- **多进程的需求**：现代计算设备通常同时运行多个程序（进程），如浏览器、邮件、游戏等。操作系统的挑战在于如何在有限的物理CPU上提供几乎无数个虚拟CPU的假象。

#### 虚拟化CPU

- **CPU虚拟化**：操作系统通过虚拟化CPU来实现多个进程的并发执行。通过时分共享技术（time sharing），操作系统让每个进程在特定时间片内独占CPU，然后切换到另一个进程，从而提供了多个虚拟CPU的假象。
- **性能开销**：虚拟化CPU带来的一些性能损失是不可避免的，因为每个进程分配到的CPU时间片较短，因此整体运行速度会变慢。

#### 机制与策略

- **机制（Mechanism）**：机制是实现虚拟化和管理进程的低级方法。例如，上下文切换（context switch）是一个关键机制，它允许操作系统暂停一个进程并切换到另一个进程运行。
- **策略（Policy）**：策略是操作系统用来做出决定的算法。例如，调度策略决定了在某个时刻哪个进程应该运行。这可能基于历史信息、当前工作负载和系统性能目标等。

### 4.1 抽象：进程

这一节深入探讨了进程的构成和操作系统如何抽象地处理运行中的程序。

#### 进程的机器状态

- **机器状态的定义**：进程的机器状态包括程序运行时可以读取或更新的所有内容。理解进程的机器状态有助于理解操作系统如何管理进程。
- **内存（地址空间）**：进程的机器状态中最重要的一部分是内存。进程的指令和数据都存储在内存中，进程通过访问这些内存来执行任务。
- **寄存器**：寄存器是机器状态的另一关键部分。程序计数器（PC）、栈指针和帧指针等寄存器对于进程的执行至关重要。

#### I/O 与持久存储

- **持久存储**：进程通常还会涉及I/O操作，例如当前打开的文件列表。这些I/O信息也是进程机器状态的一部分。

### 提示与设计理念

- **分离策略与机制**：操作系统设计中的一个常见范式是将策略与机制分离开来。机制解决“如何实现”问题，而策略解决“哪个进程应该执行”的问题。这种分离使得操作系统的设计更具模块化，并易于调整策略而不影响底层机制。

------

这总结涵盖了第4章中的内容，包括操作系统如何通过虚拟化CPU和管理进程机器状态来实现并发执行，并且强调了策略与机制分离的重要性。

### 4.2 进程 API

在这一节中，作者简要介绍了操作系统提供的进程管理API，这些API在所有现代操作系统中都以某种形式存在。

#### 进程 API 的主要功能：

- **创建（create）**：操作系统必须提供创建新进程的方法。当用户在命令行输入命令或双击应用程序图标时，操作系统会创建一个新进程来运行指定的程序。
- **销毁（destroy）**：既然有创建进程的接口，操作系统也必须提供销毁进程的接口。虽然很多进程会在任务完成后自动退出，但如果某个进程失控，用户可以通过接口强制终止它。
- **等待（wait）**：有时用户或系统需要等待某个进程停止运行，因此操作系统提供了等待接口来实现这一功能。
- **其他控制（miscellaneous control）**：除了终止或等待进程外，操作系统还提供了其他控制功能，例如暂停（暂停运行一段时间）或恢复进程（继续运行）。
- **状态（status）**：操作系统通常还提供查询进程状态的接口，比如查询进程运行的时间或进程当前所处的状态。

### 4.3 进程创建：更多细节

本节深入探讨了操作系统如何创建和运行一个进程的具体过程，揭示了程序如何转化为进程。

#### 进程创建的步骤：

1. **加载程序到内存**：
   - **加载代码和静态数据**：操作系统首先将程序的代码和所有静态数据（例如初始化变量）从磁盘加载到内存中。程序通常以某种可执行格式存储在磁盘上，操作系统将其读取并放入内存中的某处。
   - **加载方式**：在早期或简单的操作系统中，这一过程是尽早（eagerly）完成的，即在程序运行前将所有内容加载到内存。而现代操作系统往往采用惰性加载（lazily），即仅在程序执行过程中需要时才加载代码或数据片段。
2. **分配运行时栈**：
   - **栈的作用**：操作系统为程序的运行时栈分配内存，栈用于存放局部变量、函数参数和返回地址。操作系统还会将传递给 `main()` 函数的参数 `argc` 和 `argv` 初始化在栈中。
3. **分配堆内存**：
   - **堆的作用**：堆内存用于动态分配数据结构，如链表、散列表和树等。操作系统初始分配较小的堆内存，当程序运行时通过调用 `malloc()` 请求更多内存时，操作系统可能会参与为其分配更多内存。
4. **I/O 初始化**：
   - **文件描述符**：在 UNIX 系统中，操作系统默认为每个进程分配三个打开的文件描述符，分别对应标准输入、输出和错误。这些描述符使程序可以方便地读取输入和输出内容。
5. **启动程序执行**：
   - **启动程序**：在完成上述初始化后，操作系统将控制权交给新创建的进程，通过跳转到 `main()` 函数开始执行程序。这一过程涉及到操作系统将CPU控制权转移到新进程中，使其开始运行。

------

这段总结详细介绍了操作系统提供的进程API，以及操作系统如何从程序创建一个完整的进程并启动其执行。通过这些细节，我们了解了操作系统在后台为每个运行中的程序所做的复杂准备工作。

### 4.4 进程状态

本节详细介绍了操作系统中进程的不同状态及其之间的转换。这些状态反映了进程在不同时间的活动情况，并且是操作系统管理多任务处理的基础。

#### 进程的三种主要状态：

- **运行（Running）**：当进程处于运行状态时，它正在处理器上执行指令。这是进程最活跃的状态。
- **就绪（Ready）**：处于就绪状态的进程已经准备好执行，但由于某种原因（如处理器繁忙），暂时未被操作系统安排运行。
- **阻塞（Blocked）**：当进程发起某种操作（如I/O请求）后，它可能会被阻塞，直到特定事件发生（如I/O操作完成）。在此期间，该进程无法继续执行，操作系统会将其挂起。

#### 进程状态转换：

- **状态图解**：如图 4.2 所示，进程可以在不同状态之间转换。进程从就绪状态到运行状态意味着它被调度执行，从运行状态到就绪状态意味着它被取消调度。当进程发起I/O请求时，它会从运行状态转到阻塞状态；当I/O操作完成后，它会从阻塞状态返回到就绪状态，或者立即被调度执行。

#### 状态转换的例子：

1. 仅使用CPU的进程

   ：

   - 表 4.1 展示了两个仅使用CPU的进程在不发起I/O操作的情况下的状态转换。一个进程在运行时，另一个进程处于就绪状态，直到前者完成，后者才开始运行。

2. 包含I/O操作的进程

   ：

   - 表 4.2 展示了一个进程在发起I/O操作时的状态转换。Process0 在运行了一段时间后发起I/O请求并进入阻塞状态，这时操作系统开始运行Process1。当I/O操作完成后，Process0返回到就绪状态，并在Process1完成后继续运行。

#### 操作系统的决策：

- **调度决策**：即使在这些简单的例子中，操作系统也需要做出重要的决策。例如，当Process0发起I/O请求时，系统决定让Process1运行，以保持CPU繁忙并提高资源利用率。当I/O完成后，系统选择不立即切换回Process0，这样的决策取决于调度策略。

### 总结：

本节通过对进程状态的详细讨论，解释了操作系统如何管理进程的执行及其在不同状态之间的转换。这些状态和转换机制使得操作系统能够有效地管理多任务处理，确保系统资源的最佳利用。

### 4.5 数据结构

本节探讨了操作系统中用于管理进程的关键数据结构，这些数据结构是操作系统跟踪每个进程的状态和信息的基础。

#### 进程列表与数据结构

- **进程列表（Process List）**：操作系统使用某种形式的进程列表来跟踪系统中所有就绪、运行和阻塞的进程。这些数据结构帮助操作系统管理多个同时运行的进程，并确保在需要时正确调度和管理这些进程。
- **进程控制块（Process Control Block, PCB）**：操作系统通常为每个进程维护一个数据结构来存储与该进程相关的所有信息。在许多操作系统中，这种数据结构被称为进程控制块。它包含了进程的状态、内存信息、寄存器内容等。

#### xv6 操作系统的进程结构示例

- **寄存器上下文**：在 `xv6` 内核中，`context` 结构体保存了进程停止时的寄存器内容。当进程被恢复时，这些寄存器的值会被重新加载到物理寄存器中，从而恢复进程的运行。这种技术被称为上下文切换（context switch）。
- **进程状态**：`xv6` 中的 `proc_state` 枚举定义了进程可能处于的几种状态，包括未使用（UNUSED）、胚胎（EMBRYO）、睡眠（SLEEPING）、可运行（RUNNABLE）、运行（RUNNING）和僵尸（ZOMBIE）状态。僵尸状态用于表示进程已经退出但尚未清理，允许父进程检查其退出状态。
- **进程信息**：`xv6` 的 `proc` 结构体包含了关于进程的各种信息，例如：
  - **内存信息**：进程内存的起始地址和大小。
  - **内核栈**：用于存储该进程的内核栈底部地址。
  - **进程 ID（PID）**：唯一标识进程的ID。
  - **父进程**：指向父进程的指针。
  - **I/O 信息**：如打开的文件、当前目录等。
  - **陷阱框架**：用于处理当前中断的陷阱框架指针。

#### 进程状态的其他扩展

- **初始状态与最终状态**：除了运行、就绪和阻塞状态外，操作系统还可能定义其他状态。例如，初始状态表示进程在创建时的状态，最终状态则表示进程已经退出但尚未被清理的状态（如 UNIX 系统中的僵尸状态）。父进程通常通过调用 `wait()` 函数来等待子进程完成，并在进程结束后清理相关资源。

### 4.6 小结

本节总结了操作系统的最基本抽象——进程的概念。通过介绍进程的状态、数据结构和管理方式，我们为进一步讨论实现进程所需的低级机制和调度进程的高级策略奠定了基础。这些内容将帮助我们更深入地理解操作系统如何通过虚拟化 CPU 来管理和运行多个进程。