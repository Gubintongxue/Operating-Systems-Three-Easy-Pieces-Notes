# 第二章 操作系统介绍

不了解计算机程序运行时做的事，这本书和相应的课程对你来说会很困难，停止阅读本书，在继续读本书之前快速学习必要的背景知识（包括Patt/Patel[PP03]，特别是Bryant/O‘Hallarn的书[BOH10]，都是相当不错的）。



一个运行中的程序会不断**执行指令**。

处理器从内存中**获取（fetch）一条指令**，对其进行**解码（decode）**（弄清楚这是哪条指令），然后**执行（execute）它**（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器**继续执行下一条指令**，依此类推，直到**程序最终完成**。

--冯诺依曼计算模型的基本概念。

操作系统（Operating System, OS）: 负责确保系统既易于使用又高效地运行。

- 让程序运行变得容易，甚至允许你同时运行多个程序，允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。

### 关键问题：如何将资源虚拟化

虚拟化，让系统更易于使用。我们关注如何虚拟化：操作系统通过哪些机制和策略来实现虚拟化？操作系统如何有效地实现虚拟化？需要哪些硬件支持？

- 操作系统主要利用一种通用的技术：虚拟化（virtualization）  
- 操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更 强大且更易于使用的虚拟形式。  
- 因此，我们有时将操作系统称为虚拟机（virtual machine ）  
- 操作系统还提供了一些接口（**API**），为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能（如运行程序、分配内存或访问文件）。
  - 实际上典型的操作系统会提供上百个系统调用（system call）,让应用程序调用。
- 由于操作系统提供的这些调用来运行程序、访问内存和设备，并进行其他相关操作，有时也会说OS为应用工程需提供了一个标准库（standard library）。
- 操作系统也被成为资源管理器（resource manager）,因为虚拟化让许多程序运行（从而共享CPU）,让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘）。
  - 每个 CPU、内存和磁盘都是系统的资源（resource），因此操作系统扮演的主要角色就是操理（manage）这些资源，以做到高效或公平，或者实际上考虑其他许多可能的目标。

操作系统实际上做了：

> 1.它取 CPU、内存或磁盘等物理资源（resources），对它们虚拟化（virtualize）  
> 2.它处理与并发（concurrency）有关的麻烦且棘手的问题  
> 3.它持久地（persistently）存储文件，从而使它们长期随全



## 2.1 虚拟化CPU

图 2.1 展示了我们的第一个程序。实际上，它没有太大的作用，它所做的只是调用 Spin()

函数，该函数会反复检查时间甚在运行一秒后返回。然后，它会打印出用户在命令行中传

入的字符串，甚一直重复这样做。

```C
#include <stdio.h>        // 包含标准输入输出库，用于 printf 和 fprintf
#include <stdlib.h>       // 包含标准库函数，用于 exit
#include <sys/time.h>     // 包含获取系统时间的库，用于 Spin 函数中的时间处理
#include <assert.h>       // 包含断言库，通常用于调试
#include "common.h"       // 包含自定义的头文件，通常包含 Spin 函数的声明

// 主函数，程序的入口点
int main(int argc, char *argv[]) 
{ 
    // 检查命令行参数的数量是否正确，argc 应该为 2（程序名 + 一个参数）
    if (argc != 2) { 
        // 如果参数数量不正确，打印错误信息并退出程序
        fprintf(stderr, "usage: cpu <string>\n"); 
        exit(1); 
    } 
    
    // 获取命令行参数（字符串），并将其赋值给 str 指针
    char *str = argv[1]; 
    
    // 无限循环，程序会一直运行，直到被手动终止
    while (1) { 
        // 调用 Spin 函数，引入 1 秒的延迟（忙等待）
        Spin(1); 
        // 打印命令行传入的字符串
        printf("%s\n", str); 
    } 
    
    // 返回 0，程序正常结束（这行代码永远不会执行到，因为有无限循环）
    return 0; 
}
```

代码的关键点：

1. **参数检查**：程序首先检查命令行参数的数量是否正确。如果不正确，会打印用法提示并退出。
2. **无限循环**：程序进入一个无限循环，在这个循环中每次都会延迟1秒并打印指定的字符串。
3. **Spin 函数**：引入了人为的延迟，用于模拟程序的等待或暂停。这在某些测试和多线程的场景中可能很有用。

使用场景：

这段代码可以用于测试CPU的负载处理能力，因为它会持续不断地打印一个字符串，同时在每次打印前进行短暂的延迟。



`Spin()` 函数在许多系统编程库或操作系统相关的代码中用于引入一个人为的延迟，通常在处理多线程或并发操作时使用。它的常见实现通常是在循环中进行忙等待。下面是一个可能的实现例子：

```C
#include <sys/time.h>

void Spin(int seconds) {
    struct timeval start, end;
    gettimeofday(&start, NULL);
    do {
        gettimeofday(&end, NULL);
    } while ((end.tv_sec - start.tv_sec) < seconds);
}
```

1. `gettimeofday(&start, NULL);`：获取当前的时间戳并存储在 `start` 变量中。
2. `do-while` 循环：循环持续执行，直到经过的时间达到指定的 `seconds`。
3. `gettimeofday(&end, NULL);`：不断更新 `end` 时间戳，直到满足条件 `(end.tv_sec - start.tv_sec) < seconds`。

在这种实现中，`Spin(1)` 将会使程序忙等待约1秒钟。

**注意：** 忙等待（Busy-waiting）会占用CPU资源，一般在实际应用中不建议使用，除非确实需要进行低延迟的轮询。

#### 编译与运行：

- 将代码保存为 

  ```
  cpu.c
  ```

  通过以下命令编译：

  ```
  gcc -o cpu cpu.c -Wall
  -Wall：这个选项是告诉 GCC 编译器打开所有的警告信息。-Wall 使得 GCC 会报告代码中可能存在的问题，这些问题虽然不会导致编译失败，但可能会导致运行时错误或性能问题。这是一个很好的实践，因为它可以帮助开发者在代码的早期阶段就发现和修复潜在的问题。
  ```

- 编译后运行程序，若输入 "A" 作为参数，输出如下：

  ```
  ./cpu "A"
  A
  A
  A
  ...
  ```

#### 多实例运行：

- 如果同时运行多个该程序的实例，如图 2.2 所示，使用以下命令：

  ```sh
  ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
  #命令后面跟随的内容默认都会被识别为字符串
  ```

- 输出将交替显示每个程序的字符串（A、B、C、D），给人一种这些程序在同时运行的错觉。

  ```
  [1] 7353 
  [2] 7354 
  [3] 7355 
  [4] 7356 
  A 
  B 
  D 
  C 
  A 
  B 
  D 
  C 
  A 
  C 
  B 
  D
  ```

#### CPU虚拟化概念：

- 虽然系统只有一个物理CPU，但这些程序看似在同时运行，这种现象称为CPU虚拟化。
- 操作系统通过硬件的支持，创建了一个系统拥有多个虚拟CPU的假象，让用户感觉多个程序在同时执行。
- 将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU（virtualizing the CPU），这是本书第一大部分的关注点。

#### 相关问题：

- 要运行程序甚停止它们，或告诉操作系统运行哪些程序，需要有一些接口（API），你可以利用它们将需求传达给操作系统。我们将在本书中讨论这些 API。事实上，它们是大多数用户与操作系统交互的主要方式。

- 运行多个程序会引发新的问题，如多个程序同时竞争资源时，哪个程序应该优先运行？这些问题由操作系统的策略（policy）来决定。
- 操作系统不仅提供了运行程序的机制（mechanism），还担任了资源管理器（resource manager）的角色，负责资源的分配与调度。

### 总结：

本节通过简单的代码示例，引出CPU虚拟化的概念，解释了如何在单处理器系统上通过操作系统的支持实现多个程序看似同时运行的效果，并引发了对操作系统资源管理策略的探讨。

### 2.2 虚拟化内存

本节介绍了内存的虚拟化过程，通过一个简单的程序展示了操作系统如何为每个进程提供私有的虚拟地址空间，即使这些进程在表面上似乎使用相同的物理内存地址。

#### 物理内存的基础概念：

- **物理内存模型**：现今的物理内存可以被视作一个简单的字节数组。读取（read）或写入（write）内存时，需要指定内存地址，以访问或更新存储在那里的数据。
- **内存的作用**：在程序运行期间，所有的数据结构都保存在内存中。程序通过各种指令访问内存，其中每个指令本身也存储在内存中，因此每条指令的执行都会涉及对内存的访问。

#### 示例程序解析：

```c
#include <unistd.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include "common.h"  // 引入头文件，包含Spin函数的定义

int 
main(int argc, char *argv[]) 
{ 
    int *p = malloc(sizeof(int)); // a1 动态分配一个int大小的内存块
    assert(p != NULL); // 检查内存分配是否成功
    printf("(%d) memory address of p: %08x\n", getpid(), (unsigned) p); // a2 输出当前进程ID和指针p的内存地址
    *p = 0; // a3 初始化p指向的内存为0
    while (1) { 
        Spin(1); // 延迟1秒，模仿程序的长时间运行
        *p = *p + 1; // 每次循环将p指向的值加1
        printf("(%d) p: %d\n", getpid(), *p); // a4 输出当前进程ID和p指向的值
    } 
    return 0; 
}
//这段代码通过动态内存分配来创建一个整数，并在一个无限循环中不断增加该整数的值，且每次循环都会延迟一秒钟并输出当前进程ID和整数的值。
/*
%08x\n
%08x 是 printf 函数的格式说明符，用于输出一个无符号的整数（unsigned int）的十六进制表示。具体到这个格式说明符：

% 表示开始一个格式说明符。
0 表示如果数字的十六进制表示长度小于指定的宽度（这里是8），则在前面填充0以达到指定的宽度。
8 表示最小宽度为8个字符。如果数字的十六进制表示长度小于8，则前面会用0填充到8位。
x 表示以十六进制（小写字母）形式输出无符号整数。
\n 是一个换行符，用于在输出后换行。
(unsigned) p
(unsigned) p 是一个类型转换的表达式，它将 p 的值转换为 unsigned 类型（通常是 unsigned int，但具体类型取决于编译器和上下文）。这种类型转换通常用于确保 p 的值以无符号整数的形式被解释和输出，这在处理指针或某些需要特定数值表示的场景中非常有用。
*/
```

图 2.3 中展示了一个示例程序（`mem.c`），该程序通过调用 `malloc()` 来动态分配内存，并反复读取、修改内存中的数据。

- **代码分析**：

  - **内存分配**：程序在第9行调用 `malloc(sizeof(int))` 为一个整数分配内存，并使用指针 `p` 指向该内存地址。
  - **检查分配是否成功**：第10行使用 `assert` 断言 `p` 不为 `NULL`，以确保内存分配成功。
  - **打印内存地址**：第11行打印分配的内存地址及进程标识符（PID），PID 对每个进程是唯一的。
  - **更新内存值**：第13行初始化内存中的值为0，然后程序进入无限循环，每秒递增一次内存中的值并输出结果。

- **程序输出**：

  - 运行 

    ```
    ./mem
    ```

     后，程序会输出内存地址及递增的值，如下所示：

    ```
    prompt> ./mem
    (2134) memory address of p: 00200000
    (2134) p: 1
    (2134) p: 2
    (2134) p: 3
    ...
    ```

#### 多实例运行示例：

图 2.4 展示了同时运行该程序多个实例时的情况。通过以下命令可以运行两个程序实例：

```
prompt> ./mem &; ./mem & 
[1] 24113 
[2] 24114 
(24113) memory address of p: 00200000 
(24114) memory address of p: 00200000 
(24113) p: 1 
(24114) p: 1 
(24114) p: 2 
(24113) p: 2 
(24113) p: 3 
(24114) p: 3 
(24113) p: 4 
(24114) p: 4 
...
```

- 观察现象：

  - 每个程序实例都在相同的地址 `00200000` 处分配了内存，并各自独立地更新了该地址处的值。
- 这表面上看似不同的程序实例在共享相同的内存地址，但实际上它们各自拥有独立的私有内存空间。

#### 内存虚拟化的概念：

- **虚拟地址空间**：操作系统为每个进程提供了一个独立的虚拟地址空间，进程只能访问自己的虚拟地址空间，而不会影响其他进程或操作系统本身的地址空间。
- **操作系统的角色**：尽管每个进程看似拥有自己的物理内存，实际上，物理内存是一个由操作系统管理的共享资源。操作系统通过将进程的虚拟地址映射到物理内存，确保进程间的内存访问不会相互干扰。

### 总结：

本节通过一个简单的内存访问程序，深入探讨了内存虚拟化的概念，展示了**操作系统如何通过虚拟地址空间机制，使得每个进程看似拥有独立的物理内存，而实际上，物理内存是由操作系统管理的共享资源**。该内容引出本书第1部分的核心主题：虚拟化（Virtualization）。

### 补充1：每个进程是否拥有独立的物理内存？

每个进程**不直接拥有独立的物理内存**，但每个进程**拥有独立的虚拟内存空间**。操作系统通过虚拟内存管理机制为每个进程提供了一个独立的虚拟地址空间，这使得每个进程看起来好像拥有自己的独立内存，但实际上，这些虚拟地址会被映射到共享的物理内存上。

#### 具体来说：

1. **虚拟内存**：
   - 每个进程有自己独立的虚拟内存空间，这些空间通常包括代码段、数据段、堆栈等。
   - 虚拟内存地址是进程所看到的地址，它们由操作系统管理，通过页表将这些虚拟地址映射到实际的物理内存地址。
2. **物理内存**：
   - 物理内存是系统中实际存在的内存条所提供的内存容量。
   - 多个进程可能会共享同一段物理内存（例如共享库、文件映射等），但通过虚拟内存机制，进程之间的内存访问是相互隔离的。
3. **页表和地址映射**：
   - 操作系统为每个进程维护一个页表，记录虚拟内存和物理内存之间的映射关系。
   - 当进程访问某个虚拟地址时，操作系统会通过页表将该虚拟地址转换为物理地址，再进行实际的内存访问。
4. **内存隔离**：
   - 由于每个进程的虚拟内存空间是独立的，进程之间的内存访问是相互隔离的。这意味着一个进程不能直接访问另一个进程的内存空间（除非通过特定的进程间通信机制，如共享内存）。
5. **内存管理**：
   - 操作系统负责管理和分配物理内存，并通过内存管理单元（MMU）实现虚拟内存到物理内存的转换。
   - 当一个进程需要更多内存时，操作系统会为其分配物理内存并更新页表。

#### 总结

每个进程有自己独立的虚拟内存空间，通过虚拟内存机制实现内存隔离。物理内存是共享的，但由于虚拟内存管理，每个进程的内存访问是独立的，不会影响其他进程。这种机制确保了进程之间的安全性和稳定性。

### 补充2：不同进程的虚拟内存地址可以一样吗，物理地址可以一样吗

在不同的进程中，**虚拟内存地址**可以相同，但**物理内存地址**不能直接相同，除非通过特定的内存共享机制。

#### 1. 虚拟内存地址可以一样

由于每个进程都有自己的独立虚拟内存空间，因此在不同进程中，相同的虚拟内存地址可能会被分配到不同的进程。换句话说，不同进程可以拥有相同的虚拟内存地址。

例如，进程A和进程B都有各自的虚拟内存地址空间，假设两个进程都使用了虚拟地址`0x1000`，在它们各自的上下文中，这个地址`0x1000`指向的内存是独立的，互不干扰。这是因为操作系统通过页表和虚拟内存管理机制将这些相同的虚拟地址映射到不同的物理地址上。

#### 2. 物理内存地址可以一样（通过共享）

在通常情况下，不同进程的虚拟内存地址映射到的物理地址是不同的。然而，通过特定的共享机制，不同进程可以共享同一段物理内存。以下是几种常见的共享机制：

- **共享内存**：操作系统提供共享内存机制，使得多个进程可以映射同一块物理内存。这些进程可以通过各自的虚拟地址访问这块共享的物理内存，因此它们在逻辑上共享了物理内存。
- **内存映射文件（mmap）**：通过内存映射文件，多个进程可以将同一文件映射到它们的虚拟内存空间中，进而共享这块文件在物理内存中的内容。

在这些情况下，虽然虚拟地址在不同进程中可能不同，但它们都指向了同一个物理地址，从而实现了物理内存的共享。

#### 总结

- **虚拟内存地址**：不同进程中的虚拟内存地址可以相同，因为虚拟内存是独立的，进程之间互不干扰。
- **物理内存地址**：在正常情况下，不同进程的虚拟内存地址会映射到不同的物理内存地址。通过共享机制（如共享内存或内存映射文件），不同进程的虚拟地址可以映射到同一块物理内存，从而共享相同的物理地址。





### 2.3 并发

本节介绍了并发（concurrency）的概念及其带来的挑战，并通过一个多线程程序示例，展示了在同时处理多个任务时可能出现的问题。

#### 并发的定义与挑战：

- **并发问题的出现**：并发涉及多个任务同时进行，这在操作系统中尤为常见。例如，操作系统需要同时处理多个进程，这种并发行为引发了一系列复杂且有趣的问题。
- **并发的扩展**：并发问题不仅存在于操作系统中，还出现在多线程（multi-threaded）程序中。随着现代计算机的多核架构，多线程程序变得越来越普遍，因此理解并发问题变得尤为重要。

#### 多线程程序示例：

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <pthread.h>  // 包含pthread库的头文件
#include "common.h"   // 包含可能自定义的辅助函数，如Pthread_create和Pthread_join

volatile int counter = 0; // 使用volatile关键字声明全局变量counter，表示可能被多线程修改
int loops; // 全局变量loops，用来表示循环的次数

void *worker(void *arg) { 
    int i; 
    for (i = 0; i < loops; i++) { 
        counter++; // 递增全局变量counter
    } 
    return NULL; 
} 

int 
main(int argc, char *argv[]) 
{ 
    if (argc != 2) { 
        fprintf(stderr, "usage: threads <value>\n"); 
        exit(1); // 如果命令行参数不足，输出错误信息并退出
    } 
    loops = atoi(argv[1]); // 将命令行输入的字符串参数转化为整数并赋值给loops
    pthread_t p1, p2; // 声明两个线程变量p1和p2
    printf("Initial value : %d\n", counter); // 打印初始的counter值
    
    Pthread_create(&p1, NULL, worker, NULL); // 创建第一个线程，执行worker函数
    Pthread_create(&p2, NULL, worker, NULL); // 创建第二个线程，执行worker函数
    Pthread_join(p1, NULL); // 等待第一个线程完成
    Pthread_join(p2, NULL); // 等待第二个线程完成
    printf("Final value : %d\n", counter); // 打印最终的counter值
    return 0; 
}
//实际的调用应该是小写的 pthread_create()。大写版本是我们自己的包装函数，它调用 pthread_create()，甚确保返回现码指示调用成功。详情请参阅现码
```

图 2.5 展示了一个简单的多线程程序（`threads.c`），该程序创建了两个线程，分别执行相同的任务——递增一个共享的计数器。

- **代码分析**：
  - **全局变量**：`volatile int counter = 0;` 定义了一个全局计数器，用于线程间的共享。
  - **线程函数**：`worker(void *arg)` 是线程执行的函数，在线程中循环 `loops` 次，每次循环递增 `counter`。
  - **线程创建**：主程序通过 `Pthread_create()` 创建了两个线程 `p1` 和 `p2`，并分别执行 `worker` 函数。
  - **线程同步**：`Pthread_join(p1, NULL); Pthread_join(p2, NULL);` 用于等待两个线程完成执行，然后主程序输出 `counter` 的最终值。
- **程序运行与预期输出**：
  - 当 `loops` 的值为 1000 时，两个线程各自递增计数器 1000 次，因此预期输出的 `counter` 值应为 2000。

### 补充3：Pthread_create()

```
在 Red Hat/CentOS/Fedora 系列发行版上：
sudo yum install man-pages
sudo yum install glibc-devel
可以使用 man ptread_create查询
```

`Pthread_create` 是一个用于创建新线程的函数，属于 POSIX 线程（pthread）库。这个函数启动一个新线程，该线程将并行执行指定的函数。

#### 函数原型

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```

#### 参数说明

1. **pthread_t \*thread**:
   - 指向 `pthread_t` 类型的变量的指针，用于存储新创建线程的标识符。
   - 线程标识符用于在线程管理函数（如 `pthread_join`）中引用线程。
2. **const pthread_attr_t \*attr**:
   - 指向线程属性对象的指针。如果传递 `NULL`，则使用默认属性。
   - 线程属性用于设置线程的行为，如是否与主线程分离（detached）、线程栈大小、调度策略等。
3. **void \*(\*start_routine)(void \*)**:
   - 函数指针，指定线程启动后执行的函数。
   - 该函数的原型为 `void *function(void *arg)`，它接受一个 `void*` 类型的参数并返回一个 `void*` 类型的结果。
4. **void \*arg**:
   - 传递给 `start_routine` 函数的参数。可以是任何类型的数据，通常通过强制类型转换成 `void*`。
   - 如果不需要传递参数，可以传递 `NULL`。

#### 返回值

- **成功**：返回 `0`，表示线程创建成功。
- 失败：返回错误码，表示线程创建失败。常见的错误码包括：
  - `EAGAIN`: 系统资源不足，无法创建新线程。
  - `EINVAL`: 无效的线程属性。
  - `EPERM`: 权限不足，无法设置所请求的属性。

#### 示例代码

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void *worker(void *arg) {
    printf("Thread is running\n");
    return NULL;
}

int main() {
    pthread_t thread;
    int result;

    result = pthread_create(&thread, NULL, worker, NULL);
    if (result != 0) {
        fprintf(stderr, "Error creating thread: %d\n", result);
        exit(EXIT_FAILURE);
    }

    pthread_join(thread, NULL); // 等待线程结束
    printf("Thread has finished\n");

    return 0;
}
```

#### 代码说明

- **pthread_create**: 创建一个新线程，该线程开始执行 `worker` 函数。
- **pthread_join**: 主线程等待子线程执行完成。
- 如果线程创建失败，`pthread_create` 会返回一个非零的错误码，代码中会检查这个错误码并打印错误信息。

#### 注意事项

- **线程安全**: 多线程编程中需要特别注意数据共享和同步，避免竞争条件。
- **资源管理**: 线程创建和销毁涉及系统资源的分配与释放，滥用线程可能导致资源耗尽。
- **可移植性**: `pthread_create` 是 POSIX 标准的一部分，适用于大多数 Unix 和 Linux 系统，也可在 Windows 上通过兼容库使用。





运行：

```
prompt> gcc -o thread thread.c -Wall -pthread 
prompt> ./thread 1000 
Initial value : 0 
Final value : 2000
```

你可能会猜到，两个线程完成时，计数器的最终值为 2000，因为每个线程将计数增加 1000一。也就是说，当 loops 的输入值设为 *N* 时，我们预计程序的最终输出为 2*N*。但事实证明，事情甚不是那么简单。让我们运行相同的程序，但 loops 的值更高，然后看看会发生什么：

```
prompt> ./thread 100000 
Initial value : 0 
Final value : 143012 // huh?? 
prompt> ./thread 100000 
Initial value : 0 
Final value : 137298 // what the??
```



#### 并发问题的实际表现：

- **非预期结果**：
  - 运行程序时，`loops` 为 100000 的情况下，`counter` 的最终值未达到预期的 200000，而是出现了错误的数值，如 143012 或 137298。这表明程序在高负载下未能正确地处理并发。
  - 进一步运行该程序时，每次得到的 `counter` 值都可能不同，甚至偶尔会得到正确的结果。这种不一致的表现揭示了程序中的并发问题。
- **并发问题的原因**：
  - **指令非原子性**：计数器的递增操作需要三条指令：**从内存加载值到寄存器、递增值、将值存回内存。**然而，这些指令并非原子操作（以原子方式atomicallly执行），**即并不是一一性地执行**，因此可能发生线程间的竞争条件（race condition），导致计数器的值被多个线程错误地更新。
  - **并发问题的深入讨论**：这些并发问题将在本书的第2部分中详细探讨，包括如何构建正确的并发程序、操作系统需要哪些原语（primitives）以及硬件应提供哪些机制来解决这些问题。

### 总结：

本节通过一个多线程程序的示例，阐述了并发问题在现代计算中的重要性与复杂性。程序中的共享资源（如计数器）在并发环境下的非原子性操作导致了不确定且错误的结果。这为后续章节关于并发问题的深入探讨奠定了基础，特别是如何利用操作系统和硬件的支持来正确地处理并发问题。



### 2.4 持久性

本节探讨了持久性（persistence）的概念，强调了在系统中保持数据持久存储的重要性，以及操作系统如何管理这种持久性。

#### 持久性的必要性：

- **易失性存储问题**：内存（如DRAM）是易失性的，意味着断电或系统崩溃时，内存中的所有数据都会丢失。为了避免数据丢失，需要硬件和软件支持将数据持久地存储。
- **硬件解决方案**：硬件层面上，通常通过输入/输出（I/O）设备来实现数据的持久存储。硬盘驱动器（HDD）和固态硬盘（SSD）是常用的长期存储设备，其中SSD因其更高的速度和可靠性，逐渐取代HDD成为主流。

#### 文件系统的角色：

- **文件系统的定义**：操作系统通过文件系统（file system）管理磁盘上的数据。文件系统负责将用户创建的文件可靠且高效地存储在磁盘上。
- **共享文件的机制**：与CPU和内存的虚拟化不同，操作系统并不为每个应用程序创建专用的虚拟磁盘。相反，文件系统假设用户可能需要共享文件信息。例如，在编写C程序时，一个文件可能被多个进程依次使用和修改。

#### I/O程序示例：

图 2.6 展示了一个简单的I/O程序（`io.c`），该程序创建了一个文件并向其中写入数据。

```c
#include <stdio.h> 
#include <unistd.h> 
#include <assert.h> 
#include <fcntl.h> 
#include <sys/types.h> 

int 
main(int argc, char *argv[]) 
{ 
    // 打开或创建文件 /tmp/file，具有写入权限，如果文件已存在则清空
    int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); 
    assert(fd > -1); // 确保文件成功打开，如果失败则程序终止

    // 向文件写入 "hello world\n"，共13个字符
    int rc = write(fd, "hello world\n", 13); 
    assert(rc == 13); // 确保所有字符都成功写入，如果写入失败则程序终止

    // 关闭文件描述符
    close(fd); 

    return 0; // 程序正常结束
}

代码解析
open: 打开指定的文件（路径为 /tmp/file），如果文件不存在则创建，权限设置为 S_IRWXU（文件拥有者可读、写、执行）。使用 O_WRONLY 表示以写入模式打开，O_CREAT 表示如果文件不存在则创建它，O_TRUNC 表示如果文件已存在则清空内容。
assert: 用于检查条件，如果条件为 false，则程序终止。这里用来检查文件是否成功打开（fd > -1）和写入操作是否成功（rc == 13）。
write: 将 "hello world\n" 这段文本写入文件，共写入 13 个字节。
close: 关闭文件描述符，释放系统资源。
```



- **代码分析**：
  - **文件打开**：`open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);` 打开或创建文件 `/tmp/file`，并以只写模式打开，同时设置文件权限。
  - **数据写入**：`write(fd, "hello world\n", 13);` 将字符串 "hello world\n" 写入文件，共写入13个字节。
  - **文件关闭**：`close(fd);` 关闭文件，表示程序不再需要继续写入数据。
- **程序调用的系统调用**：
  - 程序中调用的 `open()`、`write()` 和 `close()` 是操作系统提供的系统调用，通过文件系统来实现这些功能。
  - **文件系统处理这些调用，确定数据应存储在磁盘的哪个位置，并记录这些信息。同时，还负责向底层存储设备发出I/O请求，读取或更新数据。**

#### 文件系统的复杂性：

- 数据持久化的挑战：

  - **I/O操作的延迟与批量处理**：为了提高性能，文件系统通常会延迟写操作，将其批量处理。这种批量写入虽然提高了效率，但也引入了在写入期间系统崩溃时可能导致数据丢失的风险。
  - **复杂的写入协议**：为了解决写入期间的系统崩溃问题，大多数文件系统采用了复杂的写入协议，如日志（journaling）或写时复制（copy-on-write）。这些协议通过仔细排序写入操作，确保即使在故障发生时，系统也能恢复到合理的状态。
  - **数据结构的多样性**：为了实现高效的数据管理，文件系统采用了多种数据结构，从简单的列表到复杂的B树，以优化不同操作的性能。

### 总结：

本节深入探讨了持久性在操作系统中的实现，介绍了文件系统如何通过复杂的机制和数据结构，确保数据在持久存储过程中既能保持高性能，又能应对可能的系统故障。通过对I/O程序的分析，本节为后续章节对持久性、设备、I/O和文件系统的详细讨论奠定了基础。

### 2.5 设计目标

本节讨论了设计和实现操作系统时需要考虑的关键目标，这些目标为系统的功能和性能提供了指导，并在必要时帮助找到合适的折中方案。

#### 抽象（Abstraction）：

- **抽象的重要性**：抽象是设计操作系统时最基本的目标。通过抽象，复杂的系统被划分为易于理解和使用的部分。这种方法在计算机科学的各个领域都非常有用，例如通过高级语言编写程序而不必考虑底层的硬件细节。
- **操作系统的抽象作用**：在操作系统中，抽象使得系统资源（如CPU、内存、磁盘）可以被虚拟化，从而为用户和应用程序提供更为简单的接口。

#### 高性能（Performance）：

- **性能优化**：操作系统的另一个重要目标是提供高性能。虚拟化和易用性虽然重要，但它们不能过多地增加系统开销。因此，操作系统设计者需要在提供功能和降低开销之间找到平衡。
- **开销的形式**：开销可能以额外的时间（更多的指令执行）或额外的空间（内存或磁盘占用）形式出现。设计时必须尽量减少这些开销，以提高系统整体的效率。

#### 保护（Protection）：

- **保护机制**：操作系统需要在应用程序之间以及在操作系统与应用程序之间提供保护。保护机制确保一个程序的恶意行为或错误不会影响其他程序或操作系统本身。
- **隔离的重要性**：保护的关键在于隔离，操作系统通过隔离各个进程，防止它们相互干扰，这是操作系统设计的基本原理之一。

#### 可靠性（Reliability）：

- **系统可靠性**：由于操作系统是所有应用程序运行的基础，其可靠性至关重要。操作系统的失效会导致整个系统崩溃，因此高可靠性是设计操作系统时的一个主要目标。
- **复杂性的挑战**：随着操作系统的复杂性增加，构建一个可靠的操作系统变得更加困难。然而，研究者们通过不断创新，努力提高操作系统的可靠性。

#### 其他设计目标：

- **能源效率（Energy Efficiency）**：在当今的绿色计算环境中，能源效率成为一个重要目标，尤其是在电池供电的移动设备上。
- **安全性（Security）**：作为保护的扩展，安全性对于防范恶意应用程序至关重要，特别是在高度联网的现代系统中。
- **移动性（Mobility）**：随着操作系统在越来越小的设备上运行，移动性成为一个重要的设计目标，确保系统能够在不同的环境中高效运行。

### 总结：

本节总结了操作系统设计的核心目标，包括抽象、高性能、保护、可靠性以及其他如能源效率、安全性和移动性等目标。这些目标指导了操作系统的设计和实现，帮助系统在提供丰富功能的同时，保持高效和可靠的运行。操作系统通过这些设计目标，为用户和应用程序提供了一个稳健的运行环境。

### 2.6 简单历史

本节回顾了操作系统的发展历史，展示了操作系统在不同阶段的演变以及其中积累的关键思想和技术。

#### 早期操作系统：只是一些库

- **最初的操作系统**：在计算的早期，操作系统的功能非常有限，主要提供一组常用的函数库。例如，不同程序员可以共享低级I/O处理的代码，减少了重复工作。
- **批处理系统（Batch Processing）**：在大型机系统中，操作员一一运行程序，决定作业的顺序。计算机的使用是非交互式的，以提高资源利用率。

#### 超越库：保护

- **保护机制的引入**：随着操作系统的发展，意识到操作系统代码的特殊性，并通过系统调用（system call）来实现更正式和受控的资源访问过程。
- **系统调用与用户模式**：系统调用通过硬件机制将控制转移到操作系统，并将特权级别提升到内核模式，允许操作系统进行I/O操作、内存管理等。

#### 多道程序时代

- **多道程序**：随着小型机的兴起，操作系统开始支持多道程序（multiprogramming），通过在多个作业之间快速切换来提高CPU利用率。此时，内存保护和并发问题变得尤为重要。
- **UNIX操作系统的诞生**：UNIX在这个阶段出现，由贝尔实验室的Ken Thompson和Dennis Ritchie开发。UNIX汇集了许多好的想法，并通过简化使其更加实用，迅速传播并成为了影响深远的操作系统。

#### 摩登时代

- **个人计算机的崛起**：随着PC的普及，操作系统也进入了新的阶段。然而，早期的PC操作系统在功能上较为简陋，如DOS系统缺乏内存保护等，导致了系统的不稳定性。
- **现代操作系统的发展**：随着时间推移，小型机操作系统的许多先进功能，如内存保护和多任务处理，逐渐被引入到PC操作系统中。今天的操作系统，如macOS X和Linux，都继承了许多来自UNIX的理念。

### 2.7 小结

本节对整章内容进行了总结，概述了操作系统的基本功能和设计目标，并指出本书将深入探讨的一些核心主题。

- **操作系统的功能**：操作系统通过虚拟化资源、处理并发问题、管理持久性存储等，使得计算机系统更易于使用。现代操作系统大多受到历史发展中积累的理念和技术的影响。
- **未涉及的主题**：本书将重点讨论CPU和内存虚拟化、并发控制和持久性管理，但不会详细探讨网络、图形设备和更深层次的安全问题，这些内容在其他课程中可能会涉及。
- **学习展望**：通过学习本书，读者将对计算机系统的真实工作方式有一个全新的认识，理解操作系统如何通过设计和实现来支持计算机的高效运行。