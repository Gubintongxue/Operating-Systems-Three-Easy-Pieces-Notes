# 第二章 操作系统介绍

不了解计算机程序运行时做的事，这本书和相应的课程对你来说会很困难，停止阅读本书，在继续读本书之前快速学习必要的背景知识（包括Patt/Patel[PP03]，特别是Bryant/O‘Hallarn的书[BOH10]，都是相当不错的）。



一个运行中的程序会不断**执行指令**。

处理器从内存中**获取（fetch）一条指令**，对其进行**解码（decode）**（弄清楚这是哪条指令），然后**执行（execute）它**（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器**继续执行下一条指令**，依此类推，直到**程序最终完成**。

--冯诺依曼计算模型的基本概念。

操作系统（Operating System, OS）: 负责确保系统既易于使用又高效地运行。

- 让程序运行变得容易，甚至允许你同时运行多个程序，允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。

### 关键问题：如何将资源虚拟化

虚拟化，让系统更易于使用。我们关注如何虚拟化：操作系统通过哪些机制和策略来实现虚拟化？操作系统如何有效地实现虚拟化？需要哪些硬件支持？

- 操作系统主要利用一种通用的技术：虚拟化（virtualization）  
- 操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更 强大且更易于使用的虚拟形式。  
- 因此，我们有时将操作系统称为虚拟机（virtual machine ）  
- 操作系统还提供了一些接口（**API**），为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能（如运行程序、分配内存或访问文件）。
  - 实际上典型的操作系统会提供上百个系统调用（system call）,让应用程序调用。
- 由于操作系统提供的这些调用来运行程序、访问内存和设备，并进行其他相关操作，有时也会说OS为应用工程需提供了一个标准库（standard library）。
- 操作系统也被成为资源管理器（resource manager）,因为虚拟化让许多程序运行（从而共享CPU）,让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘）。
  - 每个 CPU、内存和磁盘都是系统的资源（resource），因此操作系统扮演的主要角色就是操理（manage）这些资源，以做到高效或公平，或者实际上考虑其他许多可能的目标。

操作系统实际上做了：

> 1.它取 CPU、内存或磁盘等物理资源（resources），对它们虚拟化（virtualize）  
> 2.它处理与并发（concurrency）有关的麻烦且棘手的问题  
> 3.它持久地（persistently）存储文件，从而使它们长期随全



## 2.1 虚拟化CPU

图 2.1 展示了我们的第一个程序。实际上，它没有太大的作用，它所做的只是调用 Spin()

函数，该函数会反复检查时间甚在运行一秒后返回。然后，它会打印出用户在命令行中传

入的字符串，甚一直重复这样做。

```
#include <stdio.h>        // 包含标准输入输出库，用于 printf 和 fprintf
#include <stdlib.h>       // 包含标准库函数，用于 exit
#include <sys/time.h>     // 包含获取系统时间的库，用于 Spin 函数中的时间处理
#include <assert.h>       // 包含断言库，通常用于调试
#include "common.h"       // 包含自定义的头文件，通常包含 Spin 函数的声明

// 主函数，程序的入口点
int main(int argc, char *argv[]) 
{ 
    // 检查命令行参数的数量是否正确，argc 应该为 2（程序名 + 一个参数）
    if (argc != 2) { 
        // 如果参数数量不正确，打印错误信息并退出程序
        fprintf(stderr, "usage: cpu <string>\n"); 
        exit(1); 
    } 
    
    // 获取命令行参数（字符串），并将其赋值给 str 指针
    char *str = argv[1]; 
    
    // 无限循环，程序会一直运行，直到被手动终止
    while (1) { 
        // 调用 Spin 函数，引入 1 秒的延迟（忙等待）
        Spin(1); 
        // 打印命令行传入的字符串
        printf("%s\n", str); 
    } 
    
    // 返回 0，程序正常结束（这行代码永远不会执行到，因为有无限循环）
    return 0; 
}
```

代码的关键点：

1. **参数检查**：程序首先检查命令行参数的数量是否正确。如果不正确，会打印用法提示并退出。
2. **无限循环**：程序进入一个无限循环，在这个循环中每次都会延迟1秒并打印指定的字符串。
3. **Spin 函数**：引入了人为的延迟，用于模拟程序的等待或暂停。这在某些测试和多线程的场景中可能很有用。

使用场景：

这段代码可以用于测试CPU的负载处理能力，因为它会持续不断地打印一个字符串，同时在每次打印前进行短暂的延迟。



`Spin()` 函数在许多系统编程库或操作系统相关的代码中用于引入一个人为的延迟，通常在处理多线程或并发操作时使用。它的常见实现通常是在循环中进行忙等待。下面是一个可能的实现例子：

```
#include <sys/time.h>

void Spin(int seconds) {
    struct timeval start, end;
    gettimeofday(&start, NULL);
    do {
        gettimeofday(&end, NULL);
    } while ((end.tv_sec - start.tv_sec) < seconds);
}
```

1. `gettimeofday(&start, NULL);`：获取当前的时间戳并存储在 `start` 变量中。
2. `do-while` 循环：循环持续执行，直到经过的时间达到指定的 `seconds`。
3. `gettimeofday(&end, NULL);`：不断更新 `end` 时间戳，直到满足条件 `(end.tv_sec - start.tv_sec) < seconds`。

在这种实现中，`Spin(1)` 将会使程序忙等待约1秒钟。

**注意：** 忙等待（Busy-waiting）会占用CPU资源，一般在实际应用中不建议使用，除非确实需要进行低延迟的轮询。

#### 编译与运行：

- 将代码保存为 

  ```
  cpu.c
  ```

  通过以下命令编译：

  ```
  
  gcc -o cpu cpu.c -Wall
  ```

- 编译后运行程序，若输入 "A" 作为参数，输出如下：

  ```
  ./cpu "A"
  A
  A
  A
  ...
  ```

#### 多实例运行：

- 如果同时运行多个该程序的实例，如图 2.2 所示，使用以下命令：

  ```
  ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
  ```

- 输出将交替显示每个程序的字符串（A、B、C、D），给人一种这些程序在同时运行的错觉。

  ```
  [1] 7353 
  [2] 7354 
  [3] 7355 
  [4] 7356 
  A 
  B 
  D 
  C 
  A 
  B 
  D 
  C 
  A 
  C 
  B 
  D
  ```

#### CPU虚拟化概念：

- 虽然系统只有一个物理CPU，但这些程序看似在同时运行，这种现象称为CPU虚拟化。
- 操作系统通过硬件的支持，创建了一个系统拥有多个虚拟CPU的假象，让用户感觉多个程序在同时执行。
- 将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU（virtualizing the CPU），这是本书第一大部分的关注点。

#### 相关问题：

- 要运行程序甚停止它们，或告诉操作系统运行哪些程序，需要有一些接口（API），你可以利用它们将需求传达给操作系统。我们将在本书中讨论这些 API。事实上，它们是大多数用户与操作系统交互的主要方式。

- 运行多个程序会引发新的问题，如多个程序同时竞争资源时，哪个程序应该优先运行？这些问题由操作系统的策略（policy）来决定。
- 操作系统不仅提供了运行程序的机制（mechanism），还担任了资源管理器（resource manager）的角色，负责资源的分配与调度。

### 总结：

本节通过简单的代码示例，引出CPU虚拟化的概念，解释了如何在单处理器系统上通过操作系统的支持实现多个程序看似同时运行的效果，并引发了对操作系统资源管理策略的探讨。

### 2.2 虚拟化内存

本节介绍了内存的虚拟化过程，通过一个简单的程序展示了操作系统如何为每个进程提供私有的虚拟地址空间，即使这些进程在表面上似乎使用相同的物理内存地址。

#### 物理内存的基础概念：

- **物理内存模型**：现今的物理内存可以被视作一个简单的字节数组。读取（read）或写入（write）内存时，需要指定内存地址，以访问或更新存储在那里的数据。
- **内存的作用**：在程序运行期间，所有的数据结构都保存在内存中。程序通过各种指令访问内存，其中每个指令本身也存储在内存中，因此每条指令的执行都会涉及对内存的访问。

#### 示例程序解析：

图 2.3 中展示了一个示例程序（`mem.c`），该程序通过调用 `malloc()` 来动态分配内存，并反复读取、修改内存中的数据。

- **代码分析**：

  - **内存分配**：程序在第9行调用 `malloc(sizeof(int))` 为一个整数分配内存，并使用指针 `p` 指向该内存地址。
  - **检查分配是否成功**：第10行使用 `assert` 断言 `p` 不为 `NULL`，以确保内存分配成功。
  - **打印内存地址**：第11行打印分配的内存地址及进程标识符（PID），PID 对每个进程是唯一的。
  - **更新内存值**：第13行初始化内存中的值为0，然后程序进入无限循环，每秒递增一次内存中的值并输出结果。

- **程序输出**：

  - 运行 

    ```
    ./mem
    ```

     后，程序会输出内存地址及递增的值，如下所示：

    ```
    bash复制代码prompt> ./mem
    (2134) memory address of p: 00200000
    (2134) p: 1
    (2134) p: 2
    (2134) p: 3
    ...
    ```

#### 多实例运行示例：

图 2.4 展示了同时运行该程序多个实例时的情况。通过以下命令可以运行两个程序实例：

```
bash
复制代码
prompt> ./mem &; ./mem &
```

- 观察现象

  ：

  - 每个程序实例都在相同的地址 `00200000` 处分配了内存，并各自独立地更新了该地址处的值。
  - 这表面上看似不同的程序实例在共享相同的内存地址，但实际上它们各自拥有独立的私有内存空间。

#### 内存虚拟化的概念：

- **虚拟地址空间**：操作系统为每个进程提供了一个独立的虚拟地址空间，进程只能访问自己的虚拟地址空间，而不会影响其他进程或操作系统本身的地址空间。
- **操作系统的角色**：尽管每个进程看似拥有自己的物理内存，实际上，物理内存是一个由操作系统管理的共享资源。操作系统通过将进程的虚拟地址映射到物理内存，确保进程间的内存访问不会相互干扰。

### 总结：

本节通过一个简单的内存访问程序，深入探讨了内存虚拟化的概念，展示了操作系统如何通过虚拟地址空间机制，使得每个进程看似拥有独立的物理内存，而实际上，物理内存是由操作系统管理的共享资源。该内容引出本书第1部分的核心主题：虚拟化（Virtualization）。

### 2.3 并发

本节介绍了并发（concurrency）的概念及其带来的挑战，并通过一个多线程程序示例，展示了在同时处理多个任务时可能出现的问题。

#### 并发的定义与挑战：

- **并发问题的出现**：并发涉及多个任务同时进行，这在操作系统中尤为常见。例如，操作系统需要同时处理多个进程，这种并发行为引发了一系列复杂且有趣的问题。
- **并发的扩展**：并发问题不仅存在于操作系统中，还出现在多线程（multi-threaded）程序中。随着现代计算机的多核架构，多线程程序变得越来越普遍，因此理解并发问题变得尤为重要。

#### 多线程程序示例：

图 2.5 展示了一个简单的多线程程序（`threads.c`），该程序创建了两个线程，分别执行相同的任务——递增一个共享的计数器。

- **代码分析**：
  - **全局变量**：`volatile int counter = 0;` 定义了一个全局计数器，用于线程间的共享。
  - **线程函数**：`worker(void *arg)` 是线程执行的函数，在线程中循环 `loops` 次，每次循环递增 `counter`。
  - **线程创建**：主程序通过 `Pthread_create()` 创建了两个线程 `p1` 和 `p2`，并分别执行 `worker` 函数。
  - **线程同步**：`Pthread_join(p1, NULL); Pthread_join(p2, NULL);` 用于等待两个线程完成执行，然后主程序输出 `counter` 的最终值。
- **程序运行与预期输出**：
  - 当 `loops` 的值为 1000 时，两个线程各自递增计数器 1000 次，因此预期输出的 `counter` 值应为 2000。

#### 并发问题的实际表现：

- **非预期结果**：
  - 运行程序时，`loops` 为 100000 的情况下，`counter` 的最终值未达到预期的 200000，而是出现了错误的数值，如 143012 或 137298。这表明程序在高负载下未能正确地处理并发。
  - 进一步运行该程序时，每次得到的 `counter` 值都可能不同，甚至偶尔会得到正确的结果。这种不一致的表现揭示了程序中的并发问题。
- **并发问题的原因**：
  - **指令非原子性**：计数器的递增操作需要三条指令：从内存加载值到寄存器、递增值、将值存回内存。然而，这些指令并非原子操作，即并不是一一性地执行，因此可能发生线程间的竞争条件（race condition），导致计数器的值被多个线程错误地更新。
  - **并发问题的深入讨论**：这些并发问题将在本书的第2部分中详细探讨，包括如何构建正确的并发程序、操作系统需要哪些原语（primitives）以及硬件应提供哪些机制来解决这些问题。

### 总结：

本节通过一个多线程程序的示例，阐述了并发问题在现代计算中的重要性与复杂性。程序中的共享资源（如计数器）在并发环境下的非原子性操作导致了不确定且错误的结果。这为后续章节关于并发问题的深入探讨奠定了基础，特别是如何利用操作系统和硬件的支持来正确地处理并发问题。

### 2.4 持久性

本节探讨了持久性（persistence）的概念，强调了在系统中保持数据持久存储的重要性，以及操作系统如何管理这种持久性。

#### 持久性的必要性：

- **易失性存储问题**：内存（如DRAM）是易失性的，意味着断电或系统崩溃时，内存中的所有数据都会丢失。为了避免数据丢失，需要硬件和软件支持将数据持久地存储。
- **硬件解决方案**：硬件层面上，通常通过输入/输出（I/O）设备来实现数据的持久存储。硬盘驱动器（HDD）和固态硬盘（SSD）是常用的长期存储设备，其中SSD因其更高的速度和可靠性，逐渐取代HDD成为主流。

#### 文件系统的角色：

- **文件系统的定义**：操作系统通过文件系统（file system）管理磁盘上的数据。文件系统负责将用户创建的文件可靠且高效地存储在磁盘上。
- **共享文件的机制**：与CPU和内存的虚拟化不同，操作系统并不为每个应用程序创建专用的虚拟磁盘。相反，文件系统假设用户可能需要共享文件信息。例如，在编写C程序时，一个文件可能被多个进程依次使用和修改。

#### I/O程序示例：

图 2.6 展示了一个简单的I/O程序（`io.c`），该程序创建了一个文件并向其中写入数据。

- **代码分析**：
  - **文件打开**：`open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);` 打开或创建文件 `/tmp/file`，并以只写模式打开，同时设置文件权限。
  - **数据写入**：`write(fd, "hello world\n", 13);` 将字符串 "hello world\n" 写入文件，共写入13个字节。
  - **文件关闭**：`close(fd);` 关闭文件，表示程序不再需要继续写入数据。
- **程序调用的系统调用**：
  - 程序中调用的 `open()`、`write()` 和 `close()` 是操作系统提供的系统调用，通过文件系统来实现这些功能。
  - 文件系统处理这些调用，确定数据应存储在磁盘的哪个位置，并记录这些信息。同时，还负责向底层存储设备发出I/O请求，读取或更新数据。

#### 文件系统的复杂性：

- 数据持久化的挑战

  ：

  - **I/O操作的延迟与批量处理**：为了提高性能，文件系统通常会延迟写操作，将其批量处理。这种批量写入虽然提高了效率，但也引入了在写入期间系统崩溃时可能导致数据丢失的风险。
  - **复杂的写入协议**：为了解决写入期间的系统崩溃问题，大多数文件系统采用了复杂的写入协议，如日志（journaling）或写时复制（copy-on-write）。这些协议通过仔细排序写入操作，确保即使在故障发生时，系统也能恢复到合理的状态。
  - **数据结构的多样性**：为了实现高效的数据管理，文件系统采用了多种数据结构，从简单的列表到复杂的B树，以优化不同操作的性能。

### 总结：

本节深入探讨了持久性在操作系统中的实现，介绍了文件系统如何通过复杂的机制和数据结构，确保数据在持久存储过程中既能保持高性能，又能应对可能的系统故障。通过对I/O程序的分析，本节为后续章节对持久性、设备、I/O和文件系统的详细讨论奠定了基础。

### 2.5 设计目标

本节讨论了设计和实现操作系统时需要考虑的关键目标，这些目标为系统的功能和性能提供了指导，并在必要时帮助找到合适的折中方案。

#### 抽象（Abstraction）：

- **抽象的重要性**：抽象是设计操作系统时最基本的目标。通过抽象，复杂的系统被划分为易于理解和使用的部分。这种方法在计算机科学的各个领域都非常有用，例如通过高级语言编写程序而不必考虑底层的硬件细节。
- **操作系统的抽象作用**：在操作系统中，抽象使得系统资源（如CPU、内存、磁盘）可以被虚拟化，从而为用户和应用程序提供更为简单的接口。

#### 高性能（Performance）：

- **性能优化**：操作系统的另一个重要目标是提供高性能。虚拟化和易用性虽然重要，但它们不能过多地增加系统开销。因此，操作系统设计者需要在提供功能和降低开销之间找到平衡。
- **开销的形式**：开销可能以额外的时间（更多的指令执行）或额外的空间（内存或磁盘占用）形式出现。设计时必须尽量减少这些开销，以提高系统整体的效率。

#### 保护（Protection）：

- **保护机制**：操作系统需要在应用程序之间以及在操作系统与应用程序之间提供保护。保护机制确保一个程序的恶意行为或错误不会影响其他程序或操作系统本身。
- **隔离的重要性**：保护的关键在于隔离，操作系统通过隔离各个进程，防止它们相互干扰，这是操作系统设计的基本原理之一。

#### 可靠性（Reliability）：

- **系统可靠性**：由于操作系统是所有应用程序运行的基础，其可靠性至关重要。操作系统的失效会导致整个系统崩溃，因此高可靠性是设计操作系统时的一个主要目标。
- **复杂性的挑战**：随着操作系统的复杂性增加，构建一个可靠的操作系统变得更加困难。然而，研究者们通过不断创新，努力提高操作系统的可靠性。

#### 其他设计目标：

- **能源效率（Energy Efficiency）**：在当今的绿色计算环境中，能源效率成为一个重要目标，尤其是在电池供电的移动设备上。
- **安全性（Security）**：作为保护的扩展，安全性对于防范恶意应用程序至关重要，特别是在高度联网的现代系统中。
- **移动性（Mobility）**：随着操作系统在越来越小的设备上运行，移动性成为一个重要的设计目标，确保系统能够在不同的环境中高效运行。

### 总结：

本节总结了操作系统设计的核心目标，包括抽象、高性能、保护、可靠性以及其他如能源效率、安全性和移动性等目标。这些目标指导了操作系统的设计和实现，帮助系统在提供丰富功能的同时，保持高效和可靠的运行。操作系统通过这些设计目标，为用户和应用程序提供了一个稳健的运行环境。

### 2.6 简单历史

本节回顾了操作系统的发展历史，展示了操作系统在不同阶段的演变以及其中积累的关键思想和技术。

#### 早期操作系统：只是一些库

- **最初的操作系统**：在计算的早期，操作系统的功能非常有限，主要提供一组常用的函数库。例如，不同程序员可以共享低级I/O处理的代码，减少了重复工作。
- **批处理系统（Batch Processing）**：在大型机系统中，操作员一一运行程序，决定作业的顺序。计算机的使用是非交互式的，以提高资源利用率。

#### 超越库：保护

- **保护机制的引入**：随着操作系统的发展，意识到操作系统代码的特殊性，并通过系统调用（system call）来实现更正式和受控的资源访问过程。
- **系统调用与用户模式**：系统调用通过硬件机制将控制转移到操作系统，并将特权级别提升到内核模式，允许操作系统进行I/O操作、内存管理等。

#### 多道程序时代

- **多道程序**：随着小型机的兴起，操作系统开始支持多道程序（multiprogramming），通过在多个作业之间快速切换来提高CPU利用率。此时，内存保护和并发问题变得尤为重要。
- **UNIX操作系统的诞生**：UNIX在这个阶段出现，由贝尔实验室的Ken Thompson和Dennis Ritchie开发。UNIX汇集了许多好的想法，并通过简化使其更加实用，迅速传播并成为了影响深远的操作系统。

#### 摩登时代

- **个人计算机的崛起**：随着PC的普及，操作系统也进入了新的阶段。然而，早期的PC操作系统在功能上较为简陋，如DOS系统缺乏内存保护等，导致了系统的不稳定性。
- **现代操作系统的发展**：随着时间推移，小型机操作系统的许多先进功能，如内存保护和多任务处理，逐渐被引入到PC操作系统中。今天的操作系统，如macOS X和Linux，都继承了许多来自UNIX的理念。

### 2.7 小结

本节对整章内容进行了总结，概述了操作系统的基本功能和设计目标，并指出本书将深入探讨的一些核心主题。

- **操作系统的功能**：操作系统通过虚拟化资源、处理并发问题、管理持久性存储等，使得计算机系统更易于使用。现代操作系统大多受到历史发展中积累的理念和技术的影响。
- **未涉及的主题**：本书将重点讨论CPU和内存虚拟化、并发控制和持久性管理，但不会详细探讨网络、图形设备和更深层次的安全问题，这些内容在其他课程中可能会涉及。
- **学习展望**：通过学习本书，读者将对计算机系统的真实工作方式有一个全新的认识，理解操作系统如何通过设计和实现来支持计算机的高效运行。