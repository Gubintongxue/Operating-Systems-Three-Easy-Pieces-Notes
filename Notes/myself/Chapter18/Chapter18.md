### 18.1 分页简介

在内存管理中，分页是一种将虚拟内存分割成固定大小的页面（page）的方法，每个页面对应物理内存中的一个页帧（page frame）。这与分段技术不同，分段是将内存分割成不同大小的段，容易导致外部碎片化问题。分页通过固定大小的页面解决了这一问题，简化了内存的管理和分配。

### 关键问题：如何通过分页实现虚拟内存

分页技术解决了分段存在的碎片化问题，通过将内存分割成固定大小的页面，系统可以更加灵活和高效地管理内存，并且减少了复杂性。

#### 一个简单的例子

为了更清晰地理解分页的基本概念，考虑一个非常简单的示例。假设一个64字节的虚拟地址空间被分成4个16字节的虚拟页面。相应地，物理内存也由定长的页帧组成，在本例中为128字节，共8个页帧。

##### 页表和地址转换

操作系统通过页表（page table）来管理每个虚拟页面在物理内存中的位置。每个进程有自己的页表，记录虚拟页到物理页的映射。通过页表，操作系统可以在物理内存中找到进程虚拟地址空间中的页面。例如，假设一个进程的虚拟页0被映射到物理页帧3，虚拟页1被映射到物理页帧7，依此类推。

当进程访问虚拟地址时，系统需要将该虚拟地址转换为物理地址。这个转换过程分为两步：

1. **虚拟地址分解**：将虚拟地址分为虚拟页号（VPN）和页内偏移量（offset）。在我们的示例中，虚拟地址有6位，其中前2位为VPN，后4位为偏移量。
2. **地址转换**：通过页表将VPN转换为物理页号（PFN），并保留偏移量不变，最终构成物理地址。

##### 例子中的地址转换

假设进程访问虚拟地址21（在二进制中为010101）。首先，系统将其分解为虚拟页号01和偏移量0101。然后，通过查找页表，将虚拟页号01映射到物理页帧7。最终，物理地址为1110101（十进制为117），指向物理内存中正确的数据位置。

### 结论

通过分页，操作系统能够更加灵活地管理内存，避免了分段带来的碎片化问题。同时，分页简化了内存管理的复杂性，提高了系统的效率和可控性。在后续章节中，我们将进一步探讨分页的实现细节，包括页表的存储方式、分页的开销以及如何优化分页系统。

### 18.2 页表存储位置

页表可以非常庞大，特别是在现代计算机中。例如，考虑一个典型的32位地址空间，页面大小为4KB，这意味着虚拟地址分为20位的虚拟页号（VPN）和12位的页内偏移量。因为虚拟页号有20位，所以操作系统需要为每个进程管理2^20（大约一百万）个地址转换。假设每个页表项（PTE）需要4个字节来保存物理地址和其他信息，这就意味着每个进程的页表需要4MB的内存空间。如果有100个进程同时运行，操作系统需要400MB的内存仅仅用来存储这些页表！这表明页表的存储需求非常大，尤其是在多任务环境下。

由于页表可能如此庞大，通常不会将页表存储在处理器的片上缓存或MMU（内存管理单元）中，而是将其存储在物理内存中。这意味着每次访问内存时都需要访问主存来查找页表中的信息，这可能会导致性能问题。为了应对这些问题，操作系统可能会在其物理内存中管理这些页表，并且可能会对内存进行进一步的虚拟化处理。

### 18.3 页表的内容

页表是一种用于将虚拟地址（通常是虚拟页号）映射到物理地址（物理页帧号）的数据结构。最简单的页表结构是线性页表，它是一个数组。操作系统通过虚拟页号访问数组中的相应页表项，以查找物理帧号。

#### 页表项的组成部分

每个页表项（PTE）通常包含多个位，用于控制和管理虚拟内存：

- **有效位（Valid bit）**：指示某个地址转换是否有效。如果页面无效，访问它将导致操作系统产生异常并可能终止进程。有效位使操作系统能够支持稀疏地址空间，不必为每个页面都分配物理内存，从而节省了资源。
- **保护位（Protection bit）**：指示页面是否可以读、写或执行。试图以不允许的方式访问页面时，会触发操作系统异常处理。
- **存在位（Present bit）**：指示页面是否驻留在物理内存中。如果页面已被换出到磁盘，存在位将为0。
- **脏位（Dirty bit）**：指示页面自从加载到内存后是否被修改过。如果页面被修改过，在将其换出到磁盘之前需要将其写回。
- **参考位（Reference bit）**：又称为访问位，用于追踪页面是否被访问过。它在页面替换算法中非常重要，用于确定哪些页面应保留在内存中。

### 18.4 分页：也很慢

在之前的章节中，我们了解到页表可以非常庞大，但它们不仅占用大量内存，还会导致系统变慢。让我们通过一个简单的指令来说明这一点：

```
assembly
复制代码
movl 21, %eax
```

这个指令从虚拟地址 21 读取数据并存储在寄存器 `eax` 中。在执行这个指令时，系统必须首先将虚拟地址 21 转换为物理地址 117，然后从物理地址 117 读取数据。因此，在完成数据加载之前，系统需要访问页表来执行地址转换。

为了找到正确的页表项，硬件会执行以下步骤：

1. **提取虚拟页号（VPN）**：

   ```
   assembly
   复制代码
   VPN = (VirtualAddress & VPN_MASK) >> SHIFT
   ```

2. **计算页表项的地址**：

   ```
   assembly
   复制代码
   PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))
   ```

在这个过程中，硬件会使用页表基址寄存器来指向页表的起始位置，然后通过 VPN 从页表中找到正确的页表项（PTE）。在上面的例子中，虚拟地址 21 对应的 VPN 是 1，页表基址寄存器指向页表的开始位置，硬件会计算出 PTE 的地址并从内存中读取。

一旦找到 PTE，硬件会检查页面是否有效并具有正确的访问权限。如果检查通过，硬件会使用物理页帧号（PFN）与偏移量结合，生成最终的物理地址，并从该地址加载数据到寄存器 `eax` 中。

这个过程涉及多个内存访问，包括页表的访问和实际数据的访问。每次内存访问都需要一个额外的内存引用来查找页表项，这大大增加了系统的开销。结果是，分页机制会使内存访问变得更慢，特别是在频繁内存访问的情况下，系统的性能可能会减慢两倍或更多。

### 18.5 内存追踪

为了更好地理解分页如何影响系统性能，我们可以通过一个简单的内存访问示例来展示使用分页时发生的所有内存访问。假设我们有一个简单的 C 程序，它初始化一个数组：

```
c复制代码int array[1000]; 
for (int i = 0; i < 1000; i++) 
    array[i] = 0;
```

在这个例子中，每次循环迭代都会访问内存，并执行以下操作：

1. 从页表中查找数组的虚拟地址对应的物理地址。
2. 将数据存储到对应的物理地址中。

假设虚拟地址空间为 64KB，页面大小为 1KB，页表存储在物理内存中。虚拟地址到物理地址的映射存储在页表中，每个内存访问都需要查找页表并进行地址转换。

在每次循环迭代中，系统需要执行 10 次内存访问，包括 4 次指令获取、1 次数据存储和 5 次页表访问。随着循环的继续，这些内存访问会随着不同的内存位置变化。

### 18.6 小结

分页是虚拟内存管理中的重要技术，提供了许多优点，如避免外部碎片和支持稀疏地址空间。然而，分页也带来了一些挑战，包括系统变慢和内存浪费。如果不加以改进，分页可能导致大量的额外内存访问，从而降低系统性能。接下来的章节将讨论如何优化分页系统，使其不仅能够工作，而且能高效工作。