### 19.1 TLB 的基本算法

在使用分页（paging）作为内存管理机制时，每次内存访问都需要进行虚拟地址到物理地址的转换。这种转换通常通过查阅页表（page table）来实现，但每次查找页表会导致额外的内存访问，从而引发性能问题。为了解决这一问题，硬件引入了地址转换旁路缓冲存储器（Translation Lookaside Buffer，TLB），它是用于缓存常用的虚拟到物理地址转换的硬件缓存。TLB 使得多数地址转换可以直接通过高速缓存完成，从而减少了对内存的访问次数。

TLB 的基本工作流程如下：

1. **提取虚拟页号（VPN）**：从虚拟地址中提取出虚拟页号（VPN），用于查找对应的物理页帧号（PFN）。
2. **查找 TLB**：硬件首先会在 TLB 中查找该 VPN 对应的转换映射。这一步称为 TLB 查找。
3. **TLB 命中（Hit）**：如果 TLB 中存在该 VPN 的映射（即 TLB 命中），硬件会提取出相应的 PFN，并结合虚拟地址的偏移量，计算出实际的物理地址。随后，硬件访问内存中的该物理地址，完成数据加载。
4. **TLB 未命中（Miss）**：如果 TLB 中没有找到该 VPN 的映射（即 TLB 未命中），硬件需要访问内存中的页表来获取该 VPN 的物理地址映射。页表查找完成后，TLB 会更新缓存条目，将新的映射加入其中。此时，硬件将重试这次内存访问，但由于 TLB 已经被更新，因此这次重试能够命中 TLB，从而快速完成地址转换。

TLB 的命中对于系统性能至关重要。如果命中率高，则大多数地址转换可以通过 TLB 快速完成，避免了频繁访问内存。而 TLB 的未命中则会引发额外的内存访问，带来显著的性能开销。

### 19.2 示例：访问数组

为了更好地理解 TLB 的工作原理，以下通过一个简单的示例来说明 TLB 如何在实际内存访问中提高性能。

假设我们有一个包含 10 个 4 字节整型数的数组，数组的起始虚拟地址为 100。在这个虚拟地址空间中，每页大小为 16 字节，因此虚拟地址可以分成 4 位的虚拟页号（VPN）和 4 位的偏移量。

**内存布局**：

- 数组的第一个元素（a[0]）位于 VPN 为 6，偏移量为 4 的位置。
- 第二、第三个元素（a[1]、a[2]）与 a[0] 位于同一页中，因此它们共享相同的 VPN。
- 第四个元素（a[3]）位于下一个虚拟页（VPN=7），接下来的元素（a[4]…a[6]）也在这一页中。
- 最后，数组的最后 3 个元素（a[7]…a[9]）位于 VPN=8 的页面上。

**程序执行**：

```
c复制代码int sum = 0;
for (int i = 0; i < 10; i++) {
    sum += a[i];
}
```

在这个循环中，每次数组访问都会触发内存访问请求，并且需要进行地址转换。以下是 TLB 在每次数组访问中的表现：

1. **第一次访问 a[0]**：系统尝试加载地址 100，对应 VPN=6。因为这是第一次访问这个页面，TLB 未命中，系统需要查找页表并更新 TLB。
2. **访问 a[1] 和 a[2]**：由于它们和 a[0] 位于同一页，VPN=6，因此这两次访问都能命中 TLB，快速完成。
3. **访问 a[3]**：这次访问对应的新页面（VPN=7），TLB 未命中，系统再次需要查找页表并更新 TLB。
4. **访问 a[4] 到 a[6]**：这些元素都在 VPN=7 页内，因此能够命中 TLB。
5. **访问 a[7]**：触发了第三次 TLB 未命中，因为它位于新的页面（VPN=8）。再次查找页表并更新 TLB 后，TLB 命中后续访问。
6. **访问 a[8] 和 a[9]**：这两个元素都命中 TLB，快速完成。

**TLB 命中率**： 在这个例子中，数组的 10 次访问中有 7 次命中 TLB，3 次未命中，命中率为 70%。在程序首次访问数组时，未命中率相对较高，但随着数组访问的进行，TLB 中缓存了这些页面的映射，命中率逐渐提高。

**局部性**： 程序展示了良好的空间局部性，数组元素在内存中紧密排列，使得多次访问可以利用同一个 TLB 缓存条目。此外，如果数组再次被访问，时间局部性也会显现，因为 TLB 中已经缓存了之前的映射，后续访问将会表现出更高的命中率。

总结来说，TLB 有效地减少了内存访问延迟，通过缓存常用的地址映射，大大提高了内存访问性能。在处理内存密集型任务时，TLB 的作用尤为重要。

### 19.3 谁来处理 TLB 未命中

当系统发生 TLB 未命中时，有两种主要方式来处理这种情况：硬件处理和软件（操作系统）处理。

#### 硬件处理 TLB 未命中

在早期的复杂指令集计算机（CISC）体系结构中，硬件负责处理 TLB 未命中。这种方式下，硬件需要直接访问页表，以找到对应的页表项并更新 TLB。这种机制要求硬件知道页表的确切位置和格式。

具体流程如下：

1. **TLB 未命中**：硬件检测到未命中后，会自动查找存储在内存中的页表。
2. **页表查找**：硬件根据页表基址寄存器（Page-Table Base Register, PTBR）的内容，在内存中查找页表项。
3. **更新 TLB**：找到正确的页表项后，硬件将该转换映射更新到 TLB 中。
4. **重试指令**：更新后，硬件重新执行触发未命中的指令，这次可以直接命中 TLB。

这种方式的优势在于由硬件完全处理，无需操作系统介入，因此处理速度较快。然而，硬件必须固定支持特定的页表结构，这限制了操作系统设计的灵活性。

#### 软件（操作系统）处理 TLB 未命中

在现代精简指令集计算机（RISC）体系结构中，TLB 未命中通常由操作系统处理。这种方法灵活性更高，因为操作系统可以自由选择页表的结构和管理方式。

具体流程如下：

1. **TLB 未命中异常**：硬件检测到 TLB 未命中时，会抛出异常，暂停当前指令流，并将系统转入内核模式。
2. **调用陷阱处理程序**：操作系统的陷阱处理程序被调用，它负责处理这个异常。操作系统在该程序中查找页表，找到正确的页表项。
3. **更新 TLB**：操作系统使用特权指令将找到的页表项加载到 TLB 中。
4. **重试指令**：更新 TLB 后，操作系统返回控制权，硬件重试引发异常的指令，这次可以直接命中 TLB。

这种方法的主要优势在于灵活性：操作系统可以自行管理页表，采用任意数据结构来实现不同的优化策略。此外，硬件只需支持基本的异常处理，简化了硬件设计。

#### 关键区别

在硬件管理的 TLB 中，硬件处理所有细节，操作系统的角色相对较小；而在软件管理的 TLB 中，操作系统负责大部分的处理，这允许操作系统根据具体需求调整管理方式。

#### 防止递归

当操作系统处理 TLB 未命中时，必须避免处理过程本身再次引发 TLB 未命中，导致无限递归。常见的做法包括将处理程序的代码和数据直接映射到物理内存中，或者在 TLB 中保留一些始终有效的项，用于处理关键的内核任务。

#### RISC 与 CISC

在 20 世纪 80 年代，RISC 和 CISC 是计算机体系结构领域的两大流派。RISC 主张简化指令集，依赖编译器生成高效代码；而 CISC 则支持复杂的指令集，直接在硬件中处理更多任务。最终，现代处理器借鉴了两者的优势，融合了两种体系结构的特点，使得处理器在保持高性能的同时具备了更强的灵活性。

总结来说，现代操作系统倾向于使用软件管理的 TLB，因为它提供了更大的灵活性，允许操作系统根据需要进行优化，尽管它在处理 TLB 未命中时可能会稍慢一些。

### 19.4 TLB 的内容

TLB（Translation Lookaside Buffer，地址转换旁路缓冲存储器）是一个关键的硬件组件，用于加速虚拟地址到物理地址的转换。TLB 的内容决定了系统在执行地址转换时的速度和效率。典型的 TLB 大小通常为 32、64 或 128 项，并且是全相联的（fully associative）。全相联意味着 TLB 中的每一项可以存储任何虚拟地址到物理地址的映射，并且硬件可以并行地查找这些映射，找到所需的地址转换。

#### TLB 项的结构

每个 TLB 项通常包含以下几个部分：

- **虚拟页号 (VPN)**：用于标识虚拟地址中的页号。每个虚拟地址都可以分为 VPN 和偏移量两部分。VPN 是 TLB 查找的关键部分。

- **物理帧号 (PFN)**：映射到物理内存中的页帧号。当硬件找到匹配的 VPN 时，它会返回对应的 PFN，并将其与原虚拟地址的偏移量组合，生成实际的物理地址。

- 其他位

  ：除了 VPN 和 PFN，TLB 项还包含一些额外的信息，用于确保内存访问的正确性和安全性。这些位包括：

  - **有效位 (Valid bit)**：指示该 TLB 项是否包含有效的地址映射。如果 TLB 项无效，那么即使 VPN 匹配，也不会使用该项的地址转换信息。
  - **保护位 (Protection bits)**：这些位用来确定对该页的访问权限，例如是否允许读取、写入或执行。如果进程试图进行未授权的访问，硬件将触发异常，通常由操作系统来处理。
  - **地址空间标识符 (Address-Space Identifier, ASID)**：在支持多进程的系统中，ASID 用于标识 TLB 项属于哪个进程，从而避免不同进程之间的地址映射混淆。ASID 允许多个进程共享一个 TLB，而无需在每次上下文切换时清空 TLB。

#### TLB 有效位与页表有效位的区别

TLB 的有效位与页表中的有效位有着不同的含义。页表中的有效位是指特定页表项是否有效，如果无效，表示该页未被进程使用，任何对此页的访问都会触发操作系统的异常处理，通常会导致进程终止。

相反，TLB 中的有效位仅仅表明该 TLB 项是否包含有效的地址映射。系统启动时，TLB 通常是空的，所有项的有效位都被置为无效状态。当进程开始运行并访问内存时，TLB 会逐渐被填满，有效项逐步增加。上下文切换时，通常会将 TLB 中所有项的有效位设置为无效，以防止新的进程错误地使用上一个进程的地址映射。

#### 其他关键位

除了有效位和保护位，TLB 中还可能包含以下位：

- **脏位 (Dirty bit)**：指示该页是否被修改过。如果页被修改，脏位会被设置为 1，这在页被换出时尤为重要。
- **参考位 (Reference bit)**：也称为访问位（Accessed bit），用于跟踪页面是否被访问过。这些信息对于实现页替换算法非常有用。

TLB 中的这些位为操作系统和硬件提供了必要的信息，以确保地址转换的正确性和效率，并在上下文切换和内存管理过程中提供必要的支持。

### 19.5 上下文切换时对 TLB 的处理

当系统进行上下文切换时（即从一个进程切换到另一个进程），由于不同进程的虚拟地址空间是独立的，因此存储在 TLB 中的虚拟到物理地址映射信息对于新进程是无效的。如果不加以处理，新进程可能会误用前一个进程的地址映射，导致错误的内存访问。这就引出了一个重要的问题：在上下文切换时，如何处理 TLB 的内容？

#### 1. 清空（Flush）TLB

最直接的解决方案是在每次上下文切换时清空 TLB。清空操作会将 TLB 中所有的有效位（valid bit）置为 0，这样在新进程开始执行时，TLB 会被重新填充当前进程的地址映射。这种方法可以确保不同进程之间的地址映射不会混淆，但它也有一个明显的缺点：每次切换到新进程时，TLB 必须重新加载映射，导致初次访问的内存操作都会触发 TLB 未命中，增加了开销。

清空 TLB 的操作通常可以通过软件管理的方式来实现，例如在操作系统中通过特权指令来执行。此外，如果是硬件管理的 TLB，硬件也可以在检测到页表基址寄存器（Page-Table Base Register, PTBR）变化时自动清空 TLB。

#### 2. 使用地址空间标识符（ASID）

为了解决每次上下文切换都要清空 TLB 的开销问题，一些系统引入了地址空间标识符（Address Space Identifier, ASID）。ASID 是一个小的标识符，通常比进程标识符（PID）短（例如，ASID 可能只有 8 位，而 PID 通常有 32 位），用来标识 TLB 中的每一条转换映射属于哪个进程。

当 TLB 中的每个条目都包含 ASID 时，系统可以在上下文切换时不清空 TLB，因为硬件会检查当前进程的 ASID，确保只有与当前进程 ASID 匹配的 TLB 项才会被使用。这样一来，TLB 可以同时保存多个进程的地址映射信息，不同进程间不会相互干扰。

例如，假设进程 P1 的 ASID 是 1，P2 的 ASID 是 2。当 TLB 中存在 P1 和 P2 的地址映射时，硬件可以通过检查 ASID 字段来区分这些映射属于哪个进程，从而避免误用。这个方法的一个显著优势是减少了 TLB 未命中的频率，提高了系统的性能，尤其是在频繁上下文切换的场景下。

#### 3. 处理特殊情况

还有一种特殊情况需要考虑，即当两个不同的进程共享相同的物理页时，如何处理 TLB 中的映射。例如，两个进程 P1 和 P2 可能会共享同一个代码段，而这个代码段位于相同的物理页内。在这种情况下，虽然两个进程的虚拟页号不同，但它们的物理页号相同。此时，ASID 的使用能够确保即使两个进程共享相同的物理页，它们的虚拟地址空间依然是独立的，不会因为共享的物理页而导致混淆。

通过引入 ASID，不同进程可以在同一个 TLB 中同时拥有自己的地址映射，从而避免了在每次上下文切换时频繁清空 TLB 的性能开销。

总结来说，TLB 在上下文切换时的处理方法主要有两种：清空 TLB 和使用 ASID。清空 TLB 是一种简单但性能较低的方案，而使用 ASID 则提供了一种高效的方法，能够在保证不同进程地址空间独立性的同时提高系统性能。

### 19.6 TLB 替换策略

TLB（Translation Lookaside Buffer）是虚拟内存系统中至关重要的硬件缓存，用于加速虚拟地址到物理地址的转换。然而，TLB 的容量是有限的，这意味着在需要插入新地址映射时，必须替换掉一个旧项。这就引发了一个关键问题：如何选择合适的替换策略，最大限度地减少 TLB 未命中率？

#### 关键问题：如何设计 TLB 替换策略

在 TLB 中替换哪个旧项是一个至关重要的设计决策。一个好的替换策略可以显著减少 TLB 未命中率，从而提升系统性能。以下是几种常见的 TLB 替换策略：

1. **最近最少使用（Least Recently Used, LRU）策略**：
   - LRU 策略基于内存访问的局部性原理，假设最近使用过的项更有可能在短期内再次使用，而较久未使用的项可能不会很快被访问。LRU 会替换掉最久未使用的 TLB 项。
   - **优点**：LRU 能够较好地适应具有强时间局部性的访问模式，因此在许多实际应用中表现良好。
   - **缺点**：实现 LRU 策略需要额外的硬件复杂度来记录和管理每个 TLB 项的使用顺序，这可能增加系统的实现成本。
2. **随机（Random）策略**：
   - 随机策略在每次需要替换时，随机选择一个 TLB 项进行替换。
   - **优点**：实现简单，不需要额外的硬件开销和复杂的算法逻辑。
   - **缺点**：未命中率相对较高，尤其是在程序的访问模式具有明显局部性时，随机替换可能不如 LRU 有效。
3. **FIFO（First In, First Out）策略**：
   - FIFO 策略会替换掉最早插入 TLB 的项，即先进先出。
   - **优点**：实现相对简单，不需要跟踪每个项的使用历史，只需记录插入顺序。
   - **缺点**：FIFO 可能无法充分利用程序的局部性，因为它忽略了项的使用频率和最近访问情况。
4. **LFU（Least Frequently Used）策略**：
   - LFU 策略会替换掉使用频率最低的 TLB 项，基于这样的假设：使用频率低的项未来被访问的可能性较小。
   - **优点**：在一些重复访问模式下，LFU 可能比 LRU 更有效。
   - **缺点**：需要额外的硬件或算法来跟踪每个项的访问次数，这增加了复杂性。此外，LFU 可能对突发访问模式反应迟缓。

在选择 TLB 替换策略时，需要平衡复杂性与性能收益。尽管 LRU 通常被认为是一个合理的选择，但其实现难度较大；随机策略虽然简单，但可能在特定情况下表现不佳。因此，具体选择应结合系统设计目标和典型工作负载的特性。

### 19.7 实际系统的 TLB 表项

在实际系统中，TLB 的设计和实现因架构不同而有所差异。以下是 MIPS R4000 处理器的 TLB 设计，展示了如何在现代硬件中管理虚拟地址到物理地址的转换。

#### MIPS R4000 TLB 表项结构

MIPS R4000 是一种使用软件管理 TLB 的现代处理器，其 TLB 表项设计如图 19.4 所示。

**图 19.4 MIPS 的 TLB 项**（示意图请自行补充）

MIPS R4000 支持 32 位地址空间，页大小为 4KB。因此，在典型的虚拟地址中，我们会看到 20 位的虚拟页号（VPN）和 12 位的偏移量。然而，在 MIPS TLB 中，虚拟页号（VPN）实际上只有 19 位，因为用户地址空间只占整个地址空间的一半（其余部分留给内核）。VPN 在 TLB 中转换为最大 24 位的物理页帧号（PFN），这意味着 MIPS R4000 可以支持最多 64GB 物理内存（224 个 4KB 页）。

MIPS TLB 还包含一些其他有用的标志位：

- **全局位（Global, G）**：指示该页是否为所有进程全局共享。如果设置为 1，则忽略 ASID（地址空间标识符），使得该页映射对所有进程都有效。
- **ASID（地址空间标识符）**：通常为 8 位，用于区分不同进程的地址空间。ASID 有效解决了在不同进程间切换时，TLB 中地址映射的冲突问题。
- **一致性位（Coherence, C）**：用于控制该页在缓存中的一致性策略（此部分超出了本书的范围）。
- **脏位（Dirty bit, D）**：指示该页是否已被修改。脏位通常用于写回策略的管理，帮助操作系统决定是否将页面写回到磁盘。
- **有效位（Valid bit, V）**：指示该项是否为有效的地址映射，帮助硬件区分哪些 TLB 项可以用于地址转换。

MIPS 的 TLB 通常有 32 项或 64 项，大多数项目供用户进程使用，还有一些项目为操作系统保留。这些保留的项用于关键时刻，特别是在 TLB 未命中处理程序中，这些情况下 TLB 未命中可能会导致严重的性能问题。

由于 MIPS TLB 是软件管理的，系统提供了一些指令来操作 TLB，包括：

- **TLBP**：查找指定的转换映射是否在 TLB 中。
- **TLBR**：读取 TLB 中的内容到指定寄存器中。
- **TLBWI**：替换指定的 TLB 项。
- **TLBWR**：随机替换一个 TLB 项。

这些指令是特权指令，只能由操作系统使用。这样可以避免用户程序恶意或错误地修改 TLB 的内容，确保系统的稳定性和安全性。

### 19.8 小结

在本章中，我们探讨了通过使用 TLB 来加速地址转换的方法。TLB 是一个小型、高速的缓存，用于存储虚拟地址到物理地址的转换信息，极大地减少了每次内存访问时的页表查找开销，使虚拟内存系统的性能接近于没有虚拟化的情况下。

然而，TLB 的局限性也显而易见。当程序短时间内访问的页数超过 TLB 的容量时，会导致大量的 TLB 未命中，显著降低系统性能。为了应对这种情况，现代处理器通常支持更大的页，增加 TLB 的覆盖范围。此外，TLB 访问本身也可能成为 CPU 流水线的瓶颈，特别是在涉及物理地址索引缓存时。这些问题促使研究人员开发了各种优化技术，例如虚拟地址索引缓存，以改善性能。

总的来说，TLB 是现代计算机体系结构中的一个关键组件，它的设计和优化直接影响到系统的整体性能。理解 TLB 的工作原理和优化策略对于系统设计者和操作系统开发者来说至关重要。