## 第20章 分页：较小的表

​		我们现在来解决分页引入的第二个问题：==页表太大，因此消耗的内存太多。==让我们从线性页表开始。你可能会记得，线性页表变得相当大。假设一个 32 位地址空间（232 字节），4KB（212 字节）的页和一个 4 字节的页表项。一个地址空间中大约有一百万个虚拟页面（232/212）。乘以页表项的大小，你会发现页表大小为 4MB。回想一下：通常系统中的每个进程都有一个页表！有一百个活动进程（在现代系统中并不罕见），就要为页表分配数百兆的内存！因此，要寻找一些技术来减轻这种沉重的负担。有很多方法，所以我们开始吧。

但先看我们的关键问题：



![image-20240906104242100](image/image-20240906104242100.png)



#### ==补充：页（Page）和页表项（Page Table Entry, PTE）是内存管理中两个重要但不同的概念。以下是它们的定义、区别和联系：==

##### 页（Page）

- **定义**：页是虚拟内存管理中将内存划分为固定大小的块，通常是 4KB 或更大的单位。虚拟内存和物理内存都被分成页，这使得内存管理更为简单和高效。
- **作用**：页是内存分配的基本单位。操作系统通过将虚拟地址空间划分为多个页来管理内存，每个页都具有一个唯一的虚拟页号（VPN）。
- **虚拟页和物理页**：
  - **虚拟页**：属于虚拟地址空间，由操作系统为每个进程提供独立的内存视图。
  - **物理页**：实际存在于物理内存（RAM）中，用于存储程序数据和代码。

##### 页表项（Page Table Entry, PTE）

- **定义**：页表项是页表中的一项，它用于存储虚拟页到物理页帧的映射信息。页表是由页表项组成的数据结构，每个虚拟页对应一个页表项。
- **作用**：页表项包含的关键信息包括：
  - **物理页帧号（PFN）**：指示虚拟页对应的物理内存中的页帧。
  - **有效位**：指示该页是否在物理内存中。
  - **权限位**：指示页的访问权限（如读、写、执行）。
  - **其他控制位**：如脏位（页是否被修改过）、访问位（页是否被访问过）。

##### 页和页表项的区别

- **本质**：
  - **页**：是内存中的实际数据块，是虚拟内存的一个单位。
  - **页表项**：是页表中的一条记录，是虚拟页到物理页帧的映射信息。
- **层次**：
  - **页**：存在于虚拟地址空间和物理内存中。
  - **页表项**：存在于页表中，是用于管理页的映射关系的结构。
- **角色**：
  - **页**：用于存储数据和指令。
  - **页表项**：用于管理和翻译虚拟地址到物理地址的过程。

##### 页和页表项的联系

- **映射关系**：页表项记录了虚拟页（VPN）与物理页帧（PFN）之间的映射。通过页表项，操作系统可以将虚拟地址转换为物理地址，从而访问物理内存中的数据。
- **访问过程**：
  1. 当 CPU 访问一个虚拟地址时，地址被拆分为虚拟页号（VPN）和页内偏移量。
  2. 操作系统查找页表，根据虚拟页号找到对应的页表项。
  3. 从页表项中提取物理页帧号（PFN），并结合页内偏移量生成物理地址。
  4. 最终访问物理内存中的数据。
- **页表的重要性**：页表及其页表项是虚拟内存管理的核心机制之一。它们使得每个进程能够拥有一个独立的虚拟地址空间，同时通过映射机制高效利用物理内存。

总之，页和页表项是虚拟内存管理中密切相关的两个概念：页是数据存储的实际单位，而页表项则是管理这些页的工具，通过它们之间的协作实现了内存的高效管理和访问控制。



#### ==补充：页表项（Page Table Entry, PTE）和 TLB（Translation Lookaside Buffer）是内存管理中两种不同的机制，但它们都与虚拟地址到物理地址的转换相关。以下是它们的区别和联系：==

##### 页表项（Page Table Entry, PTE）

- **定义**：页表项是页表中的一项，包含虚拟页号（VPN）到物理页帧号（PFN）的映射信息。页表项通常还包含其他控制信息，如访问权限、有效位、脏位和访问位等。
- **作用**：
  - 存储虚拟页到物理页的映射。
  - 管理和控制对内存页面的访问权限。
  - 支持操作系统进行内存管理和地址转换。
- **工作机制**：
  - 当 CPU 访问一个虚拟地址时，通过页表查找相应的页表项来获得物理地址。
  - 页表项直接从内存中读取，因此访问速度相对较慢。

##### TLB（Translation Lookaside Buffer）

- **定义**：TLB 是一个小型的、高速的缓存，用于存储最近使用的虚拟页号到物理页帧号的映射。它位于 CPU 内部，作为硬件组件存在。
- **作用**：
  - 缓存最近访问的页表项，以加速虚拟地址到物理地址的转换。
  - 减少对页表的访问次数，从而提高系统性能。
- **工作机制**：
  - 当 CPU 访问虚拟地址时，首先查询 TLB。
  - 如果 TLB 中存在对应的映射（称为 TLB 命中），则直接使用该映射进行地址转换。
  - 如果 TLB 中没有找到对应的映射（称为 TLB 未命中），则需要访问页表来获取映射，并将其加载到 TLB 中，以便后续访问更快。

##### 页表项和 TLB 的区别

- **本质**：
  - **页表项**：是存储在内存中的数据结构，包含虚拟页到物理页的映射信息。
  - **TLB**：是存储在 CPU 内部的缓存，用于加速地址转换。
- **存储位置**：
  - **页表项**：存在于主存（RAM）中的页表。
  - **TLB**：是 CPU 内部的缓存硬件。
- **访问速度**：
  - **页表项**：访问速度相对较慢，因为需要通过内存访问。
  - **TLB**：访问速度非常快，因为它是 CPU 的缓存部分。
- **大小**：
  - **页表项**：页表通常较大，涵盖所有虚拟页的映射。
  - **TLB**：大小有限，一般只缓存有限数量的最近使用的映射。

##### 页表项和 TLB 的联系

- **协同工作**：页表项和 TLB 协同工作以实现虚拟内存到物理内存的地址转换。
- **加速地址转换**：
  - 当 CPU 访问虚拟地址时，首先查找 TLB。如果 TLB 命中，直接使用缓存的映射信息进行转换。
  - 如果 TLB 未命中，则查找页表获取对应的页表项，将其加载到 TLB 中，并完成地址转换。
- **TLB 的作用是减少页表访问**：因为页表项存储在较慢的主存中，直接访问页表会降低性能。TLB 通过缓存页表项，显著减少了对页表的直接访问，从而提高了虚拟内存系统的效率。
- **一致性管理**：当页表项更新时（如更改页面的映射或权限），TLB 也需要同步更新，否则可能导致错误的地址转换或权限检查。这通常通过 TLB 刷新（TLB Flush）来实现。

总结来说，页表项是虚拟地址到物理地址映射的存储单位，而 TLB 是用来加速这个映射过程的缓存。页表项是数据结构，而 TLB 是硬件组件，它们之间通过缓存机制联系紧密，共同提升系统的内存管理性能。



### 20.1 简单的解决方案：更大的页

==解决页表过大的一个简单方法是增大页面的大小。通过增大页的大小，页表中的页数减少，从而显著减小页表的大小。==

#### 多种页大小的使用

许多现代处理器架构（如 MIPS、SPARC、x86-64）支持多种页大小。==通常情况下，小页面（4KB 或 8KB）用于大多数操作，但对于某些特定应用（如数据库管理系统），可以使用更大的页面（如 4MB）。大页面可以减少 TLB 的压力，因为大页面意味着需要的 TLB 项更少。==

尽管使用更大的页面可以减少页表的大小和 TLB 的负载，==**但它也带来了内部碎片的问题**。即使只有部分页面被使用，整个页面的空间也会被分配，这可能导致内存的浪费。==因此，大多数系统在常见情况下仍使用较小的页面大小，如 4KB 或 8KB。



#### 原文：

​		可以用一种简单的方法减小页表大小：使用更大的页。再以 32 位地址空间为例，但这次假设用 16KB 的页。因此，会有 18 位的 VPN 加上 14 位的偏移量。假设每个页表项（4字节）的大小相同，现在线性页表中有 218 个项，因此每个页表的总大小为 1MB，页表缩到四分之一。

![image-20240906105138189](image/image-20240906105138189.png)

​		然而，这种方法的主要问题在于，大内存页会导致每页内的浪费，这被称为内部碎片（internal fragmentation）问题（因为浪费在分配单元内部）。因此，结果是应用程序会分配页，但只用每页的一小部分，而内存很快就会充满这些过大的页。因此，大多数系统在常见的情况下使用相对较小的页大小：4KB（如 x86）或 8KB（如 SPARCv9）。问题不会如此简单地解决。



### 20.2 混合方法：分页和分段

​		在解决复杂问题时，结合不同的方法往往能带来更好的结果。==分页和分段的结合就是一种杂合方法，旨在减少页表的内存开销。==

#### 分页和分段结合的原因

​		==通过回顾线性页表的使用情况，我们可以看到，典型的地址空间往往会有很大一部分未被使用==。比如，一个 16KB 地址空间，使用 1KB 的页面，那么就会有许多页表项是无效的。如果将这种情况扩展到 32 位地址空间，==未使用的页表项数量会变得非常巨大，造成极大的内存浪费。==

#### 杂合方案的实现

​		杂合方法的关键思想是将分页和分段结合起来。==我们不再为整个进程的地址空间提供一个单一的页表，而是为每个逻辑段（如代码段、堆段、栈段）分别提供页表。每个段的页表大小与该段的实际使用情况相匹配，从而减少内存浪费。==

​		在这种方案中，每个段都有自己的基址寄存器和界限寄存器。基址寄存器指向该段的页表的物理地址，界限寄存器则指示该页表的结尾。在进行地址转换时，系统会根据段标识符（SN）选择相应的基址寄存器，结合虚拟页号（VPN）计算页表项的地址。

​		通过这种方法，我们可以显著减少页表的大小，同时保留分页和分段的优点。然而，这种方法并非没有缺点。==由于仍然使用了分段，杂合方案可能会导致外部碎片问题，而且对于那些具有大而稀疏地址空间的应用程序，页表仍可能会浪费大量空间。==



#### 原文：

​		在生活中，每当有两种合理但不同的方法时，你应该总是研究两者的结合，看看能否两全其美。我们称这种组合为杂合（hybrid）。例如，为什么只吃巧克力或简单的花生酱，而不是将两者结合起来，就像可爱的花生酱巧克力杯[M28]？

​		多年前，Multics 的创造者（特别是 Jack Dennis）在构建 Multics 虚拟内存系统时，偶然发现了这样的想法[M07]。具体来说，Dennis 想到将分页和分段相结合，以减少页表的内存开销。更仔细地看看典型的线性页表，就可以理解为什么这可能有用。假设我们有一个地址空间，其中堆和栈的使用部分很小。例如，我们使用一个16KB 的小地址空间和 1KB 的页（见图 20.1）。该地址空间的页表如表 20.1 所示。

​		这个例子假定单个代码页（VPN 0）映射到物理页 10，单个堆页（VPN 4）映射到物理页 23，以及地址空间另一端的两个栈页（VPN 14 和 15）被分别映射到物理页 28 和 4。从图 20.1 中可以看到，大部分页表都没有使用，充满了无效的（invalid）项。真是太浪费了！这是一个微小的 16KB 地址空间。想象一下 32 位地址空间的页表和所有潜在的浪费空间！真的，不要想象这样的事情，太可怕了。

![image-20240827092451979](image/image-20240827092451979.png)



![image-20240827092632660](image/image-20240827092632660.png)

![image-20240827092640339](image/image-20240827092640339.png)

​		因此，==我们的杂合方法不是为进程的整个地址空间提供单个页表，而是为每个逻辑分段提供一个==。在这个例子中，我们可能有 3 个页表，地址空间的代码、堆和栈部分各有一个。

​		现在，回忆在分段中，有一个基址（base）寄存器，告诉我们每个段在物理内存中的位置，还有一个界限（bound）或限制（limit）寄存器，告诉我们该段的大小。在杂合方案中，

​		我们仍然在 MMU 中拥有这些结构。在这里，我们使用基址不是指向段本身，而是保存该段的页表的物理地址。界限寄存器用于指示页表的结尾（即它有多少有效页）。我们通过一个简单的例子来澄清。假设 32 位虚拟地址空间包含 4KB 页面，并且地址空间分为 4 个段。在这个例子中，我们只使用 3 个段：一个用于代码，另一个用于堆，还有一个用于栈。

​		要确定地址引用哪个段，我们会用地址空间的前两位。假设 00 是未使用的段，01 是代码段，10 是堆段，11 是栈段。因此，虚拟地址如下所示：

![image-20240827092727405](image/image-20240827092727405.png)

​		在硬件中，假设有 3 个基本/界限对，代码、堆和栈各一个。当进程正在运行时，每个段的基址寄存器都包含该段的线性页表的物理地址。因此，系统中的每个进程现在都有 3 个与其关联的页表。在上下文切换时，必须更改这些寄存器，以反映新运行进程的页表的位置。

​		在 TLB 未命中时（假设硬件管理的 TLB，即硬件负责处理 TLB 未命中），硬件使用分段位（SN）来确定要用哪个基址和界限对。然后硬件将其中的物理地址与 VPN 结合起来，形成页表项（PTE）的地址：

```C
SN = (VirtualAddress & SEG_MASK) >> SN_SHIFT 
VPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT 
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
```

​		这段代码应该看起来很熟悉，它与我们之前在线性页表中看到的几乎完全相同。当然，唯一的区别是使用 3 个段基址寄存器中的一个，而不是单个页表基址寄存器。

​		杂合方案的关键区别在于，每个分段都有界限寄存器，每个界限寄存器保存了段中最大有效页的值。例如，如果代码段使用它的前 3 个页（0、1 和 2），则代码段页表将只有 3个项分配给它，并且界限寄存器将被设置为 3。内存访问超出段的末尾将产生一个异常，并可能导致进程终止。以这种方式，与线性页表相比，杂合方法实现了显著的内存节省。栈和堆之间未分配的页不再占用页表中的空间（仅将其标记为无效）。

​		但是，你可能会注意到，这种方法并非没有问题。首先，它仍然要求使用分段。正如我们讨论的那样，分段并不像我们需要的那样灵活，因为它假定地址空间有一定的使用模式。例如，如果有一个大而稀疏的堆，仍然可能导致大量的页表浪费。其次，这种杂合导致外部碎片再次出现。尽管大部分内存是以页面大小单位管理的，但页表现在可以是任意大小（是 PTE 的倍数）。因此，在内存中为它们寻找自由空间更为复杂。出于这些原因，人们继续寻找更好的方式来实现更小的页表。

![image-20240906105656384](image/image-20240906105656384.png)





### 20.3 多级页表

​		多级页表（multi-level page table）是一种有效地解决页表空间浪费问题的方法。其基本思想是通过将页表分层组织成类似树的结构，使得仅为有效的虚拟地址分配页表空间，从而减少内存的消耗。多级页表在许多现代系统中得到了应用，例如 x86 架构。

#### 多级页表的结构

​		在多级页表中，页表被分割成多个页面，每个页面由页目录（page directory）管理。如果某个页表页面中的所有页表项（PTE）都是无效的，那么整个页表页面就不会被分配内存。页目录则用于记录哪些页表页面是有效的，并指向它们在内存中的位置。

​		图 20.2 展示了一个多级页表的示例。左侧显示了经典的线性页表，其中即使地址空间中的大部分中间区域无效，仍然需要为这些区域分配页表空间。右侧则是一个多级页表。可以看到，只有页表的两页被标记为有效，因此只需要为这两页分配内存。

​		在一个简单的两级页表中，页目录为每页页表包含一项（PDE，Page Directory Entry）。PDE 包含有效位（valid bit）和页帧号（page frame number, PFN）。如果 PDE 的有效位为 1，则表示该 PDE 指向的页表页面中至少有一个有效的 PTE；如果有效位为 0，则该 PDE 无效，页表页面不存在。

#### 多级页表的优势

1. **节省内存**：多级页表的主要优势在于其内存使用量与实际使用的地址空间成比例。对于稀疏的地址空间，多级页表只需要为那些实际使用的页面分配页表空间，而不会浪费内存。
2. **易于管理**：通过将页表的每一部分组织成页面大小的单位，操作系统可以更加容易地管理页表。例如，当需要增加或删除页表项时，操作系统只需对整个页面进行操作，而无需处理连续的大块内存。
3. **减少碎片**：多级页表避免了线性页表中必须分配连续大块内存的需求。通过使用页目录来分层管理页表项，多级页表允许页表页面分散在物理内存的各个位置，减少了内存碎片。

#### 多级页表的劣势

​		然而，多级页表也有其缺点。首先，多级页表的实现比线性页表更为复杂。无论是硬件还是操作系统都需要处理多级页表的查找操作，这增加了系统的复杂性。其次，在 TLB 未命中的情况下，多级页表的地址转换需要更多的内存访问（例如，两次访问，一次用于页目录，一次用于页表项），这会导致性能上的开销。

#### 示例：构建多级页表

​		为了更好地理解多级页表的工作原理，我们来看一个具体的例子。假设有一个大小为 16KB 的地址空间，其中包含 64 字节的页面。这个地址空间有一个 8 位的虚拟页号（VPN）和 6 位的偏移量（offset）。即使这个地址空间只有一小部分被使用，线性页表仍然会有 256 个项（2^8），即占用 1KB 的内存。

我们可以将这个地址空间的页表分为 16 个页面，每个页面包含 16 个 PTE。接下来，我们使用 VPN 的前 4 位来索引页目录（Page Directory），找到对应的页表页面。如果该页表页面存在，我们再用 VPN 的后 4 位来索引页表，找到对应的 PTE，最终得到物理地址。

例如，假设我们有一个地址空间，其中：

- VPN 0 和 1 用于代码段，
- VPN 4 和 5 用于堆，
- VPN 254 和 255 用于栈。

​		在多级页表中，我们首先查找页目录，找到指向代码段、堆和栈的页表页面。然后再从这些页表页面中找到对应的 PTE，最终得到物理地址。通过这种方式，我们可以避免为未使用的地址空间分配内存。

#### 多级页表的扩展

​		在某些情况下，两级页表可能还不够用。对于更大的地址空间，可能需要使用更多级的页表。例如，假设我们有一个 30 位的虚拟地址空间和 512 字节的页面。这时，我们可能需要使用三级或更多级的页表来管理地址转换。

​		每增加一级页表，都会在地址转换过程中增加一次内存访问。但与此同时，每一级页表都会减少内存的占用，从而达到节省内存的目的。

### 地址转换过程

多级页表的地址转换过程如下：

1. **TLB 查找**：首先，硬件会检查 TLB 中是否存在该虚拟地址的转换映射。如果命中，直接得到物理地址。
2. **页目录查找**：如果 TLB 未命中，硬件将使用虚拟地址的前几位索引页目录，找到对应的页目录项。
3. **页表查找**：然后，硬件使用虚拟地址的下一部分索引页表，找到对应的页表项（PTE）。
4. **物理地址生成**：最后，硬件根据 PTE 生成物理地址，并进行内存访问。

通过这种方式，多级页表在节省内存的同时，实现了高效的地址转换。



#### ==原文：==

​		另一种方法并不依赖于分段，但也试图解决相同的问题：如何去掉页表中的所有无效区域，而不是将它们全部保留在内存中？我们将这种方法称为多级页表（multi-level page table），因为它将线性页表变成了类似树的东西。这种方法非常有效，许多现代系统都用它（例如 x86 [BOH10]）。我们现在详细描述这种方法。

​		多级页表的基本思想很简单。==首先，将页表分成页大小的单元。然后，如果整页的页表项（PTE）无效，就完全不分配该页的页表。==为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为页目录（page directory）的新结构。页目录因此可以告诉你页表的页在哪里，或者页表的整个页不包含有效页。

​		==图 20.2 展示了一个例子。图的左边是经典的线性页表。即使地址空间的大部分中间区域无效，我们仍然需要为这些区域分配页表空间（即页表的中间两页）。==右侧是一个多级页表。页目录仅将页表的两页标记为有效（第一个和最后一个）；因此，页表的这两页就驻留在内存中。因此，你可以形象地看到多级页表的工作方式：==它只是让线性页表的一部分消失（释放这些帧用于其他用途），并用页目录来记录页表的哪些页被分配。==

​		在一个简单的两级页表中，页目录为每页页表包含了一项。==它由多个页目录项（Page Directory Entries，PDE）组成。PDE（至少）拥有有效位（valid bit）和页帧号（page frame number，PFN），类似于 PTE。==但是，正如上面所暗示的，这个有效位的含义稍有不同：如果 PDE 项是有效的，则意味着该项指向的页表（通过 PFN）中至少有一页是有效的，即在该 PDE 所指向的页中，至少一个 PTE，其有效位被设置为 1。如果 PDE 项无效（即等于零），则 PDE的其余部分没有定义。

​		与我们至今为止看到的方法相比，多级页表有一些明显的优势。==首先，也许最明显的是，多级页表分配的页表空间，与你正在使用的地址空间内存量成比例。因此它通常很紧凑，并且支持稀疏的地址空间。==

![image-20240827093027880](image/image-20240827093027880.png)

​		其次，如果仔细构建，页表的每个部分都可以整齐地放入一页中，从而更容易管理内存。操作系统可以在需要分配或增长页表时简单地获取下一个空闲页。将它与一个简单的（非分页）线性页表相比，后者仅是按 VPN 索引的 PTE 数组。用这样的结构，整个线性页表必须连续驻留在物理内存中。对于一个大的页表（比如 4MB），找到如此大量的、未使用的连续空闲物理内存，可能是一个相当大的挑战。==有了多级结构，我们增加了一个间接层（level of indirection），使用了页目录，它指向页表的各个部分。这种间接方式，让我们能够将页表页放在物理内存的任何地方。==

![image-20240906110021834](image/image-20240906110021834.png)

​		==应该指出，多级页表是有成本的。在 TLB 未命中时，需要从内存加载两次，才能从页表中获取正确的地址转换信息（一次用于页目录，另一次用于 PTE 本身），而用线性页表只需要一次加载。==因此，多级表是一个时间—空间折中（time-space trade-off）的小例子。我们想要更小的表（并得到了），但不是没代价。尽管在常见情况下（TLB 命中），性能显然是相同的，但 TLB 未命中时，则会因较小的表而导致较高的成本。

​		另一个明显的缺点是复杂性。无论是硬件还是操作系统来处理页表查找（在 TLB 未命中时），这样做无疑都比简单的线性页表查找更复杂。通常我们愿意增加复杂性以提高性能或降低管理费用。在多级表的情况下，为了节省宝贵的内存，我们使页表查找更加复杂。

#### 详细的多级示例 

​		为了更好地理解多级页表背后的想法，我们来看一个例子。设想一个大小为 16KB 的小地址空间，其中包含 64 个字节的页。因此，我们有一个 14 位的虚拟地址空间，VPN 有 8位，偏移量有 6 位。即使只有一小部分地址空间正在使用，线性页表也会有 28 （256）个项。图 20.3 展示了这种地址空间的一个例子。

![image-20240906110152506](image/image-20240906110152506.png)

​		在这个例子中，虚拟页 0 和 1 用于代码，虚拟页 4 和 5 用于堆，虚拟页 254 和 255 用于栈。地址空间的其余页未被使用。

​		要为这个地址空间构建一个两级页表，我们从完整的线性页表开始，将它分解成页大小的单元。回想一下我们的完整页表（在这个例子中）有 256 个项；假设每个 PTE 的大小是 4个字节。因此，我们的页大小为 1KB（256×4 字节）。鉴于我们有 64 字节的页，1KB 页表可以分为 16 个 64 字节的页，每个页可以容纳 16 个 PTE。

​		我们现在需要了解：如何获取 VPN，并用它来首先索引到页目录中，然后再索引到页表的页中。请记住，每个都是一组项。因此，我们需要弄清楚，如何为每个 VPN 构建索引。

​		我们首先索引到页目录。这个例子中的页表很小：256 个项，分布在 16 个页上。页目录需要为页表的每页提供一个项。因此，它有 16 个项。结果，我们需要 4 位 VPN 来索引目录。我们使用 VPN 的前 4 位，如下所示：

![image-20240827093332894](image/image-20240827093332894.png)

​		一旦从 VPN 中提取了页目录索引（简称 PDIndex），我们就可以通过简单的计算来找到页目录项（PDE）的地址：PDEAddr = PageDirBase +（PDIndex×sizeof（PDE））。这就得到了页目录，现在我们来看它，在地址转换上取得进一步进展。

​		如果页目录项标记为无效，则我们知道访问无效，从而引发异常。但是，如果 PDE 有效，我们还有更多工作要做。具体来说，我们现在必须从页目录项指向的页表的页中获取页表项（PTE）。要找到这个 PTE，我们必须使用 VPN 的剩余位索引到页表的部分：

![image-20240827093401164](image/image-20240827093401164.png)



​		这个页表索引（Page-Table Index，PTIndex）可以用来索引页表本身，给出 PTE 的地址：

```C
PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))
```

​		请注意，从页目录项获得的页帧号（PFN）必须左移到位，然后再与页表索引组合，才能形成 PTE 的地址。

​		为了确定这一切是否合理，我们现在代入一个包含一些实际值的多级页表，并转换一个虚拟地址。让我们从这个例子的页目录开始（见表 20.2 的左侧）。在该表中，可以看到每个页目录项（PDE）都描述了有关地址空间页表的一些内容。在这个例子中，地址空间里有两个有效区域（在开始和结束处），以及一些无效的映射。在物理页 100（页表的第 0 页的物理帧号）中，我们有 1 页，包含 16 个页表项，记录了地址空间中的前 16 个 VPN。请参见表 20.2（中间部分）了解这部分页表的内容。

![image-20240827093501899](image/image-20240827093501899.png)

​		页表的这一页包含前 16 个 VPN 的映射。在我们的例子中，VPN 0 和 1 是有效的（代码段），4 和 5（堆）也是。因此，该表有每个页的映射信息。其余项标记为无效。

​		页表的另一个有效页在 PFN 101 中。该页包含地址空间的最后 16 个 VPN 的映射。具体见表 20.2（右侧）。

​		在这个例子中，VPN 254 和 255（栈）包含有效的映射。希望从这个例子中可以看出，多级索引结构可以节省多少空间。在这个例子中，我们不是为一个线性页表分配完整的 16页，而是分配 3 页：一个用于页目录，两个用于页表的具有有效映射的块。大型（32 位或64 位）地址空间的节省显然要大得多。

​		最后，让我们用这些信息来进行地址转换。这里是一个地址，指向 VPN 254 的第 0 个字节：0x3F80，或二进制的 11 1111 1000 0000。

​		回想一下，我们将使用 VPN 的前 4 位来索引页目录。因此，1111 会从上面的页目录中选择最后一个（第 15 个，如果你从第 0 个开始）。这就指向了位于地址 101 的页表的有效页。然后，我们使用 VPN 的下 4 位（1110）来索引页表的那一页并找到所需的 PTE。1110 是页面中的倒数第二（第 14 个）条，并告诉我们虚拟地址空间的页 254 映射到物理页 55。通过连接 PFN = 55（或十六进制 0x37）和 offset = 000000，可以形成我想要的物理地址，并向内存系统发出请求：PhysAddr =（PTE.PFN << SHIFT）+ offset = 00 1101 1100 0000 = 0x0DC0。

​		你现在应该知道如何构建两级页表，利用指向页表页的页目录。但遗憾的是，我们的工作还没有完成。我们现在要讨论，有时两个页级别是不够的！

#### 超过两级

​		在至今为止的例子中，我们假定多级页表只有两个级别：一个页目录和几页页表。在某些情况下，更深的树是可能的（并且确实需要）。

​		让我们举一个简单的例子，用它来说明为什么更深层次的多级页表可能有用。在这个例子中，假设我们有一个 30 位的虚拟地址空间和一个小的（512 字节）页。因此我们的虚拟地址有一个 21 位的虚拟页号和一个 9 位偏移量。

​		请记住我们构建多级页表的目标：使页表的每一部分都能放入一个页。到目前为止，我们只考虑了页表本身。但是，如果页目录太大，该怎么办？

​		要确定多级表中需要多少级别才能使页表的所有部分都能放入一页，首先要确定多少页表项可以放入一页。鉴于页大小为 512 字节，并且假设 PTE 大小为 4 字节，你应该看到，可以在单个页上放入 128 个 PTE。当我们索引页表时，我们可以得出结论，我们需要 VPN的最低有效位 7 位（log2128）作为索引：

![image-20240827093659642](image/image-20240827093659642.png)

​		在上面你还可能注意到，多少位留给了（大）页目录：14。如果我们的页目录有 214个项，那么它不是一个页，而是 128 个，因此我们让多级页表的每一个部分放入一页目标失败了。

​		为了解决这个问题，我们为树再加一层，将页目录本身拆成多个页，然后在其上添加另一个页目录，指向页目录的页。我们可以按如下方式分割虚拟地址：

![image-20240827093717822](image/image-20240827093717822.png)



​		现在，当索引上层页目录时，我们使用虚拟地址的最高几位（图中的 PD 索引 0）。该索引用于从顶级页目录中获取页目录项。如果有效，则通过组合来自顶级 PDE 的物理帧号和 VPN 的下一部分（PD 索引 1）来查阅页目录的第二级。最后，如果有效，则可以通过使用与第二级 PDE 的地址组合的页表索引来形成 PTE 地址。这会有很多工作。所有这些只是为了在多级页表中查找某些东西。



#### ==补充：上述示例过程解释==

为了更好地理解多级页表的机制，我们将详细讲解你提供的示例。这个过程涉及将虚拟地址逐步解析为物理地址，通过使用多级页表实现虚拟内存的高效管理。让我们一步步来看这个过程。

#### 示例背景

我们假设一个 16KB 的虚拟地址空间，页大小为 64 字节。这意味着：

- 虚拟地址总共有 14 位（16KB=2^14字节）。(1KB=1024Byte=2^10Byte)
- 虚拟页号 (VPN) 有 8 位。
- 页内偏移量有 6 位（64字节=2^6）。
- 虚拟地址的格式为：[VPN (8 位) | 偏移量 (6 位)]。

#### 构建两级页表

1. **页表的分解**：线性页表有 256 个页表项（PTEs），每个 PTE 为 4 字节大小。因此，页表的总大小为 256×4=1KB。为了使用多级页表，==我们将页表分解为 16 个小页，每个小页有 16 个 PTEs（每个小页大小为 64 字节）。==
2. **页目录的结构**：==页目录有 16 个项，每个项指向页表中的一个页。==页目录项（PDE）的数量与页表页的数量相同。

#### 地址转换过程

- **示例虚拟地址**：我们使用虚拟地址 `0x3F80`（即二进制 `11 1111 1000 0000`）来进行地址转换。这个地址指向 VPN 254 的第 0 个字节。

#### 分解虚拟地址

1. **提取 VPN 和偏移量**：

   - 虚拟地址 

     ```
     0x3F80
     ```

     - VPN 部分是前 8 位：`1111 1110` (十进制 254)。
     - 偏移量部分是后 6 位：`000000`。

2. **页目录索引**：

   - ==我们使用 VPN 的前 4 位 `1111`（十进制 15）来索引页目录。==
   - ==这选中了页目录的第 15 项，指向页表的有效页（在物理页 101）。==

3. **页表索引**：

   - ==剩余的 VPN 位 `1110`（十进制 14）用于索引页表的页==。
   - 我们查找第 14 个 PTE，==它显示 VPN 254 对应到物理页 55==。

4. **计算物理地址**：

   - 使用物理页帧号 (PFN) `55`，结合偏移量 `000000`，计算物理地址：
   - `PhysAddr = (PFN << SHIFT) | offset = (55 << 6) | 0 = 0x0DC0`。

#### 超过两级页表

有时候，两级页表不足以处理大的地址空间。例如，当虚拟地址有 30 位且页大小为 512 字节时：

- 虚拟地址中有 21 位的 VPN 和 9 位的偏移量。
- 页表的每个页能容纳 128 个 PTE（每个 PTE 4 字节），需要 7 位索引。
- 页目录有 14 位来索引，导致页目录的项数大于 1 页大小（需要分为 128 页）。

为了管理这个较大的页目录，我们将页目录分解为多级：

1. **顶级页目录**：使用 VPN 的最高几位（如图中 PD 索引 0）。
2. **次级页目录**：顶级页目录的每项指向次级页目录。使用 VPN 的下几位（PD 索引 1）来索引次级页目录。
3. **页表**：次级页目录项指向页表。最后使用 VPN 剩余的位（页表索引）来找到 PTE。

通过这种多级结构，系统能够处理更大的地址空间，并且节省内存，因为只需要分配实际使用的页表页。

### 小结

- **两级页表**：通过页目录和页表来高效管理虚拟地址到物理地址的映射。
- **多级页表扩展**：对于更大的地址空间，可以增加更多的级别，将页目录拆分为多级，进一步减少内存浪费。
- **空间节省**：多级页表结构避免了为未使用的虚拟地址空间分配大量线性页表页。

这个示例展示了多级页表是如何通过逐级查找，节省内存空间并保持灵活性的。希望这个详细的过程有助于你理解多级页表的工作原理！





#### 地址转换过程：记住 TLB 

为了总结使用两级页表的地址转换的整个过程，我们再次以算法形式展示控制流（见图 20.4）。该图显示了每个内存引用在硬件中发生的情况（假设硬件管理的 TLB）。从图中可以看到，在任何复杂的多级页表访问发生之前，硬件首先检查 TLB。在命中时，物理地址直接形成，而不像之前一样访问页表。只有在 TLB 未命中时，硬件才需要执行完整的多级查找。在这条路径上，可以看到传统的两级页表的成本：两次额外的内存访问来查找有效的转换映射。

以下是图 20.4 的多级页表控制流代码版本，并添加了详细注释，解释每个步骤的作用：

```C
// Step 1: 从虚拟地址中提取虚拟页号 (VPN)
// VPN 是从虚拟地址中截取和偏移的结果
VPN = (VirtualAddress & VPN_MASK) >> SHIFT 

// Step 2: 尝试在 TLB 中查找对应的页表项
// TLB_Lookup 返回一个布尔值 Success 表示查找是否成功，以及找到的 TLB 条目
(Success, TlbEntry) = TLB_Lookup(VPN) 

// Step 3: 如果 TLB 命中 (TLB Hit)
if (Success == True) 
{
    // Step 4: 检查访问权限
    if (CanAccess(TlbEntry.ProtectBits) == True) 
    {
        // Step 5: 从虚拟地址中提取偏移量
        Offset = VirtualAddress & OFFSET_MASK 

        // Step 6: 计算物理地址
        // 物理地址由页帧号 (PFN) 左移并与偏移量相加得到
        PhysAddr = (TlbEntry.PFN << SHIFT) | Offset 

        // Step 7: 访问物理内存中的数据
        Register = AccessMemory(PhysAddr)
    } 
    else 
    {
        // 权限检查失败，触发保护异常
        RaiseException(PROTECTION_FAULT) 
    }
} 
else 
{
    // Step 10: 如果 TLB 未命中 (TLB Miss)，执行页表查找

    // Step 11: 获取页目录条目 (PDE)
    // PDIndex 是虚拟页号在页目录中的索引
    PDIndex = (VPN & PD_MASK) >> PD_SHIFT 

    // Step 12: 计算页目录条目的地址
    // PDBR 是页目录基址寄存器，指向当前进程的页目录
    PDEAddr = PDBR + (PDIndex * sizeof(PDE)) 

    // Step 13: 从内存中访问页目录条目
    PDE = AccessMemory(PDEAddr) 

    // Step 14: 检查页目录条目的有效性
    if (PDE.Valid == False) 
    {
        // 如果页目录条目无效，触发段错误异常
        RaiseException(SEGMENTATION_FAULT) 
    } 
    else 
    {
        // Step 18: 页目录条目有效，继续查找页表条目 (PTE)

        // 获取页表中的索引
        PTIndex = (VPN & PT_MASK) >> PT_SHIFT 

        // Step 20: 计算页表条目的地址
        // 从页目录条目中获取页表的页帧号
        PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE)) 

        // Step 21: 从内存中访问页表条目
        PTE = AccessMemory(PTEAddr) 

        // Step 22: 检查页表条目的有效性
        if (PTE.Valid == False) 
        {
            // 如果页表条目无效，触发段错误异常
            RaiseException(SEGMENTATION_FAULT) 
        } 
        else if (CanAccess(PTE.ProtectBits) == False) 
        {
            // 权限检查失败，触发保护异常
            RaiseException(PROTECTION_FAULT) 
        } 
        else 
        {
            // Step 27: 将新的映射插入到 TLB
            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) 

            // Step 28: 重试指令，这次会命中 TLB
            RetryInstruction() 
        }
    }
}
```

#### 代码流程注释

1. **TLB 命中**：如果在 TLB 中找到对应的 VPN 映射，并且访问权限允许，则直接通过 TLB 提供的 PFN 计算物理地址并访问内存。这是最快的路径。
2. **TLB 未命中**：如果 TLB 查找失败，系统将继续从页表中查找对应的映射。
3. ==**多级页表查找**：通过页目录和页表逐级查找虚拟地址对应的物理地址。==
   - ==首先，通过页目录基址寄存器（PDBR）和虚拟页号中的页目录索引，查找页目录条目（PDE）。==
   - ==然后，通过 PDE 的 PFN 继续查找页表中的页表条目（PTE）。==
4. **有效性和权限检查**：在多级页表查找过程中，每次访问页表项或页目录项时，都要检查其有效性和访问权限。
5. **TLB 更新**：当从页表找到有效的映射时，将其加载到 TLB 中以优化后续的访问。

这个流程利用了多级页表结构和 TLB 的结合，实现了高效的虚拟内存管理和地址转换。



### 20.4 反向页表

​		在反向页表（Inverted Page Table, IPT）中，页表的设计变得更加极端，以实现更大的空间节省。与传统的页表设计不同，==反向页表仅维护一个系统范围内的全局页表，而不是为每个进程都分配一个独立的页表。每个页表项对应一个物理页，并且包含使用该物理页的进程标识符（PID）以及虚拟页号（VPN）。==

#### 反向页表的工作原理

​		==在传统的页表中，页表项通过虚拟页号索引，可以快速定位对应的物理页。而在反向页表中，由于每个页表项代表一个物理页，需要通过扫描页表来找到与给定虚拟页匹配的物理页，这就引入了效率问题。==

​		为了解决这个问题，==反向页表通常会结合哈希表（hash table）来加速查找过程。==具体来说，每次需要执行地址转换时，系统会使用虚拟页号和进程标识符作为哈希函数的输入，从而在反向页表中定位到可能的物理页。通过这种方式，哈希表减少了线性扫描的成本，提高了查找速度。

PowerPC 体系结构就是一个使用反向页表的典型例子。它通过这种设计在系统级别实现了更高效的内存管理。

#### 反向页表的优缺点

**优点**：

- **节省空间**：==反向页表显著减少了页表的内存开销，因为系统只需要维护一个全局页表，而不是为每个进程维护独立的页表。==
- **简化管理**：通过集中管理物理页，操作系统可以更容易地进行全局内存管理和页面置换。

**缺点**：

- **查找复杂度**：==由于反向页表不再直接通过虚拟页号进行索引，查找过程变得更加复杂，需要借助哈希表等辅助结构来提高查找效率。==
- **哈希冲突**：在使用哈希表时，如果哈希函数设计不当，可能会引发大量冲突，进一步降低查找效率。

#### 原文：

​		在反向页表（inverted page table）中，可以看到页表世界中更极端的空间节省。在这里，我们保留了一个页表，其中的项代表系统的每个物理页，而不是有许多页表（系统的每个进

​		程一个）。页表项告诉我们哪个进程正在使用此页，以及该进程的哪个虚拟页映射到此物理页。现在，要找到正确的项，就是要搜索这个数据结构。线性扫描是昂贵的，因此通常在此基础结构上建立散列表，以加速查找。PowerPC 就是这种架构[JM98]的一个例子。更一般地说，反向页表说明了我们从一开始就说过的内容：页表只是数据结构。你可以对数据结构做很多疯狂的事情，让它们更小或更大，使它们变得更慢或更快。多层和反向页表只是人们可以做的很多事情的两个例子。



### 20.5 将页表交换到磁盘

​		在内存有限的系统中，即使应用了多级页表或反向页表等优化技术，页表仍然可能过大，无法完全存储在物理内存中。==在这种情况下，操作系统可以将页表的部分内容交换（swap）到磁盘中。这样做允许操作系统腾出内存空间给其他更紧急的任务，同时确保页表不会成为内存消耗的瓶颈。==

#### 页表的交换机制

​		在需要将页表的一部分交换到磁盘时，操作系统会将页表存储在内核虚拟内存中，并在物理内存中为其分配一个较小的缓存区域。未被缓存的页表部分将被换出到磁盘，当系统需要访问这些部分时，操作系统会将其换回内存中。

​		这种机制的工作原理类似于对进程页面的换出和换入，只不过这里的对象是页表项。当系统内存紧张时，这种机制能够显著减少页表的内存占用，从而将更多的内存留给实际的用户进程。

​		在实际操作系统中，例如 VAX/VMS 系统中，就采用了这种技术，以处理大规模的虚拟内存需求。通过将页表交换到磁盘，操作系统能够在内存管理方面更灵活应对多任务负载。



#### 原文：

​		最后，我们讨论放松最后一个假设。==到目前为止，我们一直假设页表位于内核拥有的物理内存中。即使我们有很多技巧来减小页表的大小，但是它仍然有可能是太大而无法一次装入内存。因此，一些系统将这样的页表放入内核虚拟内存（kernel virtual memory），从而允许系统在内存压力较大时，将这些页表中的一部分交换（swap）到磁盘。==我们将在下一章（即 VAX/VMS 的案例研究）中进一步讨论这个问题，在我们更详细地了解了如何将页移入和移出内存之后。



### 20.6 小结

​		在本章中，我们探讨了几种减少页表内存占用的策略，从简单的线性页表到更复杂的多级页表和反向页表。这些策略反映了时间与空间的权衡，不同系统和应用场景下，选择不同的数据结构来管理内存页表是非常重要的。

- **多级页表**：通过将线性页表分成多级结构，有效减少了内存使用，适合大多数现代系统。
- **反向页表**：进一步极端的空间节省方法，适用于特定架构，如 PowerPC，但需要更复杂的查找机制。
- **页表交换到磁盘**：当内存压力过大时，允许将部分页表换出到磁盘，进一步降低内存占用。

​		总的来说，页表设计中涉及的复杂性和性能权衡，依赖于系统的具体需求和硬件支持。操作系统开发人员需要根据应用场景选择合适的页表结构，确保系统在内存管理方面的高效性与可扩展性。



### 原文：

​		我们现在已经看到了如何构建真正的页表。不一定只是线性数组，而是更复杂的数据结构。这样的页表体现了时间和空间上的折中（表格越大，TLB 未命中可以处理得更快，反之亦然），因此结构的正确选择强烈依赖于给定环境的约束。

​		在一个内存受限的系统中（像很多旧系统一样），小结构是有意义的。在具有较多内存，并且工作负载主动使用大量内存页的系统中，用更大的页表来加速 TLB 未命中处理，可能是正确的选择。有了软件管理的 TLB，数据结构的整个世界开放给了喜悦的操作系统创新者（提示：就是你）。你能想出什么样的新结构？它们解决了什么问题？当你入睡时想想这些问题，做一个只有操作系统开发人员才能做的大梦。







