### 第十六章 分段

在前面的章节中，我们假设将进程的整个地址空间加载到物理内存中，利用基址和界限寄存器来进行地址重定位。然而，这种方式会导致内存的浪费，特别是在栈和堆之间的未使用空间会占用实际的物理内存。为了提高内存利用率并支持更大的地址空间，引入了**分段（Segmentation）**这一概念。

#### 16.1 分段：泛化的基址/界限

**分段**是将地址空间划分为多个独立的逻辑段（segment），每个段有自己的一对基址和界限寄存器。常见的段包括代码段、堆段和栈段。通过分段，操作系统可以将这些段分别放置在物理内存的不同区域，避免未使用的地址空间占用物理内存。这种机制特别适用于存在稀疏地址空间（Sparse Address Spaces）的情况。

**示例**： 假设一个进程的地址空间被划分为三个段，如图16.1所示。通过使用基址和界限寄存器，操作系统将每个段独立放置在物理内存中，如图16.2所示。在这个例子中，物理内存被分为64KB的区域，其中16KB留给操作系统，剩余的48KB用于放置代码段、堆段和栈段。

表16.1展示了这些段的具体基址和大小：

| **段**     | **基址** | **大小** |
| ---------- | -------- | -------- |
| **代码段** | 32KB     | 2KB      |
| **堆段**   | 34KB     | 2KB      |
| **栈段**   | 28KB     | 2KB      |

**地址转换过程**：

- 如果引用代码段中的虚拟地址100，硬件会将基址（32KB）加上偏移量100，得到物理地址32868，并检查该地址是否在界限内（100 < 2KB），如果合法，则发起对物理地址32868的访问。
- 对于堆中的虚拟地址4200，首先计算段内的偏移量（4200 - 4096 = 104），然后将偏移量加上堆段的基址（34KB），得到物理地址34920。

**段错误（Segmentation Fault）**： 当进程试图访问超出段边界的地址时，硬件会检测到这一越界行为，并触发异常，通常会导致进程被终止。这种错误在支持分段的机器上被称为**段错误（Segmentation Fault）**。

#### 16.2 我们引用哪个段

**段选择**： 在地址转换过程中，硬件需要确定虚拟地址属于哪个段，并计算段内的偏移量。有两种常见的方式来实现这一点：

1. **显式方式（Explicit Method）**：通过虚拟地址的高位来标识段。例如，在一个14位的虚拟地址中，前两位用于标识段，其余12位用于表示段内的偏移量。这种方式使得硬件能够快速确定地址属于哪个段，并计算物理地址。

   示例代码片段展示了如何进行段选择和地址转换：

   ```
   c复制代码// 获取虚拟地址的高位，确定段
   Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT;
   // 计算段内偏移量
   Offset = VirtualAddress & OFFSET_MASK;
   // 检查偏移量是否越界
   if (Offset >= Bounds[Segment])
       RaiseException(PROTECTION_FAULT);
   else
       PhysAddr = Base[Segment] + Offset;
   ```

2. **隐式方式（Implicit Method）**：硬件通过地址的产生方式来确定段。例如，程序计数器（PC）产生的地址通常属于代码段，而基址指针产生的地址则属于栈段。这种方式不需要显式的段标识，而是通过上下文推断出地址属于哪个段。

**分段的灵活性**： 虽然分段机制引入了更多的硬件复杂性，但它带来了显著的内存利用效率提升。通过分段，操作系统可以灵活地管理内存，将程序的各个部分放置在物理内存中最合适的位置，从而支持大地址空间和稀疏地址空间。

------

本章介绍了分段机制，它通过将地址空间划分为多个逻辑段，并为每个段配备独立的基址和界限寄存器，显著提高了内存利用效率。分段不仅减少了内存浪费，还允许操作系统灵活地管理和分配物理内存，从而更好地支持复杂的应用程序和大规模内存需求。下一步将探讨更复杂的内存管理机制，如分页（Paging）和虚拟内存的实现。

### 16.3 栈怎么办

在前面的讨论中，我们主要关注了代码段和堆段的地址转换，但栈段有一个关键的不同点：它是反向增长的。换句话说，栈从高地址向低地址增长，这与代码段和堆段的增长方向相反。

**栈的反向增长**： 在地址转换过程中，栈段的处理方式与其他段有所不同。硬件需要支持一个额外的标志位，用于指示段的增长方向。例如，1表示正向增长（从低地址向高地址增长），0表示反向增长（从高地址向低地址增长）。在表16.2中，更新后的段寄存器结构包括了这个新标志位。

**表 16.2 段寄存器（支持反向增长）**：

| 段   | 基址 | 大小 | 是否反向增长 |
| ---- | ---- | ---- | ------------ |
| 代码 | 32KB | 2KB  | 1            |
| 堆   | 34KB | 2KB  | 1            |
| 栈   | 28KB | 2KB  | 0            |

**栈段地址转换示例**： 假设要访问虚拟地址15KB（位于栈段中），该地址应该映射到物理地址27KB。虚拟地址的二进制形式为`11 1100 0000 0000`（十六进制为0x3C00）。硬件首先利用前两位`11`来指定这是栈段，然后根据剩余的地址部分计算偏移量。因为栈是反向增长的，我们需要从栈段的最大地址（4KB）中减去偏移量（3KB），得到−1KB的反向偏移量。将这个偏移量与基址28KB相加，就得到正确的物理地址27KB。

这种处理方式确保了反向增长段的地址能够正确映射到物理内存，同时也允许硬件进行界限检查，确保反向偏移量的绝对值小于段的大小。

### 16.4 支持共享

随着分段机制的发展，系统设计人员意识到，通过进一步的硬件支持，可以实现内存的共享，尤其是在多个进程之间共享代码段。为了实现这一点，引入了**保护位（Protection Bit）**的概念。

**保护位的作用**： 每个段寄存器除了基址、大小和增长方向外，还需要增加几个位来标识该段的权限，比如是否允许读、写、或执行。这些保护位允许操作系统将某些段标记为只读，从而实现代码段的共享。多个进程可以共享同一个物理内存中的代码段，而不必担心进程之间的相互影响。

**表 16.3 段寄存器的值（有保护）**：

| 段   | 基址 | 大小 | 是否反向增长 | 保护    |
| ---- | ---- | ---- | ------------ | ------- |
| 代码 | 32KB | 2KB  | 1            | 读—执行 |
| 堆   | 34KB | 2KB  | 1            | 读—写   |
| 栈   | 28KB | 2KB  | 0            | 读—写   |

**共享的实现**： 当硬件在进行地址转换时，不仅要检查地址是否越界，还需要检查该访问是否符合段的权限设置。如果用户进程试图写入只读段，或者从非执行段执行指令，硬件会触发异常，并让操作系统处理该错误。

### 16.5 细粒度与粗粒度的分段

我们之前的讨论主要集中在粗粒度分段上，即将地址空间分成较大的段（如代码段、栈段、堆段）。然而，一些早期系统，如Multics，允许将地址空间划分为许多小段，这被称为**细粒度分段（Fine-Grained Segmentation）**。

**细粒度分段的优势**： 细粒度分段提供了更大的灵活性，允许操作系统和编译器更精细地管理内存资源。例如，早期的Burroughs B5000机器支持成千上万的段，操作系统可以将代码和数据划分为许多小段，从而更高效地利用内存。

**段表的引入**： 为了支持大量的小段，系统需要引入段表（Segment Table）来管理这些段的信息。段表通常存储在内存中，并包含每个段的基址、大小和权限等信息。

### 16.6 操作系统支持

分段机制虽然提供了内存利用效率，但也给操作系统带来了新的挑战。

**1. 上下文切换**： 在上下文切换时，操作系统必须保存和恢复各个段寄存器的内容。每个进程都有自己独立的虚拟地址空间，因此在进程切换时，操作系统必须确保所有段寄存器被正确设置。

**2. 空闲内存管理**： 操作系统必须管理物理内存中的空闲空间。当创建新的地址空间时，操作系统需要为它的各个段找到合适的物理内存块。然而，由于段大小不同，可能会导致物理内存中出现许多不连续的空闲空间，即**外部碎片（External Fragmentation）**。

**解决外部碎片的策略**：

- **紧凑内存**：操作系统可以通过移动段来紧凑内存，使得空闲空间变得连续，从而满足新的内存分配请求。但这种方法代价高昂，因为移动段需要大量的处理器时间。
- **空闲列表管理**：操作系统可以采用各种空闲列表管理算法，如最优匹配、最坏匹配、首次匹配等，来减少外部碎片的影响。

### 16.7 小结

分段机制通过动态重定位和灵活的段管理，帮助操作系统更有效地利用内存资源，特别是在支持稀疏地址空间和共享代码段方面。尽管如此，分段机制仍然面临一些挑战，如外部碎片和对稀疏地址空间的支持不足。为了解决这些问题，更复杂的内存管理技术将被引入，例如分页（Paging），这是后续章节的内容。

------

这部分对第16章的关键内容进行了详细总结，涵盖了栈段的处理、共享机制的引入、细粒度与粗粒度分段的对比，以及操作系统在分段机制下的挑战和解决方案。如果有更多内容需要总结，请继续提供。