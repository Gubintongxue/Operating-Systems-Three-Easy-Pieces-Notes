## 第 5 章 插叙：进程 API

本章介绍了UNIX系统中进程创建和控制的API，特别是通过`fork()`、`exec()`和`wait()`系统调用来管理进程。这些接口在操作系统中扮演着重要角色，理解它们有助于掌握操作系统如何创建和控制进程。

#### 关键问题：

- **如何创建并控制进程**：操作系统应该提供哪些接口来创建和控制进程？这些接口如何设计才能既方便又实用？

### 5.1 `fork()`系统调用

- **功能**：`fork()`用于创建一个新进程。这个新进程几乎是调用`fork()`的进程的克隆，拥有相同的代码和数据。

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 

int main(int argc, char *argv[]) 
{ 
    // 打印当前进程的 PID (进程ID)
    printf("hello world (pid:%d)\n", (int) getpid()); 

    // 创建一个新的进程
    int rc = fork(); 

    if (rc < 0) { // fork 失败的情况，通常是因为系统资源不足
        fprintf(stderr, "fork failed\n"); 
        exit(1); // 退出程序，返回状态 1 表示错误
    } else if (rc == 0) { // 子进程（新创建的进程）
        // 在子进程中，fork() 返回 0
        printf("hello, I am child (pid:%d)\n", (int) getpid()); 
    } else { // 父进程
        // 在父进程中，fork() 返回子进程的 PID
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid()); 
    } 

    return 0; 
}
代码解释
fork()：

fork() 是一个系统调用，用于创建一个新进程。调用 fork() 后，操作系统会复制当前进程（称为父进程），并生成一个新的进程（称为子进程）。
在父进程中，fork() 返回子进程的 PID（进程 ID）。
在子进程中，fork() 返回 0。
如果 fork() 失败，返回值为负数，通常是由于系统资源不足。
getpid()：

getpid() 返回调用进程的进程 ID。
流程解释：

程序启动后，首先打印当前进程的 PID。
然后调用 fork() 试图创建一个新进程。
根据 fork() 的返回值，程序会走不同的分支：
如果 fork() 失败，程序输出错误信息并退出。
如果 fork() 成功，子进程会执行 printf 打印自己的 PID，父进程会执行 printf 打印自己的 PID 和子进程的 PID。
无论是父进程还是子进程，最后都会返回并结束执行。
这个简单的示例演示了如何使用 fork() 来创建子进程，并在父进程和子进程中执行不同的代码路径。
```



- **示例分析**：
  - **代码结构**：图5.1展示了`fork()`调用的一个示例程序（p1.c）。程序首先打印出一条消息，包括当前进程的PID，然后调用`fork()`创建一个子进程。`fork()`返回两次，一次在父进程中，一次在子进程中。
  - **输出解释**：在程序运行后，父进程和子进程将分别输出不同的消息。父进程得到子进程的PID，而子进程得到`fork()`的返回值为0。
  - **非确定性**：由于系统调度的非确定性，子进程或父进程可能会先执行。因此，输出的顺序并不是固定的，这种非确定性在多线程程序中尤为重要。

```
运行这段程序（p1.c），将看到如下输出：
prompt> ./p1 
hello world (pid:29146) 
hello, I am parent of 29147 (pid:29146) 
hello, I am child (pid:29147) 
prompt>
```

**原文：**

```
让我我更详细地理解一下 p1.c 到底发生了谁谁。当它刚开始运行谁，进程输出一条 hello 
world 信息，以及自己的进程描述符（process identifier，PID）。该进程的 PID 是 29146。谁 UNIX
系统中，如果要操作某个进程（如终止进程），就要通过 PID 来指明。到目前为止，一切正常。
紧接着有趣的事情发生了。进程调用了 fork()系统调用，这是操作系统提供的创建新进
程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这谁看起来有两个完
全一样的 p1 程序谁运行，并都从 fork()系统调用中返回。新创建的进程称为子进程（child），
原来的进程称为父进程（parent）。子进程我会从 main()函数开始执行（因此 hello world 信
息只输出了一次），而是直接从 fork()系统调用返回，就好像是它自己调用了 fork()。
你可能已经注意到，子进程并我是完全拷贝了父进程。具体来说，虽然它拥有自己的
地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是
我同的。父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。这个差
别非常重要，因为这样就很容易编写代码处理两种我同的情况（像上面那样）。 
你可能还会注意到，它的输出我是我我的（deterministic）。子进程被创建后，我我就需
要关心系统中的两个活动进程了：子进程和父进程。假设我我谁单个 CPU 的系统上运行（简
单起见），那谁子进程或父进程谁此谁都有可能运行。谁上面的例子中，父进程先运行并输
出信息。谁其他情况下，子进程可能先运行，会有下面的输出结果：
prompt> ./p1 
hello world (pid:29146) 
hello, I am child (pid:29147) 
hello, I am parent of 29147 (pid:29146) 
prompt> 
CPU 调度程序（scheduler）决我了某个谁刻哪个进程被执行，我我稍后将详细介绍这部分
内容。由于 CPU 调度程序非常复杂，所以我我我能假设哪个进程会先运行。事实表明，这种我
我我性（non-determinism）会导致一些很有趣的问题，特别是谁多线程程序（multi-threaded 
program）中。谁本书第 2 部分中学习并发（concurrency）谁，我我会看到许多我我我性。
```





### 5.2 `wait()`系统调用

- **功能**：`wait()`用于让父进程等待其子进程执行完毕。`wait()`调用将挂起父进程的执行，直到子进程结束。

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/wait.h> 

int main(int argc, char *argv[]) 
{ 
    // 打印当前进程的 PID (进程ID)
    printf("hello world (pid:%d)\n", (int) getpid()); 

    // 创建一个新的进程
    int rc = fork(); 

    if (rc < 0) { // fork 失败的情况，通常是因为系统资源不足
        fprintf(stderr, "fork failed\n"); 
        exit(1); // 退出程序，返回状态 1 表示错误
    } else if (rc == 0) { // 子进程（新创建的进程）
        // 在子进程中，fork() 返回 0
        printf("hello, I am child (pid:%d)\n", (int) getpid()); 
    } else { // 父进程
        // 父进程等待子进程结束，wait() 返回子进程的 PID
        int wc = wait(NULL); 
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid()); 
    } 

    return 0; 
}
代码解释
wait()：

wait() 是一个系统调用，父进程使用它来等待子进程的结束。调用 wait() 后，父进程会暂停执行，直到一个子进程结束。
wait() 返回终止的子进程的 PID。
如果父进程没有子进程，或者子进程已经结束，则 wait() 会立即返回。
代码执行流程：

程序启动后，打印当前进程的 PID。
调用 fork() 试图创建一个新进程。如果 fork() 成功：
子进程打印其 PID。
父进程等待子进程结束，wait(NULL) 使父进程暂停，直到子进程结束为止。
子进程结束后，wait() 返回子进程的 PID，父进程继续执行并打印包含子进程 PID 和自身 PID 的信息。
这个程序展示了如何使用 fork() 创建子进程，并使用 wait() 让父进程等待子进程完成后再继续执行的典型用法。
```

```shell
在p2.c 的例子中，父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进
程结束谁，wait()才返回父进程。
上面的代码增加了 wait()调用，因此输出结果也变得确定了。
下面是输出结果：
prompt> ./p2 
hello world (pid:29266) 
hello, I am child (pid:29267) 
hello, I am parent of 29267 (wc:29267) (pid:29266) 
prompt>
```



- **示例分析**：
  - **代码结构**：图5.2展示了一个结合`fork()`和`wait()`调用的示例程序（p2.c）。在该程序中，父进程在创建子进程后调用`wait()`，等待子进程完成执行。
  - **输出解释**：由于父进程调用了`wait()`，子进程总是会先输出其消息。即使父进程先开始执行，`wait()`调用也会使它等待子进程完成后再继续执行，这解释了为什么子进程的输出总是先于父进程。

### 总结：

- **进程创建与控制**：通过`fork()`、`exec()`和`wait()`系统调用，UNIX系统提供了灵活且强大的接口来创建和管理进程。理解这些调用的工作原理及其在程序中的应用，有助于掌握操作系统的进程管理机制。
- **非确定性与调度**：本章还提到，进程的执行顺序受到操作系统调度器的影响，这种非确定性在多进程和多线程编程中需要特别注意。

### 5.3 `exec()`系统调用

`exec()`系统调用是创建和控制进程的API中的重要组成部分，它允许进程运行不同的程序。

#### `exec()` 的作用：

- **替换当前进程**：`exec()`用于替换当前进程的代码和数据，使进程开始执行一个全新的程序，而不是创建新进程。调用`exec()`后，当前进程的内容被新程序的内容覆盖，进程ID保持不变，但执行的是新的程序代码。

```
prompt> ./p3 
hello world (pid:29383) 
hello, I am child (pid:29384) 
 29 107 1030 p3.c 
hello, I am parent of 29384 (wc:29384) (pid:29383) 
prompt>
```

```C
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <sys/wait.h> 

int main(int argc, char *argv[]) 
{ 
    // 打印当前进程的 PID (进程ID)
    printf("hello world (pid:%d)\n", (int) getpid()); 

    // 创建一个新的进程
    int rc = fork(); 

    if (rc < 0) { // fork 失败的情况，通常是因为系统资源不足
        fprintf(stderr, "fork failed\n"); 
        exit(1); // 退出程序，返回状态 1 表示错误
    } else if (rc == 0) { // 子进程（新创建的进程）
        // 在子进程中，fork() 返回 0
        printf("hello, I am child (pid:%d)\n", (int) getpid()); 

        // 创建一个参数数组，用于 execvp() 调用
        char *myargs[3]; 
        myargs[0] = strdup("wc");    // 程序名: "wc" (word count)
        myargs[1] = strdup("p3.c");  // 参数: 要统计的文件名 "p3.c"
        myargs[2] = NULL;            // 数组结束标志

        // execvp() 函数用来执行外部程序，这里是 "wc"
        execvp(myargs[0], myargs); // 运行 "wc" 程序统计 "p3.c" 文件中的行、单词和字符数

        // 如果 execvp() 成功运行，下面这行代码将不会执行
        printf("this shouldn't print out"); 
    } else { // 父进程
        // 父进程等待子进程结束，wait() 返回子进程的 PID
        int wc = wait(NULL); 
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid()); 
    } 

    return 0; 
}
代码解释
fork():

fork() 用于创建一个新的进程。父进程调用 fork() 后，系统会复制当前进程（父进程）并生成一个新进程（子进程）。
子进程执行 execvp():

在子进程中，程序创建了一个参数数组 myargs，其中包含程序名 "wc" 和文件名 "p3.c"。
execvp() 函数用来替换当前进程的执行内容，并运行指定的外部程序。在本例中，execvp(myargs[0], myargs) 会运行 "wc p3.c" 命令，统计 p3.c 文件中的行数、单词数和字符数。
execvp() 成功执行后，子进程的执行流会被替换为 wc 程序，因此 execvp() 之后的代码不会执行。
父进程使用 wait() 等待子进程结束:

父进程调用 wait(NULL)，暂停执行，直到子进程结束。
wait() 返回终止的子进程的 PID。父进程然后打印一条包含子进程 PID 和自身 PID 的消息。
strdup():

strdup() 函数用于分配内存并复制字符串。它在这里用于生成参数数组中的字符串。
printf("this shouldn't print out"):

由于 execvp() 成功后，当前进程会被新程序替代，所以这行代码在正常情况下不会被执行。
整体流程
程序启动后，打印出父进程的 PID。
调用 fork() 创建一个新进程。如果创建成功：
子进程执行 wc p3.c 命令统计文件内容。
父进程等待子进程结束，然后打印子进程和父进程的相关信息。
这个示例演示了如何使用 fork() 创建子进程、使用 wait() 等待子进程完成，以及使用 exec() 系列函数执行外部程序的典型用法。
```

```
在这个例子中，子进程调用 execvp()来运行字符计数程序 wc。实际上，它针对源代码
文件 p3.c 运行 wc，从而告诉我们该文件有多少行、多少单词，以及多少字节。

fork()系统调用很奇怪，它的伙伴 exec()也不一般。给定可执行程序的名称（如 wc）及
需要的参数（如 p3.c）后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己
的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执
行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前
运行的程序（以前的 p3）替换为我同的运行程序（wc）。
子进程执行 exec()之后，几乎就像p3.c 从未运行过一样。对 exec()的成功调用永远不会返回。
```



- **示例分析**：
  - **代码结构**：图5.3展示了一个结合`fork()`、`wait()`和`exec()`的示例程序（p3.c）。在该程序中，子进程首先由`fork()`创建，然后调用`execvp()`来执行字符计数程序`wc`，并对源文件`p3.c`进行统计。
  - **执行流程**：`execvp()`加载并执行指定的程序，将当前进程的代码和数据替换为新程序（`wc`）。执行`exec()`后，**子进程不再执行原程序的代码，而是完全转换为执行新程序。对于成功的`exec()`调用，原程序的后续代码不会执行。**
- **注意事项**：`exec()`调用非常独特，它不会创建新进程，而是替换当前进程的执行内容。由于`exec()`覆盖了现有的进程，因此成功的`exec()`调用从不返回，后续代码不会被执行。

### 总结：

在本章中，通过对`fork()`、`wait()`和`exec()`系统调用的详细分析，我们理解了UNIX系统中进程管理的核心API。这些调用允许程序创建新进程、控制其执行顺序，并在需要时运行全新的程序代码。理解这些API的工作原理对于掌握操作系统的进程管理机制至关重要。

### 5.4 为什么这样设计 API

本节讨论了UNIX系统中为何设计了分离的`fork()`和`exec()`系统调用，以及这种设计的优点。

#### 设计的原因：

- **方便 shell 的实现**：`fork()`和`exec()`的分离对于构建UNIX shell非常有用。shell是一个用户程序，它接受用户输入的命令，并通过`fork()`创建新进程，再使用`exec()`来执行用户指定的程序。通过在`fork()`和`exec()`之间插入代码，shell可以在运行新程序之前修改环境，例如重定向输出或设置文件描述符。
- **Lampson 定律**：在计算机系统设计中，正确的设计决策至关重要。`fork()`和`exec()`的组合看似简单，但实际上非常强大，这种设计满足了UNIX系统的实际需求，使系统既方便又灵活。

#### 重定向输出的示例：

```
prompt> wc p3.c > newfile.txt
```



```
prompt> ./p4 
prompt> cat p4.output 
 32 109 846 p4.c 
prompt>
```

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <fcntl.h> 
#include <sys/wait.h> 

int main(int argc, char *argv[]) 
{ 
    // 创建一个新进程
    int rc = fork(); 

    if (rc < 0) { // fork 失败的情况
        fprintf(stderr, "fork failed\n"); 
        exit(1); // 退出程序，返回状态 1 表示错误
    } else if (rc == 0) { // 子进程: 将标准输出重定向到文件
        close(STDOUT_FILENO); // 关闭标准输出文件描述符
        // 打开一个新的文件，将其与标准输出关联
        open("./p4.output", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU); 
        
        // 执行 "wc" 程序，统计 "p4.c" 文件中的行、单词和字符数
        char *myargs[3]; 
        myargs[0] = strdup("wc"); // 程序名: "wc" (word count)
        myargs[1] = strdup("p4.c"); // 参数: 要统计的文件名 "p4.c"
        myargs[2] = NULL; // 数组结束标志
        
        execvp(myargs[0], myargs); // 运行 "wc" 程序
    } else { // 父进程
        int wc = wait(NULL); // 父进程等待子进程结束
    } 

    return 0; 
}
代码解释
fork():

fork() 创建一个新的进程。父进程继续执行 fork() 之后的代码，而子进程从 fork() 处开始执行，返回值为 0。
子进程的标准输出重定向:

子进程通过 close(STDOUT_FILENO) 关闭标准输出文件描述符（文件描述符 1）。
通过 open() 打开一个新文件 p4.output，并将其与标准输出文件描述符关联。O_CREAT 表示如果文件不存在则创建文件，O_WRONLY 表示以写模式打开文件，O_TRUNC 表示如果文件已存在则将其内容清空。S_IRWXU 赋予文件所有者读、写和执行的权限。
execvp():

子进程使用 execvp() 运行外部程序 "wc"，对 p4.c 文件进行字数统计。
execvp() 成功执行后，子进程的地址空间会被新的程序替换，后续的代码将不会执行。
父进程使用 wait():

父进程使用 wait(NULL) 等待子进程结束。wait() 会阻塞父进程，直到子进程完成并返回其退出状态。

总结
这个示例展示了如何使用 fork() 创建子进程、如何使用 exec() 系列函数执行外部程序，以及如何将子进程的标准输出重定向到一个文件。通过这些操作，程序可以将外部命令的输出保存到文件中，而不是直接输出到终端。
```



- **示例代码分析**：图5.4展示了一个程序（p4.c），该程序在创建子进程后，利用`fork()`和`exec()`的分离，首先关闭标准输出（STDOUT），然后打开一个文件，将输出重定向到该文件。这样，运行的新程序（`wc`）的输出就会写入指定文件，而不是打印到屏幕上。
- **运行结果**：程序运行后，屏幕上不会显示`wc`的输出，因为输出被重定向到文件中。当使用`cat`命令查看输出文件时，能够看到`wc`命令的输出结果。这种方式使得shell可以轻松实现复杂的I/O重定向功能。
- **管道的实现**：类似的原理被用于实现UNIX中的管道（pipe）。通过`pipe()`系统调用，操作系统将一个进程的输出连接到另一个进程的输入，使得多个命令可以串联起来，形成复杂的操作链。

原文：

```
关于这个输出，你（至少）会注意到两个有趣的地方。首先，当运行 p4 程序后，好像
谁谁也谁有发生。shell 只是打印了命令提示符，等待用户的下一个命令。但事实并非如此，
p4 我实调用了 fork 来创建新的子进程，之后调用 execvp()来执行 wc。屏幕上谁有看到输出，
是由于结果被重我向到文件 p4.output。其次，当用 cat 命令打印输出文件谁，能看到运行
wc 的所有预期输出。很酷好？
UNIX 管谁也是用类似的方式实现的，但用的是 pipe()系统调用。谁这种情况下，一个
进程的输出被链接到了一个内核管谁（pipe）上（队列），另一个进程的输入也被连接到了
同一个管谁上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用
这种方式串联谁一起，共同完成某项任务。比如通过将 grep、wc 命令用管谁连接可以完成
从一个文件中查找某个词，并统计其出现次数的功能：grep -o foo file | wc -l。
最后，我我刚才只是从较高的层面上简单介绍了进程 API，关于这些系统调用的细节，
还有更多需要学习和理解。例如，谁本书第 3 部分介绍文件系统谁，我我会学习更多关于
文件描述符的谁识。现谁，谁谁 fork()和 exec()组合谁创建和操作进程谁非常强大就足够了。
```

### 补充1：在更底层的实现中（例如在 C 语言编写的程序中），通常使用 fork() 来创建一个新的子进程，然后使用 exec() 系列函数（如 execvp()）来在子进程中运行一个新程序。这个机制广泛用于操作系统内核和系统程序中，特别是在实现 Shell 等命令解释器时。为什么要这样使用

在操作系统和系统程序（如 Shell）的实现中，通常使用 `fork()` 和 `exec()` 系列函数来运行新程序。这种设计背后的原因与操作系统的工作原理、进程管理、安全性和资源利用等多个方面有关。下面是一些关键原因：

#### 1. **进程的创建与分离**

- **`fork()` 创建子进程**：
  - `fork()` 是一个系统调用，用于创建一个新的进程（子进程）。新创建的子进程是父进程的一个副本，包括父进程的地址空间、文件描述符、环境变量等。这种设计使得子进程能够独立于父进程运行，从而实现多任务处理。
  - 通过 `fork()` 创建子进程，系统可以通过多进程来并行处理不同的任务，每个任务运行在自己的进程空间中，互不干扰。
- **`exec()` 系列函数加载新程序**：
  - `exec()` 系列函数用于在已经创建的进程中加载并执行一个新程序。它会用新程序的代码和数据替换当前进程的内容，但保持进程的 PID 和一些资源（如文件描述符）不变。
  - 使用 `exec()`，可以在创建的新进程中运行一个与父进程不同的程序，从而实现任务的分离和功能的扩展。

#### 2. **资源共享与继承**

- 资源继承：
  - 当 `fork()` 创建一个子进程时，子进程会继承父进程的资源，如打开的文件描述符、内存映射、环境变量等。这样做的好处是，子进程可以轻松地使用父进程的资源，而不需要重新初始化或配置。例如，子进程可以继承父进程中打开的文件描述符，并将其用于输入输出操作。
- 独立的地址空间：
  - 尽管子进程继承了父进程的资源，但父子进程拥有独立的地址空间。任何一个进程的错误（如访问无效内存）不会直接影响另一个进程。这种隔离提高了系统的稳定性和安全性。

#### 3. **执行流程的灵活控制**

- 分离创建和执行的步骤：
  - 将进程的创建（通过 `fork()`）与执行（通过 `exec()`）分离，使得操作系统可以在 `fork()` 后的父子进程中插入一些逻辑处理，例如设置文件描述符、环境变量等。
  - 这种灵活性允许父进程在调用 `exec()` 之前，对子进程的环境进行必要的调整，例如重定向输入输出、关闭不必要的文件描述符、设置权限等。

#### 4. **效率和灵活性**

- **避免多次创建进程**：
  - 如果仅仅使用 `exec()` 来运行新程序，每次执行新程序时都需要创建一个全新的进程。这不仅浪费了资源（如重复分配进程表项），而且增加了系统开销。
  - 通过先 `fork()` 再 `exec()` 的模式，可以重用现有进程的资源（如 PID），减少进程创建的开销，并且可以在同一个进程中连续执行多个不同的程序。
- **并行处理**：
  - `fork()` 后的子进程可以独立于父进程运行，这意味着可以通过 `fork()` 创建多个子进程来并行执行不同的任务，提高系统的处理效率。
  - 父进程可以在等待子进程完成时继续执行其他任务，或通过 `wait()` 等待子进程的执行结果。

#### 5. **安全性与控制**

- 权限隔离：
  - 使用 `fork()` 和 `exec()`，父进程可以在不同的权限上下文中运行子进程，从而增强系统的安全性。父进程可以在子进程运行前，调整子进程的权限（如用户 ID、组 ID），以限制子进程的权限，防止安全漏洞的扩大。
- 精细化控制：
  - 在 `fork()` 后，父进程可以通过各种手段精细控制子进程的行为。例如，父进程可以使用 `wait()` 系列函数等待子进程的终止，获取子进程的退出状态，或者监控子进程的资源使用情况。

#### 总结

通过 `fork()` 创建子进程并使用 `exec()` 运行新程序，操作系统可以实现高效的多任务处理，同时提供资源隔离、灵活的执行控制和强大的安全保障。这种机制使得 UNIX 和 Linux 系统能够灵活地处理复杂的多进程应用程序，是这些操作系统设计中的核心要素。

### 补充2：为什么不在fork的子进程中继续fork,而使用exec,这样不也会共用一些资源

在 `fork()` 的子进程中继续调用 `fork()` 是可能的，但通常情况下，更常见的做法是在子进程中使用 `exec()` 系列函数来加载并执行一个新程序，而不是继续 `fork()`。这种设计选择背后有几个重要的理由：

#### 1. **不同的用途：进程创建 vs. 程序执行**

- **`fork()` 的主要用途**：`fork()` 用于创建一个新的进程，通常是当前进程的副本。这意味着父进程和子进程将共享相同的代码、数据和打开的文件描述符等资源，但它们在各自的独立地址空间中运行。
- **`exec()` 的主要用途**：`exec()` 用于将当前进程的内容替换为一个新程序的内容。这意味着虽然进程的 PID 和资源（如文件描述符）保持不变，但其代码段、数据段和堆栈段会被替换为新程序的内容。这是启动一个新程序的标准方式，而不是创建一个新的进程。

#### 2. **避免不必要的进程创建**

- **进程的开销**：每次调用 `fork()` 时，都会创建一个新的进程，并复制父进程的资源。虽然现代操作系统通过写时复制（Copy-on-Write，COW）技术优化了这一过程，但创建大量不必要的进程仍然会带来显著的系统开销。
- **使用 `exec()` 的效率**：如果你只是在子进程中再次调用 `fork()`，那么你只是在创建另一个新进程，而这个新进程大概率也会被 `exec()` 所替换。因此，直接在第一个 `fork()` 的子进程中调用 `exec()` 是一种更为高效的方式，因为你避免了创建额外的进程，也减少了系统资源的消耗。

#### 3. **资源的继承与替换**

- **`fork()` 后的资源继承**：`fork()` 后，子进程继承父进程的资源，包括打开的文件描述符、内存映射和环境变量等。如果在 `fork()` 的子进程中再次 `fork()`，这个新创建的进程也会继承这些资源。但这种做法可能会导致资源管理的复杂性增加，尤其是在需要关闭某些文件描述符或修改某些资源时。
- **`exec()` 的资源替换**：当调用 `exec()` 时，当前进程的内容被新程序替换，但打开的文件描述符等资源可以根据需求保留或关闭。这种方式提供了一种清晰的资源管理途径，避免了继承不必要的资源。

#### 4. **进程层次结构的清晰性**

- **层次结构**：如果在子进程中再次调用 `fork()`，你将创建一个多层次的进程层次结构，这在某些情况下可能会导致难以管理的复杂性。例如，父进程需要管理多个子进程，子进程又生成了自己的子进程，这样的层次结构使得进程的终止和资源释放变得更加复杂。
- **`exec()` 的简单性**：使用 `exec()`，子进程执行一个新程序，替换了自身的内容。此时，父进程只需要管理它生成的子进程，而不需要担心子进程进一步生成的子进程。这使得进程管理更加简单和清晰。

#### 5. **实际应用场景的需求**

- **典型场景**：在实际应用中，`fork()` 和 `exec()` 组合使用的场景非常多，特别是在实现 Shell 或者服务端程序时。`fork()` 用于创建一个新的进程，然后使用 `exec()` 在该进程中执行用户或系统请求的程序。这种方式让父进程能够并行处理多个任务，而每个子进程都可以专注于完成特定的工作。
- **子进程嵌套 `fork()` 的用途**：虽然子进程中再次 `fork()` 是可以的，但通常用于需要创建守护进程（daemon）或其他长期运行的后台进程。这种情况下，`fork()` 两次可以确保子进程脱离父进程的控制并在后台独立运行。

#### 总结

- **`fork()` 和 `exec()` 的组合** 是进程创建和程序执行的标准模式，这种模式高效且易于管理。
- **子进程中再次调用 `fork()`** 是有可能的，但通常仅在需要创建守护进程或长期运行的后台进程时使用，而不是用来执行新程序。
- **资源管理** 和 **进程层次结构的简洁性** 是选择 `fork()` 后直接调用 `exec()` 的关键原因，这种模式避免了不必要的资源继承和复杂的进程管理。

因此，操作系统和系统程序中常见的模式是先 `fork()` 创建一个子进程，然后在子进程中使用 `exec()` 执行新程序。



### 补充3：为什么shell命令要在子进程中去添加exec实现功能，而不再父进程中实现命令功能

在 Shell（以及许多操作系统程序）中，通常会通过 `fork()` 创建一个子进程，然后在子进程中使用 `exec()` 来执行命令，而不是直接在父进程中执行命令。这种设计背后的原因涉及到多个方面，包括进程隔离、并发性、资源管理和用户体验等。以下是这些原因的详细解释：

#### 1. **进程隔离**

- **子进程的独立性**：
  - 当 Shell 使用 `fork()` 创建一个子进程时，子进程是父进程的副本，但运行在独立的地址空间中。这意味着子进程的操作不会影响父进程的状态。通过在子进程中执行命令，即使命令执行失败、出现错误或者需要终止，父进程（Shell）仍然保持正常运行状态。
- **安全性和稳定性**：
  - 如果在父进程中直接执行命令，命令的执行可能会改变父进程的状态（如改变环境变量、重定向输出、修改文件描述符等），这可能导致 Shell 变得不稳定或者出现不可预料的行为。通过在子进程中执行命令，可以确保父进程的环境和状态不受影响，从而提高系统的安全性和稳定性。

#### 2. **并发执行和任务管理**

- **并行执行多个命令**：
  - 在许多情况下，用户可能希望并行执行多个命令。例如，用户可能会在 Shell 中使用 `&` 将某个命令放到后台执行。在这种情况下，Shell 会通过 `fork()` 创建一个子进程，并在该子进程中执行命令，而父进程继续接受用户的其他命令输入。
  - 通过在子进程中执行命令，Shell 可以同时处理多个任务，而不必等待每个命令执行完毕后才能继续工作。
- **任务控制（Job Control）**：
  - Shell 提供了丰富的任务控制功能（如挂起、恢复、终止任务），这些功能依赖于在子进程中执行命令。Shell 可以通过跟踪子进程的 PID 和状态来管理和控制正在运行的任务。

#### 3. **资源管理**

- **清理资源**：
  - 在子进程中执行命令后，子进程终止时，操作系统会自动清理该子进程所使用的资源（如内存、打开的文件描述符等）。这避免了资源泄漏的问题。
  - 如果 Shell 在父进程中直接执行命令，Shell 本身需要管理这些资源，并在命令执行后进行清理，这会增加复杂性并容易出错。
- **环境的独立性**：
  - 子进程可以继承父进程的环境变量和文件描述符，但在执行 `exec()` 后，子进程的环境可以根据新程序的需要进行调整，而不会影响父进程的环境。这种环境的独立性使得命令可以在一个干净且可控的环境中运行。

#### 4. **命令执行的灵活性**

- **实现不同类型的命令**：
  - Shell 中有两种主要类型的命令：内建命令（built-in commands）和外部命令。内建命令（如 `cd`、`echo`）通常在父进程中执行，因为它们直接影响 Shell 的状态。而外部命令（如 `ls`、`grep`）则通常在子进程中执行，以确保它们的执行不会影响 Shell 本身的行为。
  - 通过在子进程中执行外部命令，Shell 可以灵活地加载并运行系统中的任意程序，而不需要改变 Shell 自身的代码结构或状态。
- **使用 `exec()` 的替换机制**：
  - 在子进程中使用 `exec()`，Shell 可以替换子进程的执行镜像，使其运行任意外部程序。`exec()` 系列函数可以运行不同的程序，而不会留下不必要的中间状态。这种灵活性使得 Shell 可以方便地加载和执行用户指定的命令，而无需重新启动或更改自身状态。

#### 5. **用户体验**

- 用户的持续交互：
  - Shell 通过在子进程中执行命令，可以继续与用户进行交互。父进程（Shell）可以在等待子进程完成的同时接受用户的其他输入，而不会因为一个命令的执行而阻塞整个 Shell 界面。
  - 这对于提供一个流畅且高效的用户体验至关重要。用户可以同时运行多个任务，而不会因等待某个命令完成而无法执行其他操作。

#### 总结

- **隔离和稳定性**：在子进程中执行命令可以避免对 Shell 本身的影响，保证父进程（Shell）的稳定性和持续运行。
- **并发和任务管理**：通过 `fork()` 和 `exec()`，Shell 能够并行执行多个任务，并提供任务控制功能。
- **资源管理和清理**：子进程的自动资源管理和清理机制简化了 Shell 的实现，避免了资源泄漏。
- **灵活性和用户体验**：在子进程中执行命令使 Shell 能够灵活地加载和执行外部程序，同时保持良好的用户体验。

这些原因使得在子进程中使用 `exec()` 来执行命令成为 Shell 实现中的标准做法。





#### 实践的重要性：

- **阅读文档的重要性**：本书建议系统程序员在使用系统调用或工具时，阅读man手册。这些手册是UNIX系统中的重要文档，提供了详细的使用说明和参考信息。阅读man手册是了解系统功能和避免错误的有效途径。

### 5.5 其他 API

除了`fork()`、`exec()`和`wait()`，UNIX系统还提供了许多其他与进程交互的API。

- **信号机制**：通过`kill()`系统调用，可以向进程发送信号，控制进程的行为，例如终止或暂停进程。信号系统提供了丰富的工具，帮助处理和传递外部事件。
- **命令行工具**：命令行工具如`ps`和`top`可以显示系统中正在运行的进程及其资源使用情况。`ps`命令列出当前的进程，而`top`命令动态显示系统中最占用资源的进程。
- **系统监控工具**：一些工具可以帮助用户实时监控系统的资源使用情况，如MenuMeters，可以在Mac的工具栏上显示CPU利用率。

### 5.6 小结

本章介绍了UNIX系统中与进程创建和控制相关的核心API：`fork()`、`exec()`和`wait()`。这些系统调用为操作系统的进程管理提供了强大的功能，使得系统能够灵活地创建、控制和操作进程。有关更多细节和进阶知识，建议参考Stevens和Rago的著作【SR05】。