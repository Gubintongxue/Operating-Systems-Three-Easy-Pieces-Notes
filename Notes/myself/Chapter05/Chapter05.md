### 第 5 章 插叙：进程 API

本章介绍了UNIX系统中进程创建和控制的API，特别是通过`fork()`、`exec()`和`wait()`系统调用来管理进程。这些接口在操作系统中扮演着重要角色，理解它们有助于掌握操作系统如何创建和控制进程。

#### 关键问题：

- **如何创建并控制进程**：操作系统应该提供哪些接口来创建和控制进程？这些接口如何设计才能既方便又实用？

### 5.1 `fork()`系统调用

- **功能**：`fork()`用于创建一个新进程。这个新进程几乎是调用`fork()`的进程的克隆，拥有相同的代码和数据。
- **示例分析**：
  - **代码结构**：图5.1展示了`fork()`调用的一个示例程序（p1.c）。程序首先打印出一条消息，包括当前进程的PID，然后调用`fork()`创建一个子进程。`fork()`返回两次，一次在父进程中，一次在子进程中。
  - **输出解释**：在程序运行后，父进程和子进程将分别输出不同的消息。父进程得到子进程的PID，而子进程得到`fork()`的返回值为0。
  - **非确定性**：由于系统调度的非确定性，子进程或父进程可能会先执行。因此，输出的顺序并不是固定的，这种非确定性在多线程程序中尤为重要。

### 5.2 `wait()`系统调用

- **功能**：`wait()`用于让父进程等待其子进程执行完毕。`wait()`调用将挂起父进程的执行，直到子进程结束。
- **示例分析**：
  - **代码结构**：图5.2展示了一个结合`fork()`和`wait()`调用的示例程序（p2.c）。在该程序中，父进程在创建子进程后调用`wait()`，等待子进程完成执行。
  - **输出解释**：由于父进程调用了`wait()`，子进程总是会先输出其消息。即使父进程先开始执行，`wait()`调用也会使它等待子进程完成后再继续执行，这解释了为什么子进程的输出总是先于父进程。

### 总结：

- **进程创建与控制**：通过`fork()`、`exec()`和`wait()`系统调用，UNIX系统提供了灵活且强大的接口来创建和管理进程。理解这些调用的工作原理及其在程序中的应用，有助于掌握操作系统的进程管理机制。
- **非确定性与调度**：本章还提到，进程的执行顺序受到操作系统调度器的影响，这种非确定性在多进程和多线程编程中需要特别注意。

### 5.2 `wait()`系统调用

本节详细探讨了`wait()`系统调用的作用及其在进程控制中的重要性。

#### `wait()` 的作用：

- **等待子进程**：`wait()`系统调用用于让父进程暂停执行，直到子进程完成运行。通过调用`wait()`，父进程能够确保子进程结束后再继续执行自己的任务。
- **示例分析**：
  - **代码结构**：图5.2展示了一个结合`fork()`和`wait()`的示例程序（p2.c）。在该程序中，父进程在创建子进程后立即调用`wait()`，使得父进程会等待子进程完成后再继续执行。
  - **输出解释**：由于父进程调用了`wait()`，子进程的输出总是先于父进程。这是因为`wait()`让父进程暂停，直到子进程完成，随后父进程才继续执行并输出消息。
- **执行顺序的确定性**：虽然调度器可能会影响进程的执行顺序，但`wait()`的引入确保了父进程的输出总是出现在子进程之后，保证了执行顺序的确定性。

### 5.3 `exec()`系统调用

`exec()`系统调用是创建和控制进程的API中的重要组成部分，它允许进程运行不同的程序。

#### `exec()` 的作用：

- **替换当前进程**：`exec()`用于替换当前进程的代码和数据，使进程开始执行一个全新的程序，而不是创建新进程。调用`exec()`后，当前进程的内容被新程序的内容覆盖，进程ID保持不变，但执行的是新的程序代码。
- **示例分析**：
  - **代码结构**：图5.3展示了一个结合`fork()`、`wait()`和`exec()`的示例程序（p3.c）。在该程序中，子进程首先由`fork()`创建，然后调用`execvp()`来执行字符计数程序`wc`，并对源文件`p3.c`进行统计。
  - **执行流程**：`execvp()`加载并执行指定的程序，将当前进程的代码和数据替换为新程序（`wc`）。执行`exec()`后，子进程不再执行原程序的代码，而是完全转换为执行新程序。对于成功的`exec()`调用，原程序的后续代码不会执行。
- **注意事项**：`exec()`调用非常独特，它不会创建新进程，而是替换当前进程的执行内容。由于`exec()`覆盖了现有的进程，因此成功的`exec()`调用从不返回，后续代码不会被执行。

### 总结：

在本章中，通过对`fork()`、`wait()`和`exec()`系统调用的详细分析，我们理解了UNIX系统中进程管理的核心API。这些调用允许程序创建新进程、控制其执行顺序，并在需要时运行全新的程序代码。理解这些API的工作原理对于掌握操作系统的进程管理机制至关重要。

### 5.4 为什么这样设计 API

本节讨论了UNIX系统中为何设计了分离的`fork()`和`exec()`系统调用，以及这种设计的优点。

#### 设计的原因：

- **方便 shell 的实现**：`fork()`和`exec()`的分离对于构建UNIX shell非常有用。shell是一个用户程序，它接受用户输入的命令，并通过`fork()`创建新进程，再使用`exec()`来执行用户指定的程序。通过在`fork()`和`exec()`之间插入代码，shell可以在运行新程序之前修改环境，例如重定向输出或设置文件描述符。
- **Lampson 定律**：在计算机系统设计中，正确的设计决策至关重要。`fork()`和`exec()`的组合看似简单，但实际上非常强大，这种设计满足了UNIX系统的实际需求，使系统既方便又灵活。

#### 重定向输出的示例：

- **示例代码分析**：图5.4展示了一个程序（p4.c），该程序在创建子进程后，利用`fork()`和`exec()`的分离，首先关闭标准输出（STDOUT），然后打开一个文件，将输出重定向到该文件。这样，运行的新程序（`wc`）的输出就会写入指定文件，而不是打印到屏幕上。
- **运行结果**：程序运行后，屏幕上不会显示`wc`的输出，因为输出被重定向到文件中。当使用`cat`命令查看输出文件时，能够看到`wc`命令的输出结果。这种方式使得shell可以轻松实现复杂的I/O重定向功能。
- **管道的实现**：类似的原理被用于实现UNIX中的管道（pipe）。通过`pipe()`系统调用，操作系统将一个进程的输出连接到另一个进程的输入，使得多个命令可以串联起来，形成复杂的操作链。

#### 实践的重要性：

- **阅读文档的重要性**：本书建议系统程序员在使用系统调用或工具时，阅读man手册。这些手册是UNIX系统中的重要文档，提供了详细的使用说明和参考信息。阅读man手册是了解系统功能和避免错误的有效途径。

### 5.5 其他 API

除了`fork()`、`exec()`和`wait()`，UNIX系统还提供了许多其他与进程交互的API。

- **信号机制**：通过`kill()`系统调用，可以向进程发送信号，控制进程的行为，例如终止或暂停进程。信号系统提供了丰富的工具，帮助处理和传递外部事件。
- **命令行工具**：命令行工具如`ps`和`top`可以显示系统中正在运行的进程及其资源使用情况。`ps`命令列出当前的进程，而`top`命令动态显示系统中最占用资源的进程。
- **系统监控工具**：一些工具可以帮助用户实时监控系统的资源使用情况，如MenuMeters，可以在Mac的工具栏上显示CPU利用率。

### 5.6 小结

本章介绍了UNIX系统中与进程创建和控制相关的核心API：`fork()`、`exec()`和`wait()`。这些系统调用为操作系统的进程管理提供了强大的功能，使得系统能够灵活地创建、控制和操作进程。有关更多细节和进阶知识，建议参考Stevens和Rago的著作【SR05】。