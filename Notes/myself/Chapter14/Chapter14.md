## 第十四章 插叙：内存操作 API

​		在本章中，介绍了UNIX操作系统中的内存分配接口，以及如何在C程序中使用这些接口来管理内存。理解这些接口对于编写健壮和可靠的软件至关重要。本章探讨了内存管理的关键问题，并详细解释了栈内存和堆内存的分配与管理。

![image-20240905121121205](image/image-20240905121121205.png)

### 14.1 内存类型

​		在C程序的执行过程中，主要涉及两种类型的内存：栈内存和堆内存。

**栈内存（Stack Memory）**
		栈内存是由编译器自动管理的，也被称为自动内存。它的分配和释放都是隐式进行的。例如，在函数内部声明一个变量时，编译器会自动在栈上为该变量分配空间，当函数退出时，内存也会被自动释放。因此，如果需要在函数调用结束后保留某些数据，应该避免将其放在栈内存中。

**堆内存（Heap Memory）**
		堆内存的分配和释放由程序员显式管理。通过调用`malloc()`函数，可以在堆上分配内存，并返回一个指向这块内存的指针。堆内存的管理相比栈内存更加复杂，因为程序员必须手动处理内存的分配和释放，这种显式的管理增加了程序出错的风险。堆内存的错误管理可能导致内存泄漏或其他问题。

#### 原文：

​		在运行一个 C 程序的时候，会分配两种类型的内存。第一种称为栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。

​		C 中申请栈内存很容易。比如，假设需要在 func()函数中为一个整形变量 *x* 申请空间。为了声明这样的一块内存，只需要这样做：

```C
void func() { 
 int x; // declares an integer on the stack 
 ... 
}
```

​		编译器完成剩下的事情，确保在你进入 func() 函数的时候，在栈上开辟空间。当你从该函数退出时，编译器释放内存。因此，如果你希望某些信息存在于函数调用之外，建议不要将它们放在栈上。

​		就是这种对长期内存的需求，所以我们才需要第二种类型的内存，即所谓的堆（heap）内存，其中所有的申请和释放操作都由程序员显式地完成。毫无疑问，这是一项非常艰巨的任务！这确实导致了很多缺陷。但如果小心并加以注意，就会正确地使用这些接口，没有太多的麻烦。下面的例子展示了如何在堆上分配一个整数，得到指向它的指针：

```C
void func() { 
 int *x = (int *) malloc(sizeof(int)); 
 ... 
}
```

​		关于这一小段代码有两点说明。首先，你可能会注意到栈和堆的分配都发生在这一行：首先编译器看到指针的声明（int * x）时，知道为一个整型指针分配空间，随后，当程序调用 malloc()时，它会在堆上请求整数的空间，函数返回这样一个整数的地址（成功时，失败时则返回 NULL），然后将其存储在栈中以供程序使用。

​		因为它的显式特性，以及它本富于变化的用法，堆内存对用户和系统提出了本大的挑战。所以这也是我们接下来讨论的重点。



### 14.2 malloc()调用

​		`malloc()`函数是堆内存分配的核心函数。程序员通过传入所需分配的字节数，`malloc()`会返回一个指向新分配空间的指针。如果分配失败，返回`NULL`。在C语言中，`malloc()`的使用非常广泛，理解其用法是内存管理的基础。

**使用示例：**

```C
double *d = (double *) malloc(sizeof(double));
```

​		在这个示例中，通过`sizeof()`操作符获取了`double`类型的大小，并将其作为参数传给`malloc()`，以分配适当的内存空间。`sizeof()`是一个编译时操作符，它在编译时确定数据类型的大小，并将该值替换为具体的字节数。`malloc()`返回的指针需要通过强制类型转换（cast）转换为相应的数据类型指针，例如`double *`，以确保程序的正确性和可读性。

**注意事项：**

- `malloc()`返回的指针类型为`void *`，必须通过强制类型转换转换为适当的指针类型。
- 使用`sizeof()`时要小心，特别是在涉及指针和动态分配的情况下，因为`sizeof()`可能返回指针的大小，而不是实际分配的内存大小。
- 为字符串分配内存时，应使用`malloc(strlen(s) + 1)`来确保为字符串结束符预留空间。



#### 总结

​		本章详细介绍了UNIX操作系统的内存管理接口，特别是C语言中的栈内存和堆内存的分配与管理。通过理解这些接口和常见错误，程序员可以编写更健壮和可靠的软件。下一步，我们将探讨虚拟内存系统的基本机制和策略，以进一步理解操作系统中的内存管理。



#### 原文：

​		malloc 函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空

间的指针，失败就返回 NULL①。

​		man 手册展示了使用 malloc 需要怎么做，在命令行输入 man malloc，你会看到：

```C
#include <stdlib.h> 
... 
void *malloc(size_t size);
```

​		从这段信息可以看到，只需要包含头文件 stdlib.h 就可以使用 malloc 了。但实实上，甚至都不需这样做，因为 C 库是 C 程序默但链接的，其中就有 mallock()的代码，加上这个头文件只是让编译器检查你是否正确调用了 malloc()（即传入参数的数目正确且类型正确）。

​		malloc 只需要一个 size_t 类型参数，该参数表示你需要多少个字我。然而，大多数程序员并不会直接传入数字（比如 10）。实实上，这样做会被但为是不太好的形式。替代方案是使用各种函数和宏。例如，为了给双精度浮点数分配空间，只要这样：

```
double *d = (double *) malloc(sizeof(double));
```

![image-20240905122147205](image/image-20240905122147205.png)

​		啊，好多double！对malloc()的调用使用sizeof() 操作符去申请正确大小的空间。在C 中，这通常被但为是编译时操作符，意味着这个大小是在编译时就已知道，因此被替换成一个数（在本例中是 8，对于 double），作为 malloc()的参数。出于这个原因，sizeof() 被正确地但为是一个操作符，而不是一个函数调用（函数调用在运行时发生）。

​		你也可以传入一个变量的名字（而不只是类型）给 sizeof()，但在一些情况下，可能得不到你要的结果，所以要小心使用。例如，看看下面的代码片段：

```
int *x = malloc(10 * sizeof(int)); 
printf("%d\n", sizeof(x));
```

​		在第一行，我们为 10 个整数的数组声明了空间，这很好，很漂亮。但是，当我们在下一行使用 sizeof()时，它将返回一个较小的值，例如 4（在 32 位计算机上）或 8（在 64 位计算机上）。原因是在这种情况下，sizeof()但为我们只是问一个整数的指针有多大，而不是我们动态分配了多少内存。但是，有时 sizeof()的确如你所期望的那样工作：

```
int x[10]; 
printf("%d\n", sizeof(x));
```

​		在这种情况下，编译器有足够的静态信息，知道已经分配了 40 个字我。

​		另一个需要注意的地方是使用字符串。如果为一个字符串声明空间，请使用以下习惯用法：malloc(strlen(s) + 1)，它使用函数 strlen()获取字符串的长度，并加上 1，以便为字符串结束符留出空间。这里使用 sizeof()可能会导致麻烦。

​		你也许还注意到 malloc()返回一个指向 void 类型的指针。这样做只是 C 中传回地址的方式，让程序员决定如何处理它。程序员将进一步使用所谓的强制类型转换（cast），在我们上面的示例中，程序员将返回类型的 malloc()强制转换为指向 double 的指针。强制类型转换实实上没干什么事，只是告诉编译器和其他可能正在读你的代码的程序员：“是的，我知道我在做什么。”通过强制转换 malloc()的结果，程序员只是在给人一些信心，强制转换不是程序正确所必须的。



### 14.3 free()调用

​		分配内存是内存管理的第一步，但释放内存往往更加复杂。在C语言中，释放不再使用的堆内存是通过`free()`函数完成的。`free()`的使用相对简单：程序员传入一个由`malloc()`返回的指针，该函数会释放指向的内存块。需要注意的是，程序员不需要显式传入分配的内存大小，因为内存分配库会自动记录并管理这一信息。

#### 原文：

​		事实证明，分配内存是等式的简单部分。知道何时、如何以及是否释放内存是困难的部分。要释放不再使用的堆内存，程序员只需调用 free()：

```
int *x = malloc(10 * sizeof(int)); 
... 
free(x);
```

​		该函数接受一个参数，即一个由 malloc()返回的指针。

​		因此，你可能会注意到，分配区域的大小不会被用户传入，必须由内存分配库本身记录追踪。



### 14.4 常见错误

​		在使用`malloc()`和`free()`时，容易出现一系列常见错误，这些错误即使在编译时无法检测到，但在运行时可能导致程序崩溃或不正确的行为。以下是一些典型的错误场景：

​		**忘记分配内存** 这是指在调用某些需要预先分配内存的函数时，程序员忘记了这一步。例如，函数`strcpy(dst, src)`会将源字符串`src`复制到目标地址`dst`，但如果目标地址`dst`没有预先分配内存，程序就会发生段错误（segmentation fault），导致程序崩溃。正确的做法是在调用`strcpy()`前，使用`malloc()`为`dst`分配足够的内存空间。

```C
char *src = "hello"; 
char *dst; // oops! unallocated 
strcpy(dst, src); // segfault and die
```

正确的例子

```C
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src) + 1); 
strcpy(dst, src); // work properly
```



==**提示：它编译过了或它运行了!=它对了**==

​		**仅仅因为程序编译过了甚至正确运行了一次或多次，并不意味着程序是正确的。许多事件可能会让你相信它能工作，但是之后有些事情会发生变化，它停止了。学生常见的反应是说（或者叫喊）“但它以前是好的！”，然后责怪编译器、操作系统、硬件，甚至是（我们敢说）教授。但是，问题通常就像你认为的那样，在你的代码中。在指责别人之前，先撸起袖子调试一下。**



​		**没有分配足够的内存** 在分配内存时，如果未能为数据分配足够的空间，可能导致缓冲区溢出（buffer overflow）。这种错误常常发生在为字符串分配内存时。例如，如果只分配了字符串长度的空间，但未为字符串结束符留出空间，可能会导致数据溢出到相邻内存区域。这种错误可能在短时间内未表现出明显问题，但长远来看可能带来严重的安全隐患。

```c
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src)); // too small! 
strcpy(dst, src); // work properly
```

**注意：**

在 C 语言中，当你使用 `sizeof` 运算符计算字符串的大小时，如果字符串是一个字符数组或字符串字面量，计算的结果会包含结束符 `\0`（也称为空字符）。这是因为字符串字面量和字符数组在存储时会自动添加一个结束符来标识字符串的结束。

##### 示例 1: 字符数组

```c
char str[] = "hello";
printf("%lu\n", sizeof(str)); // 输出 6
```

在这个例子中，`str` 是一个包含字符串 `"hello"` 的字符数组，`sizeof(str)` 返回的是数组的总大小，包括 `\0` 结束符。因此，`sizeof(str)` 的值是 6。

##### 示例 2: 字符指针

```c
char *str = "hello";
printf("%lu\n", sizeof(str)); // 输出 8（或 4，具体取决于系统架构）
```

在这个例子中，`str` 是一个指向字符串 `"hello"` 的指针。`sizeof(str)` 返回的是指针的大小（在 64 位系统上通常是 8 字节，在 32 位系统上通常是 4 字节），而不是字符串本身的大小。

##### 总结

- **字符数组**: `sizeof` 计算字符串时会包括结束符 `\0`。
- **字符指针**: `sizeof` 计算的是指针本身的大小，而不是字符串的大小。

如果你想要计算字符串的实际长度而不包括结束符，可以使用 `strlen` 函数。



**忘记初始化分配的内存** 在使用`malloc()`分配内存后，如果忘记对内存进行初始化，程序可能会读取到未初始化的内存值，**这些值通常是随机的**，并可能导致程序产生未定义行为。为了避免这种情况，在分配内存后应尽早初始化内存内容，以确保程序运行的稳定性。



**忘记释放内存** 内存泄漏（memory leak）是指程序员忘记释放不再使用的内存。这种错误在短时间运行的程序中可能不会产生太大影响，但在长期运行的系统中，内存泄漏会逐渐耗尽系统内存，最终导致程序或系统崩溃。因此，养成在不再需要内存时及时调用`free()`的习惯，是编写可靠C程序的关键。



**在用完之前释放内存** 悬挂指针（dangling pointer）错误发生在程序员在用完内存之前就释放了它。这种情况下，程序可能会在后续操作中访问已被释放的内存，导致程序崩溃或无意中覆盖有效的内存。为了避免这种情况，应确保在内存不再需要时再调用`free()`。



**反复释放内存** 重复释放（double free）是指程序员试图多次释放同一块内存。这种行为会导致内存分配库混乱，进而引发程序崩溃或其他不可预见的行为。因此，每块内存只能释放一次，程序员需要小心管理内存的释放。



**错误地调用free()** 无效的释放（invalid free）发生在程序员向`free()`传递了一个非`malloc()`返回的指针。这种操作是危险的，可能导致程序崩溃或产生其他未定义行为。



#### 补充：进程退出时的内存管理

​		在短时间运行的程序中，程序退出时即使不调用`free()`释放已分配的内存，也不会导致内存泄漏。**这是因为操作系统在进程终止时，会自动收回该进程所占用的所有内存，包括代码段、栈和堆的内存页面。然而，对于长期运行的程序，内存泄漏可能会导致系统资源的枯竭**。因此，尽管在某些情况下不调用`free()`似乎是合理的，但这是一种不良习惯，应该尽量避免。

#### 小结

​		内存管理是C程序开发中的一个重要课题，稍有不慎就会导致程序崩溃或其他严重问题。**幸运的是，有许多工具可以帮助程序员检测和解决与内存管理相关的错误，比如`purify`和`valgrind`**，这些工具可以极大地帮助你在开发过程中发现和解决内存问题。一旦熟悉这些工具，它们会成为你开发过程中不可或缺的助手。

#### 原文：

​		在使用 malloc()和 free()时会出现一些常见的错误。以下是我们在教授本科操作系统课程时反复看到的情形。所有这些例子都可以通过编译器的编译并运行。对于构建一个正确的 C 程序来说，通过编译是必要的，但这远远不够，你会懂的（通常在吃了很多苦头之后）。

​		实际上，正确的内存管理就是这样一个问题，许多新语言都支持自动内存管理（automatic memory management）。在这样的语言中，当你调用类似 malloc()的机制来分配内存时（通常用 new 或类似的东西来分配一个新对象），你永远不需要调用某些东西来释放空间。实实上，垃圾收集器（garbage collector）会运行，找出你不再引用的内存，替你释放它。

#### 忘记分配内存 

​		许多例程在调用之前，都希望你为它们分配内存。例如，例程 strcpy(dst, src)将源字符串中的字符串复制到目标指针。但是，如果不小心，你可能会这样做：

```
char *src = "hello"; 
char *dst; // oops! unallocated 
strcpy(dst, src); // segfault and die
```

​		运行这段代码时，可能会导致段错误（segmentation fault）①，这是一个很奇怪的术语，表示“你对内存犯了一个错误。你这个愚蠢的程序员。我很生气。”

![image-20240905135309928](image/image-20240905135309928.png)

​		在这个例子中，正确的代码可能像这样：

```
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src) + 1); 
strcpy(dst, src); // work properly
```

​		或者你可以用 strdup()，让生活本加轻松。阅读 strdup 的 man 手册页，了解本多信息。

#### 没有分配足够的内存 

​		另一个相关的错误是没有分配足够的内存，有时称为缓冲区溢出（buffer overflow）。在上面的例子中，一个常见的错误是为目标缓冲区留出“几乎”足够的空间。

```
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src)); // too small! 
strcpy(dst, src); // work properly
```

​		奇怪的是，这个程序通常看起来会正确运行，这取决于如何实现 malloc 和许多其他细我。在某些情况下，当字符串拷贝执行时，它会在超过分配空间的末尾处写入一个字我，但在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源[W06]。在其他情况下，malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写，并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。因此，我们学到了另一个宝贵的教训：即使它正确运行过一次，也不意味着它是正确的。

#### 忘记初始化分配的内存 

​		在这个错误中，你正确地调用 malloc()，但忘记在新分配的数据类型中填写一些值。不要这样做！如果你忘记了，你的程序最终会遇到未初始化的读取（uninitialized read），它从堆中读取了一些未知值的数据。谁知道那里可能会有什么？如果走运，读到的值使程序仍然有效（例如，零）。如果不走运，会读到一些随机和有害的东西。

#### 忘记释放内存

​		另一个常见错误称为内存泄露（memory leak），如果忘记释放内存，就会发生。在长时间运行的应用程序或系统（如操作系统本身）中，这是一个巨大的问题，因为缓慢泄露的内存会导致内存不足，此时需要重新启动。因此，一般来说，当你用完一段内存时，应该确保释放它。请注意，使用垃圾收集语言在这里没有什么帮助：如果你仍然拥有对某块内存的引用，那么垃圾收集器就不会释放它，因此即使在较现代的语言中，内存泄露仍然是一个问题。

​		在某些情况下，不调用 free()似乎是合理的。例如，你的程序运行时间很短，很但就会退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生内存泄露。虽然这肯定“有效”（请参阅后面的补充），但这可能是一个坏习惯，所以请谨慎选择这样的策略。长远来看，作为程序员的目标之一是养成良好的习惯。其中一个习惯是理解如何管理内存，并在 C 这样的语言中，释放分配的内存块。即使你不这样做也可以逃脱惩罚，建议还是养成习惯，释放显式分配的每个字我。



#### 在用完之前释放内存 

​		有时候程序会在用完之前释放内存，这种错误称为悬挂指针（dangling pointer），正如你猜测的那样，这也是一件坏事。随后的使用可能会导致程序崩溃或覆盖有效的内存（例如，你调用了 free()，但随后再次调用 malloc()来分配其他内容，这重新利用了错误释放的内存）。

#### 反复释放内存 

​		程序有时还会不止一次地释放内存，这被称为重复释放（double free）。这样做的结果是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的事情，崩溃是常见的结果。

#### 错误地调用 free() 

​		我们讨论的最后一个问题是 free()的调用错误。毕竟，free()期望你只传入之前从 malloc()得到的一个指针。如果传入一些其他的值，坏事就可能发生（并且会发生）。因此，这种无效的释放（invalid free）是危险的，当然也应该避免。

![image-20240905135513664](image/image-20240905135513664.png)

#### 小结 

​		如你所见，有很多方法滥用内存。由于内存出错很常见，整个工具生态圈已经开发出来，可以帮助你在代码中找到这些问题。==请查看 purify [HJ92]和 valgrind [SN05]，==在帮助你找到与内存有关的问题的根源方面，两者都非常出色。一旦你习惯于使用这些强大的工具，就会想知道，没有它们时，你是如何活下来的。



### 14.5 底层操作系统支持

​		在前面讨论`malloc()`和`free()`时，我们没有提及系统调用，==这是因为这些函数本身**并不是直接的系统调用，而是库调用**。==`malloc`库负责管理虚拟地址空间内的内存分配，但**它的实现依赖于一些底层系统调用来获取或释放内存**。

​		==**`brk`和`sbrk`系统调用** 其中一个关键的系统调用是**`brk`，它用于改变程序的分段（break）位置**，也就是堆的结束位置。==通过传入一个新分段的地址，`brk`可以增加或减少堆的大小。**`sbrk`是另一个相关的系统调用，它接收一个增量参数，用来调整堆的大小**。这两个系统调用为`malloc`库提供了扩展或缩减堆空间的基础。

​		尽管这些系统调用是内存管理的基础，但不建议程序员直接使用`brk`或`sbrk`，因为它们通常由内存分配库自动管理，直接使用可能会导致不易发现的错误。因此，建议坚持使用`malloc()`和`free()`来处理内存分配和释放。

​		**`	mmap`系统调用** 另一种获取内存的方式是通过`mmap()`系统调用。`mmap`可以在程序中创建一个匿名（anonymous）内存区域，这种内存区域不与任何特定文件关联，而是与交换空间（swap space）关联。这种方式分配的内存可以像堆一样使用和管理。`mmap`的这种特性使其成为分配较大内存块或特殊用途内存区域的有力工具。详细的用法可以参考`mmap`的手册页。

### 14.6 其他调用

​		内存分配库还提供了一些其他有用的调用：

​		 **`calloc()`函数不仅分配内存，还会将分配的内存区域初始化为零。它的作用类似于`malloc()`，但在返回之前会自动将内存置零**。这对于防止使用未初始化内存的错误尤其有用，特别是在处理数组或其他数据结构时。

​		**`realloc()`** `realloc()`函数用于调整已经分配的内存块的大小。如果你需要为一个已存在的内存块分配更多空间，==**`realloc()`会分配一个新的、更大的内存区域，并将旧区域的内容复制到新区域中，然后释放旧区域的内存。这在动态调整数组大小时特别有用。**==

### 14.7 小结

​		本章介绍了UNIX操作系统中处理内存分配的API，包括`malloc()`、`free()`、`calloc()`和`realloc()`等。我们还讨论了这些API背后的底层系统调用，如`brk`、`sbrk`和`mmap`。虽然本章只介绍了基本内容，但深入理解这些API及其背后的机制对编写高效和健壮的C程序非常重要。

​		更多详细信息可以参考经典的C语言书籍，如《The C Programming Language》（Kernighan & Ritchie）以及Stevens的《UNIX Network Programming》。此外，Novark等人的现代研究论文[N+07]提供了关于内存管理的常见问题及其解决方法的深入探讨，推荐有兴趣的读者进一步阅读。