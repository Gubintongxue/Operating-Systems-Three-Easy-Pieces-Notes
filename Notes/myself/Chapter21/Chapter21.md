## 第21章 超越物理内存：机制

​		到目前为止，我们一直假定地址空间非常小，能放入物理内存。事实上，我们假设每个正在运行的进程的地址空间都能放入内存。我们将放松这些大的假设，并假设我们需要支持许多同时运行的巨大地址空间。

​		为了达到这个目的，需要在内存层级（memory hierarchy）上再加一层。到目前为止，我们一直假设所有页都常驻在物理内存中。但是，为了支持更大的地址空间，操作系统需要把当前没有在用的那部分地址空间找个地方存储起来。一般来说，这个地方有一个特点，那就是比内存有更大的容量。因此，一般来说也更慢（如果它足够快，我们就可以像使用内存一样使用，对吗？）。在现代系统中，硬盘（hard disk drive）通常能够满足这个需求。因此，在我们的存储层级结构中，大而慢的硬盘位于底层，内存之上。那么我们的关键问题是：

**关键问题：如何超越物理内存**

**操作系统如何利用大而慢的设备，透明地提供巨大虚拟地址空间的假象？**

​		你可能会问一个问题：为什么我们要为进程支持巨大的地址空间？答案还是方便和易用性。有了巨大的地址空间，你不必担心程序的数据结构是否有足够空间存储，只需自然地编写程序，根据需要分配内存。这是操作系统提供的一个强大的假象，使你的生活简单很多。别客气！一个反面例子是，一些早期系统使用“内存覆盖（memory overlays）”，它需要程序员根据需要手动移入或移出内存中的代码或数据[D97]。设想这样的场景：在调用函数或访问某些数据之前，你需要先安排将代码或数据移入内存。

**补充：存储技术**

​		**稍后将深入介绍 I/O 设备如何运行。所以少安毋躁！当然，这个较慢的设备可以是硬盘，也可以是一些更新的设备，比如基于闪存的 SSD。我们也会讨论这些内容。但是现在，只要假设有一个大而较慢的设备，可以利用它来构建巨大虚拟内存的假象，甚至比物理内存本身更大。**

### 21.1 交换空间

​		在现代操作系统中，为了支持大于物理内存的地址空间，操作系统会在硬盘上开辟一部分空间，称为**交换空间（Swap Space）**，用于存储从物理内存中换出的页面。当物理内存不足时，操作系统会将一些页面从内存移出，存储在交换空间中；当这些页面再次需要时，再从交换空间中将它们移回内存。这种机制使得操作系统能够为进程提供比物理内存更大的地址空间。

#### 交换空间的作用

​		交换空间的作用是为操作系统提供一个比物理内存更大的“虚拟”内存，使得在多任务并行执行时，每个进程都可以使用足够的内存，而不会因为物理内存不足而崩溃。例如，假设一个系统有 4GB 的物理内存和 8GB 的交换空间，则系统总共可以为进程提供 12GB 的虚拟内存。当物理内存耗尽时，操作系统会将不常用的页面换出到交换空间，以腾出内存给需要的进程。

#### 交换空间的大小

​		交换空间的大小直接影响系统的性能和稳定性。一般来说，交换空间越大，操作系统能够处理的进程和数据就越多。然而，交换空间过大会导致磁盘 I/O 增加，进而影响系统性能。因此，操作系统通常会根据物理内存大小、工作负载类型等因素，合理配置交换空间的大小。

​		在配置交换空间时，还要考虑到现代操作系统使用的其他磁盘空间。例如，运行一个二进制程序（如 `ls` 或者用户自己编译的程序），这些程序的代码最初存储在硬盘上，并在运行时按需加载到内存中。如果系统需要腾出内存给其他进程，操作系统可以将这些代码页面从内存中移除，并在需要时重新从硬盘加载，而无需使用交换空间。这种机制进一步优化了内存的使用效率。

![image-20240827110919578](image/image-20240827110919578.png)

​		图 21.1 展示了一个系统的内存使用情况。系统中有 4 页物理内存和 8 页交换空间。在这个示例中，有 3 个进程（进程 0、进程 1 和进程 2）正在运行，它们各自的页面部分存储在物理内存中，部分存储在交换空间中。进程 3 的所有页面都已被换出到交换空间中，表明该进程当前没有运行。

​		通过这个示例可以看到，交换空间允许系统假装内存比实际物理内存更大。当进程 3 需要运行时，操作系统会将它的页面从交换空间中换入内存，同时将其他进程的页面换出，腾出足够的内存空间。这种机制使得系统能够同时运行多个大规模进程，即使它们的内存需求总和远超物理内存。

​		交换空间不仅用于存储换出的页面，还可以用于存储二进制文件的代码页面。当一个程序运行时，代码页面会按需从硬盘加载到内存中，并在内存不足时将其移出，以便稍后重新加载。这种机制使得系统能够高效地管理内存，并在物理内存有限的情况下，仍然为进程提供足够的虚拟内存。

### 21.2 存在位

​		在系统中引入交换机制后，我们需要额外的机制来支持从硬盘交换页。关键的一点是**存在位（present bit）**。这个位位于每个页表项（PTE）中，用于指示该页是否当前存在于物理内存中。如果存在位为 1，表示该页在物理内存中；如果存在位为 0，表示该页已被交换到硬盘上。此时，访问该页将触发一个**页错误（page fault）**。

​		在处理页错误时，操作系统必须通过页表项找到该页在硬盘上的位置，然后将其从硬盘交换回内存。存在位的引入使得系统可以区分哪些页面是在内存中，哪些页面是在硬盘上。

#### 原文：

​		现在我们在硬盘上有一些空间，需要在系统中增加一些更高级的机制，来支持从硬盘交换页。简单起见，假设有一个硬件管理 TLB 的系统。

​		先回想一下内存引用发生了什么。正在运行的进程生成虚拟内存引用（用于获取指令或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。

​		硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。

​		如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。

​		但是，如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错误（page fault）。

#### 补充：交换术语及其他

​		**对于不同的机器和操作系统，虚拟内存系统的术语可能会有点令人困惑和不同。例如，页错误（page fault）一般是指对页表引用时产生某种错误：这可能包括在这里讨论的错误类型，即页不存在的错误，但有时指的是内存非法访问。事实上，我们将这种完全合法的访问（页被映射到进程的虚拟地址空间，但此时不在物理内存中）称为“错误”是很奇怪的。实际上，它应该被称为“页未命中（page miss）”。但是通常，当人们说一个程序“页错误”时，意味着它正在访问的虚拟地址空间的一部分，被操作系统交换到了硬盘上。** 

​		**我们怀疑这种行为之所以被称为“错误”，是因为操作系统中的处理机制。当一些不寻常的事情发生的时候，即硬件不知道如何处理的时候，硬件只是简单地把控制权交给操作系统，希望操作系统能够解决。在这种情况下，进程想要访问的页不在内存中。硬件唯一能做的就是触发异常，操作系统从开始接管。由于这与进程执行非法操作处理流程一样，所以我们把这个活动称为“错误”，这也许并不奇怪。**

​		

​		在页错误时，操作系统被唤起来处理页错误。一段称为“页错误处理程序（page-fault handler）”的代码会执行，来处理页错误，接下来就会讲。



### 21.3 页错误

​		当页不存在于内存中时，操作系统必须处理这个**页错误**。无论是硬件管理的 TLB 还是软件管理的 TLB，页错误的处理过程大致相同。操作系统的**页错误处理程序**负责查找该页在硬盘上的位置，将其读取回内存，并更新页表。

​		处理页错误时，操作系统会暂停当前进程，执行一系列步骤来将页面换入内存。操作系统首先从页表项中获取该页在硬盘上的地址，然后发起 I/O 操作，将页面读取到内存中。读取完成后，操作系统更新页表项的存在位，将页表项的物理帧号（PFN）指向新加载的页面，并重新尝试触发页错误的指令。

​		这个过程会使进程在 I/O 操作期间处于阻塞状态，而操作系统可以利用这个时间运行其他进程。这样，虽然处理页错误的时间较长，但通过多道程序的并行执行，系统可以更有效地利用硬件资源。

#### 原文：

​		回想一下，在 TLB 未命中的情况下，我们有两种类型的系统：硬件管理的 TLB（硬件在页表中找到需要的转换映射）和软件管理的 TLB（操作系统执行查找过程）。不论在哪种系统中，如果页不存在，都由操作系统负责处理页错误。操作系统的页错误处理程序（page-fault handler）确定要做什么。几乎所有的系统都在软件中处理页错误。即使是硬件管理的 TLB，硬件也信任操作系统来管理这个重要的任务。

​		如果一个页不存在，它已被交换到硬盘，在处理页错误的时候，操作系统需要将该页交换到内存中。那么，问题来了：操作系统如何知道所需的页在哪儿？在许多系统中，页表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址，这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中查找地址，并将请求发送到硬盘，将页读取到内存中。

#### 补充：为什么硬件不能处理页错误

​		**我们从 TLB 的经验中得知，硬件设计者不愿意信任操作系统做所有事情。那么为什么他们相信操作系统来处理页错误呢？有几个主要原因。首先，页错误导致的硬盘操作很慢。即使操作系统需要很长时间来处理故障，执行大量的指令，但相比于硬盘操作，这些额外开销是很小的。其次，为了能够处理页故障，硬件必须了解交换空间，如何向硬盘发起 I/O 操作，以及很多它当前所不知道的细节。因此，由于性能和简单的原因，操作系统来处理页错误，即使硬件人员也很开心。**



​		当硬盘 I/O 完成时，操作系统会更新页表，将此页标记为存在，更新页表项（PTE）的PFN 字段以记录新获取页的内存位置，并重试指令。下一次重新访问 TLB 还是未命中，然而这次因为页在内存中，因此会将页表中的地址更新到 TLB 中（也可以在处理页错误时更新 TLB 以避免此步骤）。最后的重试操作会在 TLB 中找到转换映射，从已转换的内存物理地址，获取所需的数据或指令。

​		请注意，当 I/O 在运行时，进程将处于阻塞（blocked）状态。因此，当页错误正常处理时，操作系统可以自由地运行其他可执行的进程。因为 I/O 操作是昂贵的，一个进程进行I/O（页错误）时会执行另一个进程，这种交叠（overlap）是多道程序系统充分利用硬件的一种方式。





### 21.4 内存满了怎么办

如果系统内存已满，当新的页面需要被换入时，操作系统必须决定将哪些页面换出。这就是**页交换策略（page-replacement policy）**的作用。页交换策略决定了哪些页面会被交换到硬盘上，以腾出空间给新页面。

选择合适的页面换出对于系统性能至关重要。错误的选择可能会导致频繁的页错误，使得系统运行速度大幅下降。因此，开发一个有效的页交换策略是操作系统设计中的关键环节。换出错误的页可能导致程序运行速度下降几个数量级，因此这个问题值得深入研究。下一章将详细讨论这些策略。

#### 原文：

​		在上面描述的过程中，你可能会注意到，我们假设有足够的空闲内存来从存储交换空间换入（page in）的页。当然，情况可能并非如此。内存可能已满（或接近满了）。因此，操作系统可能希望先交换出（page out）一个或多个页，以便为操作系统即将交换入的新页留出空间。选择哪些页被交换出或被替换（replace）的过程，被称为页交换策略（page-replacement policy）。

​		事实表明，人们在创建好页交换策略上投入了许多思考，因为换出不合适的页会导致程序性能上的巨大损失，也会导致程序以类似硬盘的速度运行而不是以类似内存的速度。在现有的技术条件下，这意味着程序可能会运行慢 10000～100000 倍。因此，这样的策略是我们应该详细研究的。实际上，这也正是我们下一章要做的。现在，我们只要知道有这样的策略存在，建立在之前描述的机制之上。

### 21.5 页错误处理流程

有了前面的知识，现在我们可以总结内存访问的完整流程，并了解在页面交换机制下可能发生的各种情况。如果有人问你：“当程序从内存中读取数据时会发生什么？”，你应该能够很好地描述出不同的可能性。请参阅图 21.2 和图 21.3，它们分别展示了硬件和操作系统在页错误处理中所执行的控制流程。

**图 21.2** 展示了硬件在地址转换过程中所做的工作：

```
1  VPN = (VirtualAddress & VPN_MASK) >> SHIFT
2  (Success, TlbEntry) = TLB_Lookup(VPN)
3  if (Success == True) // TLB 命中
4      if (CanAccess(TlbEntry.ProtectBits) == True)
5          Offset = VirtualAddress & OFFSET_MASK
6          PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
7          Register = AccessMemory(PhysAddr)
8      else
9          RaiseException(PROTECTION_FAULT)
10 else // TLB 未命中
11     PTEAddr = PTBR + (VPN * sizeof(PTE))
12     PTE = AccessMemory(PTEAddr)
13     if (PTE.Valid == False)
14         RaiseException(SEGMENTATION_FAULT)
15     else
16         if (CanAccess(PTE.ProtectBits) == False)
17             RaiseException(PROTECTION_FAULT)
18         else if (PTE.Present == True)
19             // 假设是硬件管理的 TLB
20             TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
21             RetryInstruction()
22         else if (PTE.Present == False)
23             RaiseException(PAGE_FAULT)
```

在这个控制流中，当 TLB 未命中时，有三种可能的情况：

1. **页面存在且有效**（第 18～21 行）：此时，硬件可以从 PTE 中获取物理帧号（PFN），插入 TLB，并重试指令，通常会在第二次尝试时命中 TLB，从而快速完成内存访问。
2. **页面不存在物理内存中**（第 22～23 行）：此时，操作系统会触发页错误处理程序，因为页面虽然是有效的，但已经被换出到硬盘。
3. **访问无效页面**（第 13～14 行）：这种情况下，访问了一个非法的内存地址，操作系统会捕获非法访问，并可能终止相关进程。

**图 21.3** 展示了操作系统在页错误时的处理流程：

```
1  PFN = FindFreePhysicalPage()
2  if (PFN == -1) // 没有找到空闲页
3      PFN = EvictPage() // 执行页替换算法
4  DiskRead(PTE.DiskAddr, PFN) // 等待 I/O 完成
5  PTE.Present = True // 更新页表，标记页已存在
6  PTE.PFN = PFN // 更新页表项中的物理帧号
7  RetryInstruction() // 重试指令
```

在处理页错误时，操作系统需要做以下步骤：

1. 寻找一个空闲的物理帧（如果没有空闲帧，则执行页替换算法）。
2. 从硬盘读取所需页面，并更新页表项。
3. 在完成这些操作后，重新尝试引发页错误的指令，并将页面加载到 TLB 中。



#### 原文：

​		有了这些知识，我们现在就可以粗略地描绘内存访问的完整流程。换言之，如果有人问你：“当程序从内存中读取数据会发生什么？”，你应该对所有不同的可能性有了很好的概念。有关详细信息，请参见图 21.2 和图 21.3 中的控制流。图 21.2 展示了硬件在地址转换过程中所做的工作，图 21.3 展示了操作系统在页错误时所做的工作。

```
1 VPN = (VirtualAddress & VPN_MASK) >> SHIFT 
2 (Success, TlbEntry) = TLB_Lookup(VPN) 
3 if (Success == True) // TLB Hit 
4 if (CanAccess(TlbEntry.ProtectBits) == True) 
5 Offset = VirtualAddress & OFFSET_MASK 
6 PhysAddr = (TlbEntry.PFN << SHIFT) | Offset 
7 Register = AccessMemory(PhysAddr) 
8 else 
9 RaiseException(PROTECTION_FAULT)
10 else // TLB Miss 
11 PTEAddr = PTBR + (VPN * sizeof(PTE)) 
12 PTE = AccessMemory(PTEAddr) 
13 if (PTE.Valid == False) 
14 RaiseException(SEGMENTATION_FAULT) 
15 else 
16 if (CanAccess(PTE.ProtectBits) == False) 
17 RaiseException(PROTECTION_FAULT) 
18 else if (PTE.Present == True) 
19 // assuming hardware-managed TLB 
20 TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) 
21 RetryInstruction() 
22 else if (PTE.Present == False) 
23 RaiseException(PAGE_FAULT)
```

图 21.2 页错误控制流算法（硬件）

​		从图 21.2 的硬件控制流图中，可以注意到当 TLB 未命中发生的时候有 3 种重要情景。第一种情况，该页存在（present）且有效（valid）（第 18～21 行）。在这种情况下，TLB 未命中处理程序可以简单地从 PTE 中获取 PFN，然后重试指令（这次 TLB 会命中），并因此继续前面描述的流程。第二种情况（第 22～23 行），页错误处理程序需要运行。虽然这是进程可以访问的合法页（毕竟是有效的），但它并不在物理内存中。第三种情况，访问的是一个无效页，可能由于程序中的错误（第 13～14 行）。在这种情况下，PTE 中的其他位都不重要了。硬件捕获这个非法访问，操作系统陷阱处理程序运行，可能会杀死非法进程。

​		从图 21.3 的软件控制流中，可以看到为了处理页错误，操作系统大致做了什么。首先，操作系统必须为将要换入的页找到一个物理帧，如果没有这样的物理帧，我们将不得不等待交换算法运行，并从内存中踢出一些页，释放帧供这里使用。在获得物理帧后，处理程序发出 I/O 请求从交换空间读取页。最后，当这个慢操作完成时，操作系统更新页表并重试指令。重试将导致 TLB 未命中，然后再一次重试时，TLB 命中，此时硬件将能够访问所需的值。

```
1 PFN = FindFreePhysicalPage() 
2 if (PFN == -1) // no free page found 
3 PFN = EvictPage() // run replacement algorithm 
4 DiskRead(PTE.DiskAddr, pfn) // sleep (waiting for I/O) 
5 PTE.present = True // update page table with present 
6 PTE.PFN = PFN // bit and translation (PFN) 
7 RetryInstruction() // retry instruction 
图 21.3 页错误控制流算法（软件）
```



### 21.6 交换何时真正发生

我们已经讨论了当内存满时，操作系统会执行页替换操作。然而，在实际系统中，操作系统通常不会等到内存完全用尽才开始页替换。为了提高效率，操作系统通常会维护一定量的空闲内存，通过设定高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），控制何时开始预防性地释放内存页。

当空闲页数少于低水位线时，一个后台线程（通常称为**交换守护进程**或**页守护进程**）会开始运行，释放内存直到达到高水位线。通过预先释放内存页，操作系统可以在需要时快速响应新页面的请求。

这种后台操作还可以通过聚集和合并多个要写入的页面来提高硬盘效率，减少寻道和旋转延迟。为了配合这个机制，图 21.3 中的控制流会做出调整，首先检查是否有空闲页，然后根据需要唤醒后台线程以释放内存。

#### 原文：

​		到目前为止，我们一直描述的是操作系统会等到内存已经完全满了以后才会执行交换流程，然后才替换（踢出）一个页为其他页腾出空间。正如你想象的那样，这有点不切实际的，因为操作系统可以更主动地预留一小部分空闲内存。

​		为了保证有少量的空闲内存，大多数操作系统会设置高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），来帮助决定何时从内存中清除页。原理是这样：当操作系统发现有少于 LW 个页可用时，后台负责释放内存的线程会开始运行，直到有 HW 个可用的物理页。这个后台线程有时称为交换守护进程（swap daemon）或页守护进程（page daemon）①，它然后会很开心地进入休眠状态，因为它毕竟为操作系统释放了一些内存。

​		通过同时执行多个交换过程，我们可以进行一些性能优化。例如，许多系统会把多个要写入的页聚集（cluster）或分组（group），同时写入到交换区间，从而提高硬盘的效率[LL82]。我们稍后在讨论硬盘时将会看到，这种合并操作减少了硬盘的寻道和旋转开销，从而显著提高了性能。

​		为了配合后台的分页线程，图 21.3 中的控制流需要稍作修改。交换算法需要先简单检查是否有空闲页，而不是直接执行替换。如果没有空闲页，会通知后台分页线程按需要释放页。当线程释放一定数目的页时，它会重新唤醒原来的线程，然后就可以把需要的页交换进内存，继续它的工作。

**提示：把一些工作放在后台**

​		**当你有一些工作要做的时候，把这些工作放在后台（background）运行是一个好注意，可以提高效率，并允许将这些操作合并执行。操作系统通常在后台执行很多工作。例如，在将数据写入硬盘之前，许多系统在内存中缓冲要写入的数据。这样做有很多好处：提高硬盘效率，因为硬盘现在可以一次写入多次要写入的数据，因此能够更好地调度这些写入。优化了写入延迟，因为数据写入到内存就可以返回。可能减少某些操作，因为写入操作可能不需要写入硬盘（例如，如果文件马上又被删除），也能更好地利用系统空闲时间（idle time），因为系统可以在空闲时完成后台工作，从而更好地利用硬件资源[G+95]。**



### 21.7 小结

在本章中，我们探讨了操作系统如何支持超出物理内存大小的地址空间。通过增加存在位和页错误处理机制，操作系统可以将页面交换到硬盘上，并在需要时将其换回内存。整个过程对于正在运行的进程来说是透明的，它们只看到一个连续的虚拟内存空间。尽管内存访问在最坏情况下可能需要多个硬盘操作的时间，但这使得操作系统能够有效地管理内存并支持大规模的地址空间。