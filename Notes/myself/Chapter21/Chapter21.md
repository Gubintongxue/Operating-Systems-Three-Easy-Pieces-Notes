### 21.1 交换空间

在现代操作系统中，为了支持大于物理内存的地址空间，操作系统会在硬盘上开辟一部分空间，称为**交换空间（Swap Space）**，用于存储从物理内存中换出的页面。当物理内存不足时，操作系统会将一些页面从内存移出，存储在交换空间中；当这些页面再次需要时，再从交换空间中将它们移回内存。这种机制使得操作系统能够为进程提供比物理内存更大的地址空间。

#### 交换空间的作用

交换空间的作用是为操作系统提供一个比物理内存更大的“虚拟”内存，使得在多任务并行执行时，每个进程都可以使用足够的内存，而不会因为物理内存不足而崩溃。例如，假设一个系统有 4GB 的物理内存和 8GB 的交换空间，则系统总共可以为进程提供 12GB 的虚拟内存。当物理内存耗尽时，操作系统会将不常用的页面换出到交换空间，以腾出内存给需要的进程。

#### 交换空间的大小

交换空间的大小直接影响系统的性能和稳定性。一般来说，交换空间越大，操作系统能够处理的进程和数据就越多。然而，交换空间过大会导致磁盘 I/O 增加，进而影响系统性能。因此，操作系统通常会根据物理内存大小、工作负载类型等因素，合理配置交换空间的大小。

在配置交换空间时，还要考虑到现代操作系统使用的其他磁盘空间。例如，运行一个二进制程序（如 `ls` 或者用户自己编译的程序），这些程序的代码最初存储在硬盘上，并在运行时按需加载到内存中。如果系统需要腾出内存给其他进程，操作系统可以将这些代码页面从内存中移除，并在需要时重新从硬盘加载，而无需使用交换空间。这种机制进一步优化了内存的使用效率。

### 图 21.1 物理内存和交换空间的示例

图 21.1 展示了一个系统的内存使用情况。系统中有 4 页物理内存和 8 页交换空间。在这个示例中，有 3 个进程（进程 0、进程 1 和进程 2）正在运行，它们各自的页面部分存储在物理内存中，部分存储在交换空间中。进程 3 的所有页面都已被换出到交换空间中，表明该进程当前没有运行。

通过这个示例可以看到，交换空间允许系统假装内存比实际物理内存更大。当进程 3 需要运行时，操作系统会将它的页面从交换空间中换入内存，同时将其他进程的页面换出，腾出足够的内存空间。这种机制使得系统能够同时运行多个大规模进程，即使它们的内存需求总和远超物理内存。

交换空间不仅用于存储换出的页面，还可以用于存储二进制文件的代码页面。当一个程序运行时，代码页面会按需从硬盘加载到内存中，并在内存不足时将其移出，以便稍后重新加载。这种机制使得系统能够高效地管理内存，并在物理内存有限的情况下，仍然为进程提供足够的虚拟内存。

### 21.2 存在位

在系统中引入交换机制后，我们需要额外的机制来支持从硬盘交换页。关键的一点是**存在位（present bit）**。这个位位于每个页表项（PTE）中，用于指示该页是否当前存在于物理内存中。如果存在位为 1，表示该页在物理内存中；如果存在位为 0，表示该页已被交换到硬盘上。此时，访问该页将触发一个**页错误（page fault）**。

在处理页错误时，操作系统必须通过页表项找到该页在硬盘上的位置，然后将其从硬盘交换回内存。存在位的引入使得系统可以区分哪些页面是在内存中，哪些页面是在硬盘上。

### 21.3 页错误

当页不存在于内存中时，操作系统必须处理这个**页错误**。无论是硬件管理的 TLB 还是软件管理的 TLB，页错误的处理过程大致相同。操作系统的**页错误处理程序**负责查找该页在硬盘上的位置，将其读取回内存，并更新页表。

处理页错误时，操作系统会暂停当前进程，执行一系列步骤来将页面换入内存。操作系统首先从页表项中获取该页在硬盘上的地址，然后发起 I/O 操作，将页面读取到内存中。读取完成后，操作系统更新页表项的存在位，将页表项的物理帧号（PFN）指向新加载的页面，并重新尝试触发页错误的指令。

这个过程会使进程在 I/O 操作期间处于阻塞状态，而操作系统可以利用这个时间运行其他进程。这样，虽然处理页错误的时间较长，但通过多道程序的并行执行，系统可以更有效地利用硬件资源。

### 21.4 内存满了怎么办

如果系统内存已满，当新的页面需要被换入时，操作系统必须决定将哪些页面换出。这就是**页交换策略（page-replacement policy）**的作用。页交换策略决定了哪些页面会被交换到硬盘上，以腾出空间给新页面。

选择合适的页面换出对于系统性能至关重要。错误的选择可能会导致频繁的页错误，使得系统运行速度大幅下降。因此，开发一个有效的页交换策略是操作系统设计中的关键环节。换出错误的页可能导致程序运行速度下降几个数量级，因此这个问题值得深入研究。下一章将详细讨论这些策略。

### 21.5 页错误处理流程

有了前面的知识，现在我们可以总结内存访问的完整流程，并了解在页面交换机制下可能发生的各种情况。如果有人问你：“当程序从内存中读取数据时会发生什么？”，你应该能够很好地描述出不同的可能性。请参阅图 21.2 和图 21.3，它们分别展示了硬件和操作系统在页错误处理中所执行的控制流程。

**图 21.2** 展示了硬件在地址转换过程中所做的工作：

```
plaintext复制代码1  VPN = (VirtualAddress & VPN_MASK) >> SHIFT
2  (Success, TlbEntry) = TLB_Lookup(VPN)
3  if (Success == True) // TLB 命中
4      if (CanAccess(TlbEntry.ProtectBits) == True)
5          Offset = VirtualAddress & OFFSET_MASK
6          PhysAddr = (TlbEntry.PFN << SHIFT) | Offset
7          Register = AccessMemory(PhysAddr)
8      else
9          RaiseException(PROTECTION_FAULT)
10 else // TLB 未命中
11     PTEAddr = PTBR + (VPN * sizeof(PTE))
12     PTE = AccessMemory(PTEAddr)
13     if (PTE.Valid == False)
14         RaiseException(SEGMENTATION_FAULT)
15     else
16         if (CanAccess(PTE.ProtectBits) == False)
17             RaiseException(PROTECTION_FAULT)
18         else if (PTE.Present == True)
19             // 假设是硬件管理的 TLB
20             TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)
21             RetryInstruction()
22         else if (PTE.Present == False)
23             RaiseException(PAGE_FAULT)
```

在这个控制流中，当 TLB 未命中时，有三种可能的情况：

1. **页面存在且有效**（第 18～21 行）：此时，硬件可以从 PTE 中获取物理帧号（PFN），插入 TLB，并重试指令，通常会在第二次尝试时命中 TLB，从而快速完成内存访问。
2. **页面不存在物理内存中**（第 22～23 行）：此时，操作系统会触发页错误处理程序，因为页面虽然是有效的，但已经被换出到硬盘。
3. **访问无效页面**（第 13～14 行）：这种情况下，访问了一个非法的内存地址，操作系统会捕获非法访问，并可能终止相关进程。

**图 21.3** 展示了操作系统在页错误时的处理流程：

```
plaintext复制代码1  PFN = FindFreePhysicalPage()
2  if (PFN == -1) // 没有找到空闲页
3      PFN = EvictPage() // 执行页替换算法
4  DiskRead(PTE.DiskAddr, PFN) // 等待 I/O 完成
5  PTE.Present = True // 更新页表，标记页已存在
6  PTE.PFN = PFN // 更新页表项中的物理帧号
7  RetryInstruction() // 重试指令
```

在处理页错误时，操作系统需要做以下步骤：

1. 寻找一个空闲的物理帧（如果没有空闲帧，则执行页替换算法）。
2. 从硬盘读取所需页面，并更新页表项。
3. 在完成这些操作后，重新尝试引发页错误的指令，并将页面加载到 TLB 中。

### 21.6 交换何时真正发生

我们已经讨论了当内存满时，操作系统会执行页替换操作。然而，在实际系统中，操作系统通常不会等到内存完全用尽才开始页替换。为了提高效率，操作系统通常会维护一定量的空闲内存，通过设定高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），控制何时开始预防性地释放内存页。

当空闲页数少于低水位线时，一个后台线程（通常称为**交换守护进程**或**页守护进程**）会开始运行，释放内存直到达到高水位线。通过预先释放内存页，操作系统可以在需要时快速响应新页面的请求。

这种后台操作还可以通过聚集和合并多个要写入的页面来提高硬盘效率，减少寻道和旋转延迟。为了配合这个机制，图 21.3 中的控制流会做出调整，首先检查是否有空闲页，然后根据需要唤醒后台线程以释放内存。

### 21.7 小结

在本章中，我们探讨了操作系统如何支持超出物理内存大小的地址空间。通过增加存在位和页错误处理机制，操作系统可以将页面交换到硬盘上，并在需要时将其换回内存。整个过程对于正在运行的进程来说是透明的，它们只看到一个连续的虚拟内存空间。尽管内存访问在最坏情况下可能需要多个硬盘操作的时间，但这使得操作系统能够有效地管理内存并支持大规模的地址空间。