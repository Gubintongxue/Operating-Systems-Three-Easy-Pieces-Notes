### 第 22 章 超越物理内存：策略

在虚拟内存管理中，如果系统拥有大量的空闲内存，那么操作会变得非常简单。当页错误发生时，操作系统可以直接从空闲页列表中找到一个空闲页，并将其分配给所需的页面。这样的情况下，操作系统可以轻松应对内存管理的挑战。

然而，当内存资源变得紧张时，情况就会变得复杂得多。在内存压力下，操作系统不得不将一些页面换出内存，以为那些更常用的页面腾出空间。决定哪些页面应被踢出内存是操作系统替换策略的核心。替换策略直接影响系统性能，因此，在历史上，这是虚拟内存系统开发中最重要的决策之一。为了更好地理解这个问题，我们提出以下关键问题：

**关键问题**：如何决定踢出哪个页？

操作系统如何决定从内存中踢出哪些页面？这个决定通常由替换策略来实现，这些策略通常遵循一些通用的原则（将在下面讨论），同时会针对特殊情况进行调整。

#### 22.1 缓存管理

在深入研究替换策略之前，我们需要更详细地描述要解决的问题。因为内存只包含系统中所有页面的一个子集，所以可以将其视为虚拟内存页面的一个缓存。在为这个缓存选择替换策略时，我们的目标是将缓存未命中次数降到最低，即尽量减少从磁盘获取页面的次数。换句话说，目标是最大化缓存命中次数，即尽量在内存中找到所需的页面。

通过计算缓存命中和未命中次数，我们可以得出程序的平均内存访问时间（Average Memory Access Time, AMAT），这在计算机体系结构中是衡量硬件缓存性能的一个重要指标。公式如下：

```
scss
复制代码
AMAT = (PHit * TM) + (PMiss * TD)
```

其中，TM 表示内存访问的成本，TD 表示磁盘访问的成本，PHit 表示缓存命中的概率，PMiss 表示缓存未命中的概率。PHit 和 PMiss 的总和为 1。

举个例子，假设一个机器有一个 4KB 的地址空间，每页 256 字节。一个进程可能会产生以下内存访问序列：0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900。

假设内存中除了虚拟页 3 之外的所有页面都已加载，此时的内存访问序列的命中率为 90%（PHit = 0.9），未命中率为 10%（PMiss = 0.1）。根据上面的 AMAT 公式，假设 TM 为 100ns，TD 为 10ms，则 AMAT = 0.9 * 100ns + 0.1 * 10ms = 1ms。可以看到，即使有很小概率的缓存未命中，也会显著增加程序的平均内存访问时间。

#### 22.2 最优替换策略

为了理解替换策略的工作原理，我们可以将其与最优替换策略进行比较。最优替换策略（Belady 策略，也称为 MIN 策略）能够达到最少的未命中次数。这个策略的基本思想是，始终替换内存中在将来最远才会被访问的页面，以此最小化缓存未命中次数。

**提示**：尽管最优策略难以实际实现，但在仿真或研究中，它是一个有用的对比基准。通过与最优策略进行比较，可以了解新的替换策略有多接近理想状态，并评估是否还有改进的空间。

为了更好地理解最优策略，我们可以看一个简单的例子。假设一个程序按以下顺序访问虚拟页面：0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1。假设缓存可以存储 3 个页面，最优替换策略将按照表 22.1 所示的方式工作。

| 访问 | 命中/未命中 | 踢出 | 缓存状态 |
| ---- | ----------- | ---- | -------- |
| 0    | 未命中      |      | 0        |
| 1    | 未命中      |      | 0, 1     |
| 2    | 未命中      |      | 0, 1, 2  |
| 0    | 命中        |      | 0, 1, 2  |
| 1    | 命中        |      | 0, 1, 2  |
| 3    | 未命中      | 2    | 0, 1, 3  |
| 0    | 命中        |      | 0, 1, 3  |
| 3    | 命中        |      | 0, 1, 3  |
| 1    | 命中        |      | 0, 1, 3  |
| 2    | 未命中      | 3    | 0, 1, 2  |
| 1    | 命中        |      | 0, 1, 2  |

通过这个例子可以看到，最优替换策略能够确保在缓存未命中次数最少的情况下进行页面替换。

尽管最优策略无法在实际系统中实现，但它为我们提供了一个重要的参考基准。在开发实际可行的替换策略时，我们将致力于接近这个最优策略的性能。

接下来，我们将探索实际系统中使用的各种替换策略，以及它们在不同场景下的优劣。

### 22.3 简单策略：FIFO

许多早期的系统采用了非常简单的替换策略来管理内存页的替换，其中之一是 FIFO（先入先出）策略。该策略的基本思想非常简单：页在进入系统时被放入一个队列，当内存需要替换页面时，队列中最早进入的页（即“先入”页）将被踢出。

FIFO 策略的一个主要优势在于其实现非常简单。然而，这种简单性也意味着它无法识别页的重要性，只是按照它们进入内存的顺序进行替换。我们可以通过一个具体的例子来理解 FIFO 策略的执行过程（见表 22.2）。

在这个例子中，我们追踪 3 个页面（0、1 和 2）的访问序列。最开始是强制性未命中，因为内存开始是空的，接下来是页面 0 和 1 的命中。当页 3 被访问时，由于缓存已满，因此需要替换一个页面。FIFO 策略会选择最早进入内存的页，即页 0。遗憾的是，下一次访问又是页 0，这导致了另一次未命中和替换。结果，FIFO 的命中率较低，因为它并没有考虑页面的访问频率或重要性。

| 访问 | 命中/未命中 | 踢出 | 缓存状态 |
| ---- | ----------- | ---- | -------- |
| 0    | 未命中      |      | 0        |
| 1    | 未命中      |      | 0, 1     |
| 2    | 未命中      |      | 0, 1, 2  |
| 0    | 命中        |      | 0, 1, 2  |
| 1    | 命中        |      | 0, 1, 2  |
| 3    | 未命中      | 0    | 1, 2, 3  |
| 0    | 未命中      | 1    | 2, 3, 0  |
| 3    | 命中        |      | 2, 3, 0  |
| 1    | 未命中      | 2    | 3, 0, 1  |
| 2    | 未命中      | 3    | 0, 1, 2  |
| 1    | 命中        |      | 0, 1, 2  |

通过对比 FIFO 和最优策略，我们可以看到 FIFO 的局限性。FIFO 的命中率仅为 36.4%（不包括强制性未命中的命中率为 57.1%）。它无法识别页的重要性，即使某个页面多次被访问，也可能被不合理地踢出内存，从而降低系统性能。

**补充：Belady 的异常**

Belady（最优策略的发明者）及其同事发现了一种现象，被称为 **Belady 的异常**。在某些情况下，增大缓存大小反而会导致 FIFO 策略的缓存命中率下降。例如，当内存引用顺序为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5 时，缓存大小从 3 增加到 4，命中率反而降低了。这种现象是因为 FIFO 和随机策略没有栈特性，不能保证更大的缓存一定会带来更好的命中率。

### 22.4 另一简单策略：随机

另一种类似的简单替换策略是随机策略（Random）。在内存需要替换页面时，它随机选择一个页面进行替换。随机策略与 FIFO 相似，易于实现，但在选择替换页面时并不考虑页面的重要性或历史访问情况。表 22.3 展示了随机策略在我们的示例引用序列中的表现。

| 访问 | 命中/未命中 | 踢出 | 缓存状态 |
| ---- | ----------- | ---- | -------- |
| 0    | 未命中      |      | 0        |
| 1    | 未命中      |      | 0, 1     |
| 2    | 未命中      |      | 0, 1, 2  |
| 0    | 命中        |      | 0, 1, 2  |
| 1    | 命中        |      | 0, 1, 2  |
| 3    | 未命中      | 0    | 1, 2, 3  |
| 0    | 未命中      | 1    | 2, 3, 0  |
| 3    | 命中        |      | 2, 3, 0  |
| 1    | 未命中      | 3    | 2, 0, 1  |
| 2    | 命中        |      | 2, 0, 1  |
| 1    | 命中        |      | 2, 0, 1  |

随机策略的表现完全取决于运气。在上述例子中，随机策略的平均命中率在多次实验中有所波动，有时会接近最优策略，有时则会表现得更糟。

### 22.5 利用历史数据：LRU

简单的替换策略如 FIFO 或随机策略的一个主要缺陷是，它们可能会踢出一个即将被访问的重要页面。为了避免这个问题，替换策略可以利用历史访问数据来做出更明智的决策。基于历史数据的替换策略包括最不经常使用策略（LFU）和最少最近使用策略（LRU）。

LRU 策略基于局部性原则，假设最近访问过的页面在未来也有更大的可能性被再次访问。因此，LRU 选择替换最近最少使用的页面。

表 22.4 展示了 LRU 策略在我们示例引用序列中的表现。可以看到，LRU 策略有效地避免了替换即将被访问的页面，从而提高了缓存命中率。

| 访问 | 命中/未命中 | 踢出 | 缓存状态 |
| ---- | ----------- | ---- | -------- |
| 0    | 未命中      |      | 0        |
| 1    | 未命中      |      | 0, 1     |
| 2    | 未命中      |      | 0, 1, 2  |
| 0    | 命中        |      | 1, 2, 0  |
| 1    | 命中        |      | 2, 0, 1  |
| 3    | 未命中      | 2    | 0, 1, 3  |
| 0    | 命中        |      | 1, 3, 0  |
| 3    | 命中        |      | 1, 0, 3  |
| 1    | 命中        |      | 0, 3, 1  |
| 2    | 未命中      | 0    | 3, 1, 2  |
| 1    | 命中        |      | 3, 2, 1  |

从表中可以看出，LRU 策略利用了页面的历史访问信息，比 FIFO 和随机策略表现得更好。LRU 策略在许多情况下接近最优策略，是一种非常有效的替换策略。

通过这些例子，我们可以看到，不同的替换策略在处理页面替换时表现各异，选择合适的策略对于提升系统性能至关重要。

### 22.6 工作负载示例

为了更好地理解替换策略的表现，我们将通过几个工作负载示例来分析不同策略的效果。这些示例虽然简化了实际情况，但能帮助我们理解不同替换策略在各种条件下的表现。

#### **无局部性工作负载**

第一个工作负载没有任何局部性，这意味着每次内存引用都是随机访问一个页。在这个例子中，工作负载每次从 100 个不同的页中随机选择一个页进行访问，总共进行 10000 次访问。为了分析替换策略的表现，我们将缓存大小从 1 页增加到 100 页，以观察命中率的变化。

图 22.2 展示了最优策略、LRU、随机和 FIFO 策略在无局部性工作负载下的表现。y 轴显示了命中率，x 轴表示缓存大小的变化。

从图 22.2 可以得出以下结论：

1. **策略差异不大**：在没有局部性的工作负载中，LRU、FIFO 和随机策略的表现相差无几，因为所有的引用都是随机的，历史信息无法为这些策略提供优势。
2. **缓存大小的重要性**：随着缓存大小的增加，命中率也会提高。当缓存大小足够大，可以容纳所有的数据时，所有策略都会达到 100% 的命中率。
3. **最优策略的优势**：最优策略的表现始终优于其他策略，因为它能够“预知”未来的访问，选择最优的替换方案。

#### **80-20 工作负载**

第二个工作负载被称为“80-20”负载场景，表现出显著的局部性：80% 的引用集中在 20% 的页上（“热门”页），剩余 20% 的引用则分布在其余 80% 的页上（“冷门”页）。图 22.3 展示了不同策略在这个工作负载下的表现。

从图 22.3 可以看出：

1. **LRU 的优势**：由于 LRU 能够保留最近访问的页，因此在有局部性的工作负载下表现出色。它倾向于保留“热门”页，从而提高命中率。
2. **最优策略仍然占优**：虽然 LRU 表现良好，但最优策略依然比它表现更好，因为 LRU 仅依赖历史信息，而最优策略能准确预知未来的访问模式。

#### **循环顺序工作负载**

最后一个工作负载是“循环顺序”负载，它依次访问 50 个页，从 0 开始，访问到 49 后重新开始，总共进行了 10000 次访问。图 22.4 展示了不同策略在这个工作负载下的表现。

图 22.4 显示了：

1. **LRU 和 FIFO 的最差情况**：在循环顺序的工作负载下，LRU 和 FIFO 的表现极差，因为它们会不断踢出刚刚被访问的页，从而导致频繁的未命中。
2. **随机策略的表现较好**：与 LRU 和 FIFO 相比，随机策略在这个工作负载下表现更好，尽管离最优策略仍有差距，但至少能达到一定的命中率，避免了特殊情况下的糟糕结果。

### 22.7 实现基于历史信息的算法

如我们所见，像 LRU 这样的基于历史信息的策略通常比简单策略（如 FIFO 或随机）表现更好，因为它们能更有效地保留重要的页。然而，实现这些策略可能面临挑战，特别是在需要频繁更新和维护历史信息时。

#### **实现 LRU 的挑战**

实现 LRU 的一大挑战在于每次内存访问都需要更新某些数据，以将该页移动到列表的前面（即最近使用的一侧）。相比之下，FIFO 仅在页被替换或新页加入队列时更新列表。因此，为了记录哪些页最近使用，需要在每次内存访问时进行更新，这可能会影响性能。

一种可能的优化是增加硬件支持。例如，硬件可以在每次页访问时更新时间字段（存储在页表中或专门的数组中）。然而，扫描系统中所有页的时间字段以找到最少使用的页仍然代价高昂，特别是在页数量庞大的系统中。因此，有必要探讨是否可以实现近似的 LRU 替换策略，并且仍然保持较高的性能。

### 22.8 近似 LRU

实际上，许多现代系统采用了近似 LRU 的方法来实现高效的页面替换。一个典型的例子是时钟算法，它通过硬件支持的使用位（use bit 或 reference bit）来近似实现 LRU。

#### **时钟算法**

时钟算法将所有页组织成一个循环列表，时钟指针指向某个页。当需要替换页时，操作系统检查当前页的使用位。如果使用位为 1，表示该页最近被访问过，因此不适合被替换。操作系统将使用位设置为 0，并将时钟指针移动到下一个页，直到找到使用位为 0 的页并将其替换。

时钟算法虽然不如完美的 LRU 精确，但在性能上显著优于不考虑历史信息的策略，并且能够避免频繁扫描所有页带来的开销。图 22.5 展示了时钟算法在“80-20”工作负载下的表现，它比不考虑历史访问的策略更为有效。

### 22.9 考虑脏页

时钟算法的一个常见改进是考虑页的脏位（modified bit 或 dirty bit）。如果一个页被修改过，则将其换出需要写回磁盘，这将增加 I/O 开销。因此，一些系统更倾向于先踢出未被修改的干净页（clean page）。

通过这种方式，系统能够减少不必要的 I/O 操作，从而提高性能。这种改进在页替换策略中非常常见，特别是在磁盘 I/O 成本较高的系统中。

### 22.10 其他虚拟内存策略

除了页面替换策略之外，虚拟内存子系统还涉及其他一些策略，尽管页面替换可能是其中最重要的。例如，操作系统必须决定何时将页面载入内存，这一策略有时被称为**页选择（page selection）策略**。

#### **按需分页和预取**

大多数情况下，操作系统采用**按需分页（demand paging）**，即当页面被访问时，操作系统将其载入内存。这种策略在内存利用上非常有效，但也存在一定的延迟，因为第一次访问某个页面时可能会导致页错误，从而引发额外的磁盘 I/O 操作。

**预取（prefetching）**是一种更积极的策略，操作系统会尝试预测哪些页面可能会被访问，并提前将它们载入内存。比如，如果操作系统发现代码页 P 被载入内存，那么可能会猜测代码页 P+1 也很快会被访问，因此也将其载入。这种策略在某些情况下可以显著提高性能，特别是当程序具有强烈的顺序访问模式时。

#### **聚集写入**

另一项策略涉及操作系统如何将修改后的页面写入磁盘。操作系统可以选择每次只写入一个页面，或者采用一种更有效的策略——**聚集写入（clustering）**。在聚集写入中，操作系统会在内存中积累多个需要写入的页面，然后一次性将它们写入磁盘。这种方式可以利用硬盘的特性，提高写入效率，因为单次大规模的写入通常比多次小规模的写入更有效率。

### 22.11 抖动（Thrashing）

抖动（thrashing）是指当系统的内存需求超过可用物理内存时，操作系统频繁进行页面交换，导致系统性能严重下降的情况。在抖动状态下，CPU 大部分时间都在等待页面交换完成，而不是执行实际的工作。

#### **应对抖动**

一些早期的操作系统实现了复杂的机制来检测并应对抖动。例如，系统可以通过**准入控制（admission control）**来减少活跃进程的数量，从而减轻内存压力。通过暂停或推迟某些进程的执行，操作系统可以确保剩余进程的工作集（即它们正在使用的页面）可以完全装入内存，从而有效地避免抖动。

现代操作系统则可能采用更激进的策略。例如，某些 Linux 版本在内存严重不足时会启动**“内存不足的杀手程序（out-of-memory killer）”**，选择一个内存密集型进程并将其终止，从而立即释放内存。这种方法虽然能够缓解内存压力，但也可能带来问题，比如如果杀死了关键进程（如 X 服务器），系统的用户界面可能会崩溃。

### 22.12 小结

本章讨论了多种虚拟内存策略，特别是页面替换策略，这些策略是现代操作系统虚拟内存管理的核心部分。虽然传统的替换算法如 LRU 和时钟算法依然在使用，但现代系统也在进行改进。例如，**扫描抗性（scan resistance）**是许多现代算法的重要特性，旨在避免 LRU 在特定工作负载下的最差表现，如在循环顺序工作负载中观察到的情况。

随着内存和磁盘访问时间之间差距的扩大，页面替换算法的重要性可能有所下降。对于许多系统来说，减少分页的最佳方法往往是增加物理内存容量，因为频繁的分页操作代价实在太高。因此，购买更多的内存常常成为提升系统性能的最直接、最有效的手段。