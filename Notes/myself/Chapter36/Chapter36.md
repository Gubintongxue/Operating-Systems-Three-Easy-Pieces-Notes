### 第 36 章 I/O 设备

在深入讲解持久性部分之前，首先介绍 I/O 设备的概念以及操作系统如何与这些设备进行交互。I/O 对计算机系统至关重要，因为它涉及到程序的输入和输出操作。没有输入和输出的程序是没有实际意义的，因此，关键问题是：如何将 I/O 集成进计算机系统中，使其高效运行？

#### 36.1 系统架构

我们先来看一个典型的系统架构。系统中，CPU 通过内存总线与系统内存相连。高性能 I/O 设备（如图像处理设备）通过 I/O 总线连接到系统，而外围设备（如磁盘和鼠标）则通过外围总线（如 SCSI、SATA 或 USB）连接到系统。该分层架构的原因在于物理布局和造价成本。高性能总线较短且昂贵，因此用于连接需要高性能的设备，而低性能设备则通过外围总线连接，这样可以连接更多的设备。

#### 36.2 标准设备

为了理解设备交互机制，我们通过一个标准设备的例子来说明。标准设备由两个重要组件组成：

1. **硬件接口**：提供给系统其他部分的接口，使系统软件能够控制设备的操作。所有设备都有自己的接口和交互协议。
2. **内部结构**：设备的内部实现部分，负责具体实现设备所展示的抽象接口。简单设备可能只包含一个或几个芯片，而复杂设备则可能包含简单的 CPU、通用内存和特定芯片。

#### 36.3 标准协议

一个典型的设备接口包含三个寄存器：状态寄存器、命令寄存器和数据寄存器。操作系统通过读写这些寄存器来控制设备的行为。与设备的交互过程通常包括以下步骤：

1. 操作系统轮询状态寄存器，等待设备进入就绪状态。
2. 当设备就绪后，操作系统将数据写入数据寄存器。
3. 操作系统将命令写入命令寄存器，设备开始执行命令。
4. 操作系统再次轮询设备状态，等待设备完成命令执行。

这个协议简单有效，但在等待设备完成命令时，轮询过程可能会浪费大量 CPU 时间，从而导致低效。为了解决这一问题，操作系统需要优化策略，以减少轮询带来的开销。



#### 36.4 利用中断减少 CPU 开销

为了减少CPU在轮询设备状态时浪费的时间，中断机制被引入。中断允许设备在完成任务后主动通知CPU，而不需要CPU不断地检查设备状态。通过中断，操作系统可以让发出I/O请求的进程进入睡眠，并调度其他进程执行。当设备完成操作后，触发中断，操作系统执行中断服务程序（ISR），处理完设备的请求并唤醒等待的进程。这种机制允许计算与I/O操作并行进行，提高了CPU的利用率。

**优化策略**：

- 如果设备处理速度非常快，轮询可能比中断更有效，因为上下文切换和中断处理的开销可能会超过其收益。
- 在某些场景下（如高频网络数据包的处理），使用中断可能导致系统过载或活锁，此时适度轮询或中断合并（多个中断合并为一次）可以更好地控制系统行为。

#### 36.5 利用DMA进行更高效的数据传送

为了减少编程I/O（PIO）带来的CPU负载，直接内存访问（DMA）技术被引入。DMA是一种特殊的硬件机制，允许数据在内存和设备之间传输时无需CPU参与。操作系统通过编程DMA引擎，指定数据的位置、大小和目标设备，然后DMA负责完成数据传输。在DMA执行任务时，CPU可以继续处理其他任务，提高了系统整体的效率。当DMA任务完成后，它会触发中断通知操作系统数据传输已经完成。

这种机制进一步优化了I/O操作，使得CPU能够处理更多的进程，最大化资源利用率。

### 36.6 设备交互的方法

操作系统与设备通信的方式有两种：明确的I/O指令和内存映射I/O。通过I/O指令，操作系统可以使用特定的指令（如x86上的`in`和`out`指令）与设备交互，向特定寄存器或端口发送数据。这类指令通常是特权指令，只有操作系统能执行，以确保系统的安全性。

内存映射I/O则是通过将设备寄存器映射为内存地址来实现的。操作系统通过读写这些内存地址与设备通信，硬件将这些操作转发到设备上。这种方法无需引入新的指令，但与I/O指令相比，两者在当前系统中都有应用。

### 36.7 纳入操作系统：设备驱动程序

为使操作系统尽可能通用且设备无关，使用了设备驱动程序来处理设备的具体操作细节。驱动程序将设备的操作封装起来，使操作系统的其他部分无需关心具体设备的实现细节。例如，在Linux文件系统栈中，文件系统通过通用块设备层与设备驱动程序通信，块设备层将请求转发给相应的驱动程序，驱动程序处理具体的硬件操作。

尽管这种封装简化了操作系统的设计，但也有缺陷。某些设备的特殊功能可能无法通过通用接口使用。此外，由于每个设备都需要驱动程序，驱动程序代码占据了内核代码的很大一部分（超过70%）。由于许多驱动程序的开发者并非全职内核开发者，驱动程序成为系统崩溃的主要原因之一。

### 36.8 案例研究：简单的 IDE 磁盘驱动程序

在本节中，我们通过一个简单的 IDE 磁盘驱动程序的例子来更深入地了解设备驱动程序的工作原理，尤其是在 xv6 操作系统中的实现。

#### IDE 磁盘的基本接口

IDE 硬盘向操作系统提供了一个简单的接口，其中包含四种类型的寄存器：控制寄存器、命令块寄存器、状态寄存器和错误寄存器。在 x86 架构上，可以使用 I/O 指令 `in` 和 `out` 来访问这些寄存器，具体地址和功能如下：

- **控制寄存器（Control Register）**：地址为 `0x3F6`，用于控制设备复位和中断启用。
- **命令块寄存器（Command Block Registers）**：地址范围为 `0x1F0` 到 `0x1F7`，包括数据端口、错误寄存器、扇区计数器、逻辑块地址（LBA）寄存器和命令寄存器。
- **状态寄存器（Status Register）**：地址为 `0x1F7`，包括设备状态标志，如忙碌（BUSY）、就绪（READY）、数据请求（DRQ）等。
- **错误寄存器（Error Register）**：地址为 `0x1F1`，在状态寄存器的错误标志置位时，用于检查详细的错误信息。

#### 与 IDE 设备交互的基本协议

与 IDE 设备进行交互的基本协议包括以下步骤：

1. **等待设备就绪**：读取状态寄存器，直到设备 READY 且未忙碌为止。
2. **设置命令参数**：写入扇区数量和 LBA 地址，并指定驱动编号。
3. **启动 I/O 操作**：向命令寄存器写入读取或写入命令。
4. **数据传输**：对于写操作，等待设备准备好接收数据，然后将数据写入数据端口。
5. **中断处理**：每个扇区的传输结束后处理中断，或者批量处理数据后触发中断。
6. **错误处理**：操作完成后检查状态寄存器，必要时读取错误寄存器获取详细错误信息。

#### xv6 中的 IDE 驱动程序实现

xv6 操作系统中的 IDE 驱动程序实现了上述协议，主要由以下函数组成：

- **`ide_wait_ready()`**：等待驱动就绪，通过反复读取状态寄存器，直到设备不再忙碌并且处于就绪状态。

  ```
  c复制代码static int ide_wait_ready() { 
    while (((int r = inb(0x1f7)) & IDE_BSY) || !(r & IDE_DRDY)) 
      ; // loop until drive isn't busy 
  }
  ```

- **`ide_start_request()`**：开始一个 I/O 请求，将请求发送给磁盘。如果是写操作，还会发送数据。

  ```
  c复制代码static void ide_start_request(struct buf *b) { 
    ide_wait_ready(); 
    outb(0x3f6, 0); // generate interrupt 
    outb(0x1f2, 1); // how many sectors? 
    outb(0x1f3, b->sector & 0xff); // LBA goes here ... 
    outb(0x1f4, (b->sector >> 8) & 0xff); // ... and here 
    outb(0x1f5, (b->sector >> 16) & 0xff); // ... and here! 
    outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((b->sector>>24)&0x0f)); 
    if(b->flags & B_DIRTY){ 
      outb(0x1f7, IDE_CMD_WRITE); // this is a WRITE 
      outsl(0x1f0, b->data, 512/4); // transfer data too! 
    } else { 
      outb(0x1f7, IDE_CMD_READ); // this is a READ (no data) 
    } 
  }
  ```

- **`ide_rw()`**：处理读写请求，将请求加入队列，如果队列为空，则直接发送请求到磁盘。等待请求完成时，进程进入睡眠状态。

  ```
  c复制代码void ide_rw(struct buf *b) { 
    acquire(&ide_lock); 
    for (struct buf **pp = &ide_queue; *pp; pp=&(*pp)->qnext) 
      ; // walk queue 
    *pp = b; // add request to end 
    if (ide_queue == b) // if q is empty 
      ide_start_request(b); // send req to disk 
    while ((b->flags & (B_VALID|B_DIRTY)) != B_VALID) 
      sleep(b, &ide_lock); // wait for completion 
    release(&ide_lock); 
  }
  ```

- **`ide_intr()`**：处理磁盘中断，在读请求时从设备读取数据，并唤醒等待的进程。如果队列中还有其他请求，继续处理下一个请求。

  ```
  c复制代码void ide_intr() { 
    struct buf *b; 
    acquire(&ide_lock); 
    if (!(b->flags & B_DIRTY) && ide_wait_ready() >= 0) 
      insl(0x1f0, b->data, 512/4); // if READ: get data 
    b->flags |= B_VALID; 
    b->flags &= ~B_DIRTY; 
    wakeup(b); // wake waiting process 
    if ((ide_queue = b->qnext) != 0) // start next request 
      ide_start_request(ide_queue); // (if one exists) 
    release(&ide_lock); 
  }
  ```

这个驱动程序展示了操作系统如何通过一系列寄存器与 IDE 磁盘交互，完成读写操作，并通过中断机制提高系统效率。

### 36.9 历史记录

在结束之前，本节简要回顾了中断和 DMA 等基本思想的历史起源。这些技术在计算机发展的早期已经出现，并随着时间的发展不断完善。

- **中断**：早在 20 世纪 50 年代，像 UNIVAC 这样的早期计算机已经有某种形式的中断向量，尽管具体的起源年份并不明确。中断技术允许 CPU 在等待 I/O 操作时执行其他任务，从而提高效率。
- **DMA（直接内存访问）**：DMA 的起源同样在 20 世纪 50 年代中期。Knuth 和其他一些人认为第一个使用 DMA 技术的是 DYSEAC，而另一些人认为是 IBM SAGE。无论如何，这些系统能够让 I/O 设备直接与内存交互，并在完成后中断 CPU。

这些技术的发展背景与当时的计算机硬件条件密切相关：早期的 CPU 速度相对较快，而 I/O 设备则相对较慢。因此，工程师们开发了中断和 DMA 等机制，以便在执行 I/O 操作时更好地利用 CPU 资源。

### 36.10 小结

本章提供了操作系统如何与 I/O 设备交互的基本理解，并介绍了几种提高设备效率的重要技术。

- **中断**：通过允许 CPU 在等待 I/O 操作时执行其他任务，中断技术极大地提高了系统的效率。
- **DMA（直接内存访问）**：DMA 使得数据在设备和内存之间传输时，不需要 CPU 的直接介入，从而进一步解放了 CPU 资源。
- **访问设备寄存器的方式**：介绍了通过 I/O 指令和内存映射 I/O 来访问设备寄存器的两种方式。
- **设备驱动程序**：操作系统通过设备驱动程序来封装设备的具体操作细节，使得操作系统能够以设备无关的方式进行设计和构建。

这些内容为理解操作系统如何高效地与硬件设备交互奠定了基础。