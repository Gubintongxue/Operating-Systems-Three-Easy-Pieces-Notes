## 第 40 章 文件系统实现

本章详细介绍了 VSFS（Very Simple File System），一个简化版的 UNIX 文件系统。VSFS 用于演示文件系统的基本结构、访问方法和策略。这些概念在许多现代文件系统中仍然适用。

#### 原文：

​		本章将介绍一个简单的文件系统实现，称为 VSFS（Very Simple File System，简单文件系统）。它是典型 UNIX 文件系统的简化版本，因此可用于介绍一些基本磁盘结构、访问方法和各种策略，你可以在当今许多文件系统中看到。

​		文件系统是纯软件。与 CPU 和内存虚拟化的开发不同，我们不会添加硬件功能来使文件系统的某些方面更好地工作（但我们需要注意设备特性，以确保文件系统运行良好）。由于在构建文件系统方面具有很大的灵活性，因此人们构建了许多不同的文件系统，从 AFS（Andrew 文件系统）[H+88]到 ZFS（Sun 的 Zettabyte 文件系统）[B07]。所有这些文件系统都有不同的数据结构，在某些方面优于或逊于同类系统。因此，我们学习文件系统的方式是通过案例研究：首先，通过本章中的简单文件系统（VSFS）介绍大多数概念。然后，对真实文件系统进行一系列研究，以了解它们在实践中有何区别。

![image-20240902152934812](image/image-20240902152934812.png)



### 40.1 思考方式

理解文件系统的两个核心方面是：

1. **数据结构**：文件系统使用的数据结构用于组织磁盘上的数据和元数据。例如，简单的文件系统（如 VSFS）使用块数组，而更复杂的文件系统（如 XFS）使用基于树的结构。
2. **访问方法**：访问方法定义了如何将系统调用（如 `open()`、`read()`、`write()`）映射到文件系统的数据结构上。了解在这些调用期间哪些结构会被读取或修改，是理解文件系统工作的关键。



#### 原文：

​		考虑文件系统时，我们通常建议考虑它们的两个不同方面。如果你理解了这两个方面，

可能就理解了文件系统基本工作原理。

第一个方面是文件系统的数据结构（data structure）。换言之，文件系统在磁盘上使用哪

些类型的结构来组织其数据和元数据？我们即将看到的第一个文件系统（包括下面的

VSFS）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统（如 SGI 的 XFS）

使用更复杂的基于树的结构[S+96]。





### 40.2 整体组织

VSFS 文件系统的基本组织方式包括将磁盘分割成大小为 4KB 的块。磁盘的每个部分用于不同的目的：

- **数据区域（Data Region）**：用于存放用户数据的磁盘区域，占据磁盘大部分空间。例如，64 块的磁盘中，最后 56 块用于数据区域。
- **inode 表（Inode Table）**：存放文件元数据的表格，每个 inode 记录文件的大小、块位置、权限等信息。假设 5 个块用于 inode 表，每个块可存储 16 个 inode，总共可存储 80 个 inode。
- **分配结构（Allocation Structure）**：用于记录 inode 和数据块的使用状态。VSFS 使用位图来表示块的分配状态：
  - **数据位图（Data Bitmap）**：标记数据块的分配状态。
  - **inode 位图（Inode Bitmap）**：标记 inode 的分配状态。
- **超级块（Superblock）**：包含关于文件系统的全局信息，如 inode 和数据块的总数及其起始位置。

下图展示了磁盘布局：

```
scss复制代码| S (Superblock) | i (Inode Bitmap) | d (Data Bitmap) | I (Inode Table) | D (Data Region) |
|       1块       |      1块         |       1块        |      5块          |      56块         |
```

### 40.3 文件组织：inode

**inode** 是存储文件元数据的结构，包括文件类型、大小、权限、时间戳和数据块指针。每个 inode 由一个 inode 号（inumber）标识。VSFS 中，inode 号可用于直接计算 inode 在磁盘上的位置。

假设 inode 表从 12KB 开始，读取 inode 号为 32 的节点时的计算如下：

- 偏移量计算：`32 × 256字节 = 8192字节`

- 加上 inode 表起始地址：`8192字节 + 12KB = 20KB`

- 扇区地址计算：

  ```
  plaintext复制代码blk = (inumber * sizeof(inode_t)) / blockSize;
  sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;
  ```

**设计 inode 的关键在于如何引用数据块的位置**：

- **直接指针**：每个直接指针指向一个数据块。
- **间接指针**：指向一个包含多个指针的块，每个指针指向一个数据块。
- **双重间接指针**：指向包含间接块指针的块，间接块包含数据块指针。
- **多级索引**：这种不平衡树形结构允许 inode 支持非常大的文件。

表 40.1 列出了 ext2 的 inode 结构示例：

| 大小（字节） | 名称        | 用途              |
| ------------ | ----------- | ----------------- |
| 2            | mode        | 文件权限          |
| 2            | uid         | 文件所有者        |
| 4            | size        | 文件大小          |
| 4            | time        | 最近访问时间      |
| 4            | ctime       | 创建时间          |
| 4            | mtime       | 最近修改时间      |
| 4            | dtime       | 删除时间          |
| 2            | gid         | 所属分组          |
| 2            | links count | 硬链接数量        |
| 4            | blocks      | 分配的块数        |
| 4            | flags       | inode 的使用方式  |
| 60           | block       | 磁盘指针（15 个） |

### 40.4 目录组织

VSFS 目录的组织非常简单，是由（文件名, inode 号）组成的列表。每个目录条目包含 inode 号、记录长度、字符串长度和文件名。

例如，目录 `dir`（inode 号为 5）中有三个文件（`foo`、`bar` 和 `foobar`），它们的 inode 号分别为 12、13 和 24：

| inum | reclen | strlen | name   |
| ---- | ------ | ------ | ------ |
| 5    | 4      | 2      | .      |
| 2    | 4      | 3      | ..     |
| 12   | 4      | 4      | foo    |
| 13   | 4      | 4      | bar    |
| 24   | 8      | 7      | foobar |

目录的 inode 标记为“目录”类型，并且可以包含直接指向数据块的指针或间接块。

### 40.5 空闲空间管理

VSFS 使用 inode 位图和数据位图来管理空闲空间。这些位图标记哪些 inode 和数据块是空闲的，哪些是已分配的。在创建文件时，系统搜索位图以找到空闲的 inode 并将其分配给新文件。对数据块的分配也类似。

**预分配策略**：在创建文件时，VSFS 会寻找连续的一系列空闲块，从而保证文件在磁盘上的连续性，提高访问性能。

### 40.6 访问路径：读取和写入

VSFS 处理文件读取和写入的访问路径包括：

#### 从磁盘读取文件

以读取文件 `/foo/bar` 为例：

1. 打开文件 `/foo/bar` 的调用会触发系统从根目录开始遍历路径。
2. 根目录的 inode 号为 2，是已知的，在文件系统挂载时加载。
3. 系统首先读取根目录的 inode 和数据块，查找 `foo` 的 inode 号。
4. 递归查找 `bar` 的 inode，读取其数据。
5. 系统返回文件描述符供用户使用。

表 40.3 描述了打开和读取文件的时间线：

| 操作      | 影响的块             | 操作详情                  |
| --------- | -------------------- | ------------------------- |
| open(bar) | root, foo, bar inode | 读取根、foo、bar 的 inode |
| read      | bar data[0]          | 读取 bar 的第一个数据块   |
| read()    | bar data[1]          | 读取第二个数据块          |

#### 写入磁盘

写入操作通常需要分配新块，导致多次 I/O 操作。表 40.4 展示了创建文件 `/foo/bar` 并写入 3 个块的时间线：

| 操作             | 影响的块             | 操作详情                                          |
| ---------------- | -------------------- | ------------------------------------------------- |
| create(/foo/bar) | root, foo, bar inode | 创建文件的过程中，读取和更新根、foo、bar 的 inode |
| write()          | data bitmap, inode   | 更新 inode 和数据位图，写入数据块                 |
| write()          | data bitmap, inode   | 更新 inode 和数据位图，写入数据块                 |
| write()          | data bitmap, inode   | 更新 inode 和数据位图，写入数据块                 |

### 40.7 缓存和缓冲

为了减少 I/O 操作，VSFS 使用系统内存作为缓存：

- **读取缓存**：通过缓存目录 inode 和数据块，减少重复的读取操作。
- **写入缓存**：将写入操作延迟到内存中批处理，从而减少磁盘 I/O。例如，在文件创建和删除频繁发生时，延迟写入可以避免不必要的 I/O。

现代文件系统通常将虚拟内存页面和文件系统页面集成到统一的页面缓存中，实现资源的动态划分。这种灵活性提高了内存的利用率和系统的整体性能。

### 40.8 小结

VSFS 展示了构建文件系统的基本机制，包括 inode、目录、位图和超级块。文件系统的设计有很大的自由度，这使得开发者可以通过优化不同策略来提升系统性能。在未来的章节中，还会深入探讨如何优化这些策略以实现更高效的文件系统。