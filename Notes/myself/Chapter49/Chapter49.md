### 第 49 章 Andrew 文件系统（AFS）

Andrew 文件系统（AFS）是由卡内基梅隆大学（CMU）的研究人员于 20 世纪 80 年代开发的，旨在实现大规模的分布式文件系统，其主要目标是扩展性。AFS 与 NFS 在设计理念和实现细节上有显著差异，尤其是在缓存机制和一致性模型方面。

#### 49.1 AFS 版本 1

AFS 的第一个版本（AFSv1）采用全文件缓存（whole-file caching）机制，客户端在本地磁盘上缓存完整文件。当客户端打开文件时，它会从服务器获取整个文件并存储在本地磁盘，所有后续的 `read()` 和 `write()` 操作都在本地进行，不需要网络通信。文件在 `close()` 时如果被修改，会被写回服务器。这种机制显著减少了对服务器的依赖，但也存在一些问题：

1. **路径查找成本高**：每次 Fetch 或 Store 请求都需要服务器遍历完整路径，导致服务器负载过高。
2. **频繁的状态验证**：AFSv1 通过 TestAuth 消息频繁检查缓存是否有效，这与 NFS 的 GETATTR 请求类似，造成服务器负载增加。

这些问题影响了 AFS 的可扩展性，每台服务器只能支持大约 20 个客户端。

#### 49.2 AFS 版本 2

AFSv2 通过引入 **回调（callback）** 机制和 **文件标识符（FID）** 改进了协议设计：

1. **回调机制**：服务器会在客户端缓存文件时记录一个回调，当文件在服务器端发生更改时通知客户端。这减少了客户端对服务器的频繁查询。
2. **文件标识符（FID）**：AFS 使用 FID 而不是路径名来标识文件，减少了路径查找的开销。客户端在首次访问时逐步获取目录和文件，并建立相应的回调，以减少后续访问中的服务器交互。

AFSv2 的这些改进大幅提升了可扩展性，每台服务器可以支持约 50 个客户端，同时保持性能接近本地文件系统。

#### 49.3 缓存一致性

AFS 提供了简单易懂的缓存一致性模型：

- **不同机器上的进程**：当一个客户端写入文件并关闭时，服务器更新文件并通知所有缓存了该文件的客户端，使其缓存无效。后续打开请求将获取最新的文件版本。
- **同一机器上的进程**：写入操作对本地进程立即可见，不需要等到文件关闭。

AFS 采用“最后写入者胜出”策略处理跨机器的并发写入，即最后一个关闭文件的客户端的更改将保留在服务器上。

#### 49.4 崩溃恢复

AFS 的崩溃恢复机制比 NFS 更为复杂。由于服务器保存回调信息，如果客户端或服务器崩溃，可能会丢失这些状态。为此，客户端需要在重新连接服务器时验证其缓存的有效性，并在服务器崩溃后重新验证所有缓存的文件。

#### 49.5 AFS 的性能和扩展性

AFSv2 通过减少服务器交互和改进协议设计，提升了性能和扩展性。其性能在大多数情况下接近本地文件系统，尤其在缓存命中率高的场景下表现尤为出色。相比之下，NFS 的性能依赖于网络访问，尤其在多次读取大文件时，AFS 的磁盘缓存优势更加明显。

AFS 的设计假设大多数文件按顺序完整访问，并且文件共享不频繁。尽管在某些特定工作负载下 AFS 可能表现不佳，但在大多数常见使用场景中，它都优于 NFS。

#### 49.6 AFS 的其他改进

除了基本的协议改进，AFS 还引入了一些增强功能：

- **全局命名空间**：所有客户端在文件命名上保持一致，提升了系统的易用性。
- **安全性**：AFS 对用户身份验证和文件访问控制有更强的支持，确保了文件的安全性和隐私。
- **系统管理**：AFS 提供了更易于管理的工具和功能，使得管理员可以更方便地维护系统。

#### 49.7 小结

AFS 通过创新的协议设计，实现了比 NFS 更高的扩展性和性能。全文件缓存和回调机制的结合，使得客户端与服务器的交互最小化，提升了系统效率。AFS 提供的强一致性模型和易于理解的缓存行为，使得它在某些环境中特别受欢迎。

尽管 AFS 的市场影响力逐渐减弱，但其思想和设计原则对后续的分布式文件系统发展产生了深远影响，尤其是对 NFSv4 的设计启发。AFS 的历史表明，协议设计对分布式文件系统的成功至关重要，合理的设计能够有效提升系统的性能和可扩展性。