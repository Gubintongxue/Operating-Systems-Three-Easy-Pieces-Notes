# 第33章 基于事件的并发（进阶）

​		目前为止，我们提到的并发，似乎只能用线程来实现。就像生活中的许多事，这不完全对。具体来说，一些基于图形用户界面（GUI）的应用[O96]，或某些类型的网络服务器[PDZ99]，常常采用另一种并发方式。这种方式称为基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如 node.js[N13]，但它源自于 C/UNIX 系统，我们下面将讨论。

​		基于事件的并发针对两方面的问题。一方面是多线程应用中，正确处理并发很有难度。正如我们讨论的，忘加锁、死锁和其他烦人的问题会发生。另一方面，开发者无法控制多线程在某一时刻的调度。程序员只是创建了线程，然后就依赖操作系统能够合理地调度线程。要实现一个在各种不同负载下，都能够良好运行的通用调度程序，是极有难度的。因此，某些时候操作系统的调度并不是最优的。关键问题如下。

![image-20240910175939483](image/image-20240910175939483.png)



## 33.1 基本想法：事件循环

在基于事件的并发模型中，不使用传统的多线程并发处理，而是依赖一个事件循环（event loop）来处理并发任务。事件循环的基本思想非常简单，它等待某个事件的发生，当事件发生时，就会处理该事件，然后继续等待下一个事件。这种方法避免了多线程并发中的一些常见问题，如死锁和复杂的调度问题。

事件循环的伪代码如下：

```
while (1) { 
    events = getEvents(); 
    for (e in events) 
        processEvent(e); 
}
```

在这个循环中，`getEvents()`负责获取所有已经发生的事件，然后`processEvent(e)`处理每个事件。事件循环的优点之一是它对调度有显式的控制，这意味着程序可以决定何时处理哪个事件，而不是依赖操作系统的调度机制。

### 原文：

​		我们使用的基本方法就是基于事件的并发（event-based concurrency）。该方法很简单：我们等待某事（即“事件”）发生；当它发生时，检查事件类型，然后做少量的相应工作（可能是 I/O 请求，或者调度其他事件准备后续处理）。这就好了！

​		在深入细节之前，我们先看一个典型的基于事件的服务器。这种应用都是基于一个简单的结构，称为事件循环（event loop）。事件循环的伪代码如下：

```
while (1) { 
 events = getEvents(); 
 for (e in events) 
 processEvent(e); 
}
```

​		它确实如此简单。主循环等待某些事件发生（通过 getEvents()调用），然后依次处理这些发生的事件。处理事件的代码叫作事件处理程序（event handler）。重要的是，处理程序在处理一个事件时，它是系统中发生的唯一活动。因此，调度就是决定接下来处理哪个事件。这种对调度的显式控制，是基于事件方法的一个重要优点。

​		但这也带来一个更大的问题：基于事件的服务器如何决定哪个事件发生，尤其是对于网络和磁盘 I/O？具体来说，事件服务器如何确定是否有它的消息已经到达？



## 33.2 重要 API：select()（或 poll()）

​		为了实现基于事件的并发模型，事件循环需要一种方法来检测是否有事件发生，特别是在处理网络和磁盘 I/O 时。大多数操作系统提供了`select()`或`poll()`系统调用来支持这一功能。这些调用允许程序检查文件描述符，看看它们是否有数据可读或可写，从而决定是否应该处理这些描述符。

### `select()`函数

`select()`的原型如下：

```
int select(int nfds, 
    fd_set *restrict readfds, 
    fd_set *restrict writefds, 
    fd_set *restrict errorfds, 
    struct timeval *restrict timeout);
```

- `nfds`：指定要检查的文件描述符的数量。
- `readfds`：指向一组文件描述符的指针，用于检查它们是否可以读取。
- `writefds`：指向一组文件描述符的指针，用于检查它们是否可以写入。
- `errorfds`：指向一组文件描述符的指针，用于检查是否有异常情况。
- `timeout`：指定`select()`调用等待的最长时间。如果设置为`NULL`，`select()`将无限期等待直到有描述符变得可用。

​		`select()`返回已经准备好的描述符的数量，这样程序就可以处理这些描述符。通常情况下，基于事件的服务器会使用`select()`来实现非阻塞I/O，从而避免整个服务器因为一个阻塞调用而被挂起。

### 阻塞与非阻塞接口

​		阻塞（同步）接口在完成任务后才会返回，而非阻塞（异步）接口则会在开始任务后立即返回，任务在后台继续执行。对于基于事件的并发模型，非阻塞接口是至关重要的，因为阻塞调用会阻止事件循环继续处理其他事件，导致系统挂起。

### 小结

​		基于事件的并发模型是处理并发任务的一种有效方式，尤其适用于需要处理大量 I/O 操作的服务器。通过使用事件循环和`select()`或`poll()`系统调用，程序可以检测并处理事件，而不需要依赖复杂的多线程模型。这种方法不仅简化了并发编程，还避免了许多多线程编程中的常见问题。

### 原文：

​		知道了基本的事件循环，我们接下来必须解决如何接收事件的问题。大多数系统提供了基本的 API，即通过 select()或 poll()系统调用。这些接口对程序的支持很简单：检查是否有任何应该关注的进入 I/O。例如，假定网络应用程序（如 Web 服务器）希望检查是否有网络数据包已到达，以便为它们提供服务。这些系统调用就让你做到这一点。

​		下面以 select()为例，手册页（在 macOS X 上）以这种方式描述 API：

```C
int select(int nfds, 
 fd_set *restrict readfds, 
 fd_set *restrict writefds, 
 fd_set *restrict errorfds, 
 struct timeval *restrict timeout);
```

​		手册页中的实际描述：select()检查 I/O 描述符集合，它们的地址通过 readfds、writefds和 errorfds 传入，分别查看它们中的某些描述符是否已准备好读取，是否准备好写入，或有异常情况待处理。在每个集合中检查前 nfds 个描述符，即检查描述符集合中从 0 到 nfds-1的描述符。返回时，select()用给定请求操作准备好的描述符组成的子集替换给定的描述符集合。select()返回所有集合中就绪描述符的总数。

![image-20240910180302913](image/image-20240910180302913.png)

​		关于 select()有几点要注意。首先，请注意，它可以让你检查描述符是否可以读取和写入。前者让服务器确定新数据包已到达并且需要处理，而后者则让服务知道何时可以回复（即出站队列未满）。

​		其次，请注意超时参数。这里的一个常见用法是将超时设置为 NULL，这会导致 select()无限期地阻塞，直到某个描述符准备就绪。但是，更健壮的服务器通常会指定某种超时。一种常见的技术是将超时设置为零，因此让调用 select()立即返回。

​		poll()系统调用非常相似。有关详细信息，请参阅其手册页或 Stevens 和 Rago 的书[SR05]。

​		无论哪种方式，这些基本原语为我们提供了一种构建非阻塞事件循环的方法，它可以简单地检查传入数据包，从带有消息的套接字中读取数据，并根据需要进行回复。



## 33.3 使用 `select()`

​		为了更具体地说明如何使用 `select()` 来检测哪些网络描述符上有传入消息，下面是一段简单的示例代码，如图 33.1 所示：

```C
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/time.h> 
#include <sys/types.h> 
#include <unistd.h> 

int main(void) { 
    // open and set up a bunch of sockets (not shown) 
    // main loop 
    while (1) { 
        // initialize the fd_set to all zero 
        fd_set readFDs; 
        FD_ZERO(&readFDs); 
        
        // now set the bits for the descriptors 
        // this server is interested in 
        // (for simplicity, all of them from min to max) 
        int fd; 
        for (fd = minFD; fd < maxFD; fd++) 
            FD_SET(fd, &readFDs); 
        
        // do the select 
        int rc = select(maxFD+1, &readFDs, NULL, NULL, NULL); 
        
        // check which actually have data using FD_ISSET() 
        for (fd = minFD; fd < maxFD; fd++) 
            if (FD_ISSET(fd, &readFDs)) 
                processFD(fd); 
    } 
}
```

​		这段代码展示了一个简单的事件循环。在每次循环中，`FD_ZERO()` 用于清空文件描述符集合，然后 `FD_SET()` 将所有从 `minFD` 到 `maxFD` 的文件描述符添加到集合中。随后，通过 `select()` 函数检测哪些描述符有数据可读。`FD_ISSET()` 函数则用于检查哪些描述符已经准备好数据，并调用 `processFD(fd)` 处理这些描述符。

​		实际的服务器会更加复杂，包含发送消息、执行磁盘 I/O 等逻辑。关于更多详细信息，可以参考 Stevens 和 Rago 的书籍 [SR05]。

### 原文：

​		为了让这更具体，我们来看看如何使用 select()来查看哪些网络描述符在它们上面有传入消息。图 33.1 展示了一个简单的例子。







## 33.4 为何更简单？无须锁

​		在使用单个 CPU 和基于事件的应用程序时，并发程序中通常遇到的问题（如死锁）并不存在。由于基于事件的方法是单线程的，因此一次只处理一个事件，不需要使用锁。这样避免了线程间的中断问题，也避免了多线程编程中的常见并发性错误。

#### **提示**：**请勿阻塞基于事件的服务器**

**基于事件的服务器需要对任务调度进行细粒度的控制，因此在设计中必须避免阻塞调用。如果阻塞调用被允许执行，整个服务器将会被阻塞，无法继续处理其他事件。**

## 33.5 一个问题：阻塞系统调用

虽然基于事件的编程方式听起来很理想，但它有一个显著的问题：如果某个事件处理程序需要发出可能会阻塞的系统调用怎么办？

例如，假设一个服务器接收到客户端的请求，需要从磁盘读取一个文件并将其返回给客户端。为了完成这个任务，服务器可能需要执行 `open()` 和一系列 `read()` 系统调用，而这些调用可能会阻塞，等待磁盘 I/O 完成。

在基于线程的服务器中，这不是一个问题，因为其他线程可以继续执行。而在基于事件的服务器中，由于它是单线程的，如果某个事件处理程序阻塞了整个事件循环，整个服务器都会被阻塞，导致资源浪费。

## 33.6 解决方案：异步 I/O

为了克服阻塞调用的问题，许多现代操作系统引入了异步 I/O（asynchronous I/O）。异步 I/O 允许应用程序发出 I/O 请求，并在 I/O 完成之前立即返回控制权。应用程序可以通过其他接口来检查这些 I/O 是否完成。

### 示例：macOS 上的异步 I/O

在 macOS 上，异步 I/O 通过 `struct aiocb`（AIO 控制块）来实现。`struct aiocb` 的简化版本如下：

```
struct aiocb { 
    int aio_fildes;    /* File descriptor */ 
    off_t aio_offset;  /* File offset */ 
    volatile void *aio_buf; /* Location of buffer */ 
    size_t aio_nbytes; /* Length of transfer */ 
};
```

要进行异步读取，应用程序需要先填充该结构，然后调用 `aio_read()` 函数：

```
int aio_read(struct aiocb *aiocbp);
```

`aio_read()` 调用会尝试发出 I/O 请求并立即返回，应用程序可以继续执行其他任务。

为了检查 I/O 请求是否完成，应用程序可以使用 `aio_error()` 函数：

```
int aio_error(const struct aiocb *aiocbp);
```

该函数返回 0 表示 I/O 已完成，返回 `EINPROGRESS` 表示 I/O 尚未完成。

### 补充：**UNIX** 信号

​		所有现代 UNIX 变体都有一个称为信号（signal）的巨大而迷人的基础设施。最简单的信号提供了一种与进程进行通信的方式。具体来说，可以将信号传递给应用程序。这样做会让应用程序停止当前的任何工作，开始运行信号处理程序（signal handler），即应用程序中某些处理该信号的代码。完成后，该进程就恢复其先前的行为。

​		每个信号都有一个名称，如 HUP（挂断）、INT（中断）、SEGV（段违规）等。有关详细信息，请参阅手册页。有趣的是，有时是内核本身发出信号。例如，当你的程序遇到段违规时，操作系统发送一个 SIGSEGV（在信号名称之前加上 SIG 是很常见的）。如果你的程序配置为捕获该信号，则实际上可以运行一些代码来响应这种错误的程序行为（这可能对调试有用）。当一个信号被发送到一个没有配置处理该信号的进程时，一些默认行为就会生效。对于 SEGV 来说，这个进程会被杀死。

​		下面一个进入无限循环的简单程序，但首先设置一个信号处理程序来捕捉 SIGHUP：

```
#include <stdio.h> 
#include <signal.h> 
void handle(int arg) { 
 printf("stop wakin' me up...\n"); 
} 
int main(int argc, char *argv[]) { 
 signal(SIGHUP, handle); 
 while (1) 
 ; // doin' nothin' except catchin' some sigs 
 return 0; 
}
```

​		你可以用 kill 命令行工具向其发送信号（是的，这是一个奇怪而富有攻击性的名称）。这样做会中断程序中的主 while 循环并运行处理程序代码 handle()：

```
prompt> ./main & 
[3] 36705 
prompt> kill -HUP 36705 
stop wakin' me up... 
prompt> kill -HUP 36705 
stop wakin' me up... 
prompt> kill -HUP 36705 
stop wakin' me up...
```

要了解信号还有很多事情要做，以至于单个页面，甚至单独的章节，都远远不够。与往常一样，有

一个重要来源：Stevens 和 Rago 的书[SR05]。如果感兴趣，请阅读。



在没有异步 I/O 的系统中，纯基于事件的方法无法实现。然而，聪明的研究人员已经推出了相当适合他们的方法。例如，Pai 等人 [PDZ99]描述了一种使用事件处理网络数据包的混合方法，并且使用线程池来管理未完成的 I/O。详情请阅读他们的论文。

### 总结

基于事件的并发编程可以避免多线程中的许多复杂性，但也需要考虑如何处理可能阻塞的系统调用。异步 I/O 提供了一种解决方案，允许服务器在处理 I/O 请求时不阻塞事件循环，从而提高服务器的并发性能和响应速度。

## 33.7 另一个问题：状态管理

基于事件的方法的另一个挑战在于状态管理。与基于线程的方法不同，基于事件的代码通常更复杂，因为它需要手动管理程序状态。当事件处理程序发出异步 I/O 请求时，它必须打包一些状态信息，以便在 I/O 完成时，能够在下一个事件处理程序中使用。这种手动栈管理（manual stack management）使得基于事件的编程更加复杂。

举个例子，假设一个基于线程的服务器需要从文件描述符（`fd`）中读取数据，并将其写入到一个网络套接字描述符（`sd`）中，代码如下：

```
int rc = read(fd, buffer, size); 
rc = write(sd, buffer, size); 
```

在多线程程序中，这种操作很容易实现。当 `read()` 最终返回时，代码立即知道要写入哪个套接字，因为这些信息保存在线程的堆栈中。

然而，在基于事件的系统中，事情就没有这么简单了。为了实现相同的功能，首先需要使用异步 I/O 调用来发出读取请求，例如使用 `aio_read()`。在读取完成时，基于事件的服务器需要知道接下来应该做什么，这时就需要用到“延续（continuation）”的概念。

延续是一种老的编程语言结构，其核心思想是将需要在事件完成时使用的信息记录在某种数据结构中。当事件发生（如磁盘 I/O 完成）时，事件处理程序可以查找这些信息并继续处理事件。例如，可以将套接字描述符 `sd` 记录在由文件描述符 `fd` 索引的某种数据结构中（如哈希表）。当磁盘 I/O 完成时，使用 `fd` 来查找并获取 `sd` 的值，然后将数据写入套接字。



## 33.8 什么事情仍然很难

尽管基于事件的方法有许多优点，但它也有一些固有的难题：

1. **多核环境下的并发控制**：当系统从单个 CPU 转向多核 CPU 时，基于事件的方法中的一些简单性就消失了。为了利用多个 CPU，事件服务器可能需要并行运行多个事件处理程序，这时就会出现传统的并发控制问题，例如临界区和锁。
2. **分页（Paging）集成困难**：基于事件的方法无法与某些系统活动（如分页）很好地集成。例如，当事件处理程序发生页错误时，它会被阻塞，导致服务器在页错误完成之前无法进展。虽然可以避免显式阻塞，但由于页错误导致的隐式阻塞很难避免。
3. **代码管理复杂**：随着时间的推移，基于事件的代码可能变得难以维护。函数的确切语义可能会随着时间发生变化，特别是当函数从非阻塞变为阻塞时，原本设计为非阻塞的事件处理程序需要重新设计。
4. **异步 I/O 的实现复杂**：虽然异步磁盘 I/O 现在在大多数平台上都可用，但与异步网络 I/O 的集成并不像想象中那么简单和统一。例如，通常需要组合使用 `select()`（用于网络 I/O）和 `aio_read()`（用于磁盘 I/O）来管理所有未完成的 I/O。

## 33.9 小结

本章讨论了基于事件的并发编程方法。尽管基于事件的方法能够为应用程序提供调度控制，并避免多线程编程中的某些复杂性，但这种方法也带来了状态管理的复杂性和与现代系统其他部分（如分页）的集成困难。由于这些挑战，线程和事件作为并发编程的两种不同方法，在未来可能会继续共存。想要进一步了解这些技术的读者可以参考相关的研究论文，或者尝试编写基于事件的代码来获得更深入的理解。