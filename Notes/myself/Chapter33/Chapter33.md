### 33.1 基本想法：事件循环

在基于事件的并发模型中，不使用传统的多线程并发处理，而是依赖一个事件循环（event loop）来处理并发任务。事件循环的基本思想非常简单，它等待某个事件的发生，当事件发生时，就会处理该事件，然后继续等待下一个事件。这种方法避免了多线程并发中的一些常见问题，如死锁和复杂的调度问题。

事件循环的伪代码如下：

```
c复制代码while (1) { 
    events = getEvents(); 
    for (e in events) 
        processEvent(e); 
}
```

在这个循环中，`getEvents()`负责获取所有已经发生的事件，然后`processEvent(e)`处理每个事件。事件循环的优点之一是它对调度有显式的控制，这意味着程序可以决定何时处理哪个事件，而不是依赖操作系统的调度机制。

### 33.2 重要 API：select()（或 poll()）

为了实现基于事件的并发模型，事件循环需要一种方法来检测是否有事件发生，特别是在处理网络和磁盘 I/O 时。大多数操作系统提供了`select()`或`poll()`系统调用来支持这一功能。这些调用允许程序检查文件描述符，看看它们是否有数据可读或可写，从而决定是否应该处理这些描述符。

#### `select()`函数

`select()`的原型如下：

```
c复制代码int select(int nfds, 
    fd_set *restrict readfds, 
    fd_set *restrict writefds, 
    fd_set *restrict errorfds, 
    struct timeval *restrict timeout);
```

- `nfds`：指定要检查的文件描述符的数量。
- `readfds`：指向一组文件描述符的指针，用于检查它们是否可以读取。
- `writefds`：指向一组文件描述符的指针，用于检查它们是否可以写入。
- `errorfds`：指向一组文件描述符的指针，用于检查是否有异常情况。
- `timeout`：指定`select()`调用等待的最长时间。如果设置为`NULL`，`select()`将无限期等待直到有描述符变得可用。

`select()`返回已经准备好的描述符的数量，这样程序就可以处理这些描述符。通常情况下，基于事件的服务器会使用`select()`来实现非阻塞I/O，从而避免整个服务器因为一个阻塞调用而被挂起。

#### 阻塞与非阻塞接口

阻塞（同步）接口在完成任务后才会返回，而非阻塞（异步）接口则会在开始任务后立即返回，任务在后台继续执行。对于基于事件的并发模型，非阻塞接口是至关重要的，因为阻塞调用会阻止事件循环继续处理其他事件，导致系统挂起。

### 小结

基于事件的并发模型是处理并发任务的一种有效方式，尤其适用于需要处理大量 I/O 操作的服务器。通过使用事件循环和`select()`或`poll()`系统调用，程序可以检测并处理事件，而不需要依赖复杂的多线程模型。这种方法不仅简化了并发编程，还避免了许多多线程编程中的常见问题。

### 33.3 使用 `select()`

为了更具体地说明如何使用 `select()` 来检测哪些网络描述符上有传入消息，下面是一段简单的示例代码，如图 33.1 所示：

```
c复制代码#include <stdio.h> 
#include <stdlib.h> 
#include <sys/time.h> 
#include <sys/types.h> 
#include <unistd.h> 

int main(void) { 
    // open and set up a bunch of sockets (not shown) 
    // main loop 
    while (1) { 
        // initialize the fd_set to all zero 
        fd_set readFDs; 
        FD_ZERO(&readFDs); 
        
        // now set the bits for the descriptors 
        // this server is interested in 
        // (for simplicity, all of them from min to max) 
        int fd; 
        for (fd = minFD; fd < maxFD; fd++) 
            FD_SET(fd, &readFDs); 
        
        // do the select 
        int rc = select(maxFD+1, &readFDs, NULL, NULL, NULL); 
        
        // check which actually have data using FD_ISSET() 
        for (fd = minFD; fd < maxFD; fd++) 
            if (FD_ISSET(fd, &readFDs)) 
                processFD(fd); 
    } 
}
```

这段代码展示了一个简单的事件循环。在每次循环中，`FD_ZERO()` 用于清空文件描述符集合，然后 `FD_SET()` 将所有从 `minFD` 到 `maxFD` 的文件描述符添加到集合中。随后，通过 `select()` 函数检测哪些描述符有数据可读。`FD_ISSET()` 函数则用于检查哪些描述符已经准备好数据，并调用 `processFD(fd)` 处理这些描述符。

实际的服务器会更加复杂，包含发送消息、执行磁盘 I/O 等逻辑。关于更多详细信息，可以参考 Stevens 和 Rago 的书籍 [SR05]。

### 33.4 为何更简单？无须锁

在使用单个 CPU 和基于事件的应用程序时，并发程序中通常遇到的问题（如死锁）并不存在。由于基于事件的方法是单线程的，因此一次只处理一个事件，不需要使用锁。这样避免了线程间的中断问题，也避免了多线程编程中的常见并发性错误。

**提示**：**请勿阻塞基于事件的服务器**
基于事件的服务器需要对任务调度进行细粒度的控制，因此在设计中必须避免阻塞调用。如果阻塞调用被允许执行，整个服务器将会被阻塞，无法继续处理其他事件。

### 33.5 一个问题：阻塞系统调用

虽然基于事件的编程方式听起来很理想，但它有一个显著的问题：如果某个事件处理程序需要发出可能会阻塞的系统调用怎么办？

例如，假设一个服务器接收到客户端的请求，需要从磁盘读取一个文件并将其返回给客户端。为了完成这个任务，服务器可能需要执行 `open()` 和一系列 `read()` 系统调用，而这些调用可能会阻塞，等待磁盘 I/O 完成。

在基于线程的服务器中，这不是一个问题，因为其他线程可以继续执行。而在基于事件的服务器中，由于它是单线程的，如果某个事件处理程序阻塞了整个事件循环，整个服务器都会被阻塞，导致资源浪费。

### 33.6 解决方案：异步 I/O

为了克服阻塞调用的问题，许多现代操作系统引入了异步 I/O（asynchronous I/O）。异步 I/O 允许应用程序发出 I/O 请求，并在 I/O 完成之前立即返回控制权。应用程序可以通过其他接口来检查这些 I/O 是否完成。

#### 示例：macOS 上的异步 I/O

在 macOS 上，异步 I/O 通过 `struct aiocb`（AIO 控制块）来实现。`struct aiocb` 的简化版本如下：

```
c复制代码struct aiocb { 
    int aio_fildes;    /* File descriptor */ 
    off_t aio_offset;  /* File offset */ 
    volatile void *aio_buf; /* Location of buffer */ 
    size_t aio_nbytes; /* Length of transfer */ 
};
```

要进行异步读取，应用程序需要先填充该结构，然后调用 `aio_read()` 函数：

```
c
复制代码
int aio_read(struct aiocb *aiocbp);
```

`aio_read()` 调用会尝试发出 I/O 请求并立即返回，应用程序可以继续执行其他任务。

为了检查 I/O 请求是否完成，应用程序可以使用 `aio_error()` 函数：

```
c
复制代码
int aio_error(const struct aiocb *aiocbp);
```

该函数返回 0 表示 I/O 已完成，返回 `EINPROGRESS` 表示 I/O 尚未完成。

### 总结

基于事件的并发编程可以避免多线程中的许多复杂性，但也需要考虑如何处理可能阻塞的系统调用。异步 I/O 提供了一种解决方案，允许服务器在处理 I/O 请求时不阻塞事件循环，从而提高服务器的并发性能和响应速度。

### 33.7 另一个问题：状态管理

基于事件的方法的另一个挑战在于状态管理。与基于线程的方法不同，基于事件的代码通常更复杂，因为它需要手动管理程序状态。当事件处理程序发出异步 I/O 请求时，它必须打包一些状态信息，以便在 I/O 完成时，能够在下一个事件处理程序中使用。这种手动栈管理（manual stack management）使得基于事件的编程更加复杂。

举个例子，假设一个基于线程的服务器需要从文件描述符（`fd`）中读取数据，并将其写入到一个网络套接字描述符（`sd`）中，代码如下：

```
c复制代码int rc = read(fd, buffer, size); 
rc = write(sd, buffer, size); 
```

在多线程程序中，这种操作很容易实现。当 `read()` 最终返回时，代码立即知道要写入哪个套接字，因为这些信息保存在线程的堆栈中。

然而，在基于事件的系统中，事情就没有这么简单了。为了实现相同的功能，首先需要使用异步 I/O 调用来发出读取请求，例如使用 `aio_read()`。在读取完成时，基于事件的服务器需要知道接下来应该做什么，这时就需要用到“延续（continuation）”的概念。

延续是一种老的编程语言结构，其核心思想是将需要在事件完成时使用的信息记录在某种数据结构中。当事件发生（如磁盘 I/O 完成）时，事件处理程序可以查找这些信息并继续处理事件。例如，可以将套接字描述符 `sd` 记录在由文件描述符 `fd` 索引的某种数据结构中（如哈希表）。当磁盘 I/O 完成时，使用 `fd` 来查找并获取 `sd` 的值，然后将数据写入套接字。

### 33.8 什么事情仍然很难

尽管基于事件的方法有许多优点，但它也有一些固有的难题：

1. **多核环境下的并发控制**：当系统从单个 CPU 转向多核 CPU 时，基于事件的方法中的一些简单性就消失了。为了利用多个 CPU，事件服务器可能需要并行运行多个事件处理程序，这时就会出现传统的并发控制问题，例如临界区和锁。
2. **分页（Paging）集成困难**：基于事件的方法无法与某些系统活动（如分页）很好地集成。例如，当事件处理程序发生页错误时，它会被阻塞，导致服务器在页错误完成之前无法进展。虽然可以避免显式阻塞，但由于页错误导致的隐式阻塞很难避免。
3. **代码管理复杂**：随着时间的推移，基于事件的代码可能变得难以维护。函数的确切语义可能会随着时间发生变化，特别是当函数从非阻塞变为阻塞时，原本设计为非阻塞的事件处理程序需要重新设计。
4. **异步 I/O 的实现复杂**：虽然异步磁盘 I/O 现在在大多数平台上都可用，但与异步网络 I/O 的集成并不像想象中那么简单和统一。例如，通常需要组合使用 `select()`（用于网络 I/O）和 `aio_read()`（用于磁盘 I/O）来管理所有未完成的 I/O。

### 33.9 小结

本章讨论了基于事件的并发编程方法。尽管基于事件的方法能够为应用程序提供调度控制，并避免多线程编程中的某些复杂性，但这种方法也带来了状态管理的复杂性和与现代系统其他部分（如分页）的集成困难。由于这些挑战，线程和事件作为并发编程的两种不同方法，在未来可能会继续共存。想要进一步了解这些技术的读者可以参考相关的研究论文，或者尝试编写基于事件的代码来获得更深入的理解。