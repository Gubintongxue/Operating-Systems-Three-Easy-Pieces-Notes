### 第十三章 抽象：地址空间

**引言** 在操作系统发展的早期，系统的设计和实现相对简单，主要是因为用户的需求非常有限。当时的用户对操作系统的期望并不高，开发者只需要满足基本的功能。然而，随着用户需求的增加，尤其是对“易用性”“高性能”和“可靠性”的需求，这使得操作系统的开发变得更加复杂。可以说，正是这些用户的新需求促使了操作系统的不断演进，同时也带来了许多开发中的挑战。

#### 13.1 早期系统

最早的计算机系统中，用户几乎没有任何内存抽象。操作系统只是一组函数，通常作为一个库加载在内存中，从物理地址0开始。随后，程序（即进程）会被加载到内存的其他部分，占据剩余的物理内存空间。在这个阶段，操作系统的功能非常简单，用户对它的要求也不高。开发者不需要考虑复杂的内存管理问题，只需要简单地将程序和操作系统加载到物理内存中即可。这种简化的模型使得早期操作系统的开发相对容易。

#### 13.2 多道程序和时分共享

随着计算机硬件价格的上升，人们开始寻求更高效的资源利用方式。多道程序系统应运而生，这种系统允许多个进程在同一时间段内准备运行。当一个进程等待I/O操作时，操作系统可以切换到另一个进程执行，以此来提高CPU的利用率。这种方式在当时尤为重要，因为计算机的成本非常高，资源的有效利用能够显著降低运营成本。

然而，随着多道程序系统的发展，用户对系统的要求进一步增加。尤其是分时系统的出现，标志着计算机从批量计算向更具交互性的系统过渡。分时系统允许多个用户同时使用计算机，每个用户都希望能够及时得到响应。为了实现这一目标，操作系统必须有效地管理多个进程的调度和内存使用。

在早期的分时系统中，操作系统会让一个进程独占全部内存运行一小段时间，然后保存该进程的状态信息，将其暂停，接着切换到下一个进程运行。然而，这种方法效率较低，尤其是在内存较大时，保存和恢复整个内存状态的操作非常耗时。为了提高效率，操作系统引入了多进程并发驻留内存的技术，使得多个进程可以同时在内存中保留，从而减少了进程切换的时间开销。随着这种方法的普及，内存保护问题也变得越来越重要。操作系统需要确保一个进程不能访问或修改其他进程的内存，防止程序间的相互干扰。

#### 13.3 地址空间

为了应对用户对操作系统提出的新要求，开发者引入了地址空间的概念。地址空间是操作系统提供给程序的一种抽象表示，它包含了程序运行所需的所有内存状态，包括代码段、栈和堆。代码段包含程序的指令，栈用于保存函数调用信息和局部变量，而堆则管理动态分配的内存。

地址空间的一个关键特性是其动态性：栈和堆可以随着程序的运行而增长或收缩。通过将栈和堆放在地址空间的两端，操作系统允许它们朝相反方向增长，最大化地利用内存空间。然而，地址空间只是一个抽象概念，实际上程序的内存分配并非直接映射到物理内存中。操作系统通过内存虚拟化技术，将程序的虚拟地址转换为物理地址，从而实现每个进程独立且私有的内存空间。这种虚拟化技术使得多个进程可以共享物理内存，同时又保持彼此独立，这是现代计算机系统的基础。

**隔离原则** 在操作系统设计中，隔离是确保系统可靠性的关键原则之一。通过内存隔离，操作系统可以保证不同的进程相互独立，一个进程的错误不会影响其他进程或整个系统的稳定性。进一步的隔离可以通过微内核架构实现，微内核将操作系统的功能模块分离，提升了系统的可靠性和安全性。

### 13.4 目标

在这一节中，讨论了操作系统的主要任务之一——内存虚拟化。内存虚拟化不仅仅是提供内存抽象，还需要实现一定的系统目标，以确保内存虚拟化的效果。这些目标包括透明性、效率和保护。

**透明性（Transparency）** 虚拟内存系统的首要目标是透明性。操作系统需要通过虚拟内存机制，使得运行中的程序看不出内存被虚拟化的事实。也就是说，程序应当认为自己拥有一块私有的、连续的物理内存，而不会意识到这实际上是通过操作系统和硬件的共同努力，实现了多个程序共享物理内存的假象。这种透明性让程序的运行逻辑更加简化，因为它们不必处理复杂的内存管理问题。

**效率（Efficiency）** 另一个关键目标是效率。操作系统在实现虚拟内存时，必须确保系统的时间和空间效率。这意味着虚拟内存系统不应显著减慢程序的运行速度，同时也不能占用过多的物理内存资源来支持虚拟化。在这个过程中，操作系统通常需要依赖硬件支持，如TLB（Translation Lookaside Buffer）等功能，以提高内存访问的效率。

**保护（Protection）** 保护是虚拟内存系统的第三个目标。操作系统必须确保每个进程的内存区域是独立且受到保护的，一个进程不能访问或修改其他进程的内存内容，也不能干扰操作系统的运行。通过这种保护机制，操作系统实现了进程间的隔离，使得每个进程都能够在独立的环境中安全运行，不受其他进程或恶意程序的影响。

**补充：虚拟地址** 在操作系统的虚拟内存体系中，程序员接触到的所有地址实际上都是虚拟地址。这些虚拟地址为程序提供了一种地址分布的假象，而实际的物理地址只有操作系统和硬件才能知道。举个例子，当你在C程序中打印一个指针的地址时，你看到的是虚拟地址，而操作系统会将这些虚拟地址翻译成物理地址，以便从实际的物理内存中获取数据。

**代码示例** 以下是一个简单的C程序示例，它分别打印了main函数的代码地址、通过malloc分配的堆空间地址，以及栈上一个整数的地址：

```
#include <stdio.h> 
#include <stdlib.h> 
int main(int argc, char *argv[]) { 
    printf("location of code : %p\n", (void *) main); 
    printf("location of heap : %p\n", (void *) malloc(1)); 
    int x = 3; 
    printf("location of stack : %p\n", (void *) &x); 
    return x; 
}
```

在64位的Mac上运行这个程序时，输出显示代码、堆和栈分别位于不同的虚拟地址空间内，这些地址都是虚拟的。操作系统通过将这些虚拟地址映射到物理地址，确保程序的正常运行。

**展望** 在接下来的章节中，将重点探讨虚拟内存系统的基本机制（如硬件和操作系统的支持），以及相关策略（如如何管理内存和页面置换）。通过深入理解这些内容，可以全面掌握现代虚拟内存系统的运作原理。

### 13.5 小结

这一章介绍了操作系统中的一个关键子系统：虚拟内存。虚拟内存系统为程序提供了一个巨大的、稀疏的、私有的地址空间的假象，程序的所有指令和数据都在其中存储。操作系统在硬件的协助下，通过将虚拟地址转换为物理地址，获取所需的物理内存内容。为了实现这一目标，操作系统需要使用大量的底层机制，并依靠关键的策略，确保多个进程同时运行时，彼此之间不互相干扰，也不影响操作系统本身的稳定性。接下来的章节将自底向上地描述这些关键机制。