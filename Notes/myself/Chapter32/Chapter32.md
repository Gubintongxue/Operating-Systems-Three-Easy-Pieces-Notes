### 第 32 章 常见并发问题

并发编程中，存在许多常见的缺陷模式，理解这些模式对于编写健壮且正确的程序至关重要。以下是本章的关键问题和常见的并发缺陷类型。

### 32.1 有哪些类型的缺陷

研究表明，复杂的并发程序中存在多种缺陷类型。Lu 等人对几个流行的开源应用程序（如 MySQL、Apache、Mozilla 和 OpenOffice）进行了研究，统计并分析了这些应用程序中常见的并发缺陷类型。这些缺陷大致分为两类：非死锁缺陷和死锁缺陷。

表 32.1 展示了这些应用程序中发现的 105 个缺陷的分布情况，其中大部分（74 个）是非死锁缺陷，其余 31 个是死锁缺陷。通过分析这些缺陷的类型，我们可以更好地理解并发编程中需要注意的问题。

### 32.2 非死锁缺陷

非死锁缺陷在 Lu 等人的研究中占了大多数。在这一节，我们主要讨论其中两种常见的非死锁缺陷：违反原子性（atomicity violation）缺陷和错误顺序（order violation）缺陷。

#### 违反原子性缺陷

违反原子性缺陷是指一段代码假设某些操作是原子的，但在实际执行中，这些操作并未实现原子性，导致程序出现问题。以下是一个出现在 MySQL 中的例子：

```
c复制代码Thread 1:: 
if (thd->proc_info) { 
    ... 
    fputs(thd->proc_info, ...); 
    ... 
} 

Thread 2:: 
thd->proc_info = NULL; 
```

在这个例子中，两个线程都访问 `thd` 结构中的 `proc_info` 成员。第一个线程检查 `proc_info` 非空，然后打印出它的值；而第二个线程将其设置为 `NULL`。如果第一个线程在检查后且在调用 `fputs()` 前被中断，第二个线程将 `proc_info` 设置为 `NULL`，那么当第一个线程恢复执行时，由于引用了空指针，程序将会崩溃。

修复这个问题的通常方法是对共享变量的访问进行加锁，确保每个线程在访问 `proc_info` 字段时，都持有锁。下面是修复后的代码：

```
c复制代码pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER; 

Thread 1:: 
pthread_mutex_lock(&proc_info_lock); 
if (thd->proc_info) { 
    ... 
    fputs(thd->proc_info, ...); 
    ... 
} 
pthread_mutex_unlock(&proc_info_lock); 

Thread 2:: 
pthread_mutex_lock(&proc_info_lock); 
thd->proc_info = NULL; 
pthread_mutex_unlock(&proc_info_lock); 
```

#### 违反顺序缺陷

违反顺序缺陷发生在两个内存访问的预期顺序被打破的情况下。以下是一个例子：

```
c复制代码Thread 1:: 
void init() { 
    ... 
    mThread = PR_CreateThread(mMain, ...); 
    ... 
} 

Thread 2:: 
void mMain(...) { 
    ... 
    mState = mThread->State; 
    ... 
} 
```

在这个例子中，线程 2 的代码假设 `mThread` 已经被初始化了。然而，如果线程 1 没有首先执行，线程 2 可能因为引用未初始化的 `mThread` 而崩溃。

为了修复这个问题，可以使用条件变量来强制执行代码的顺序。以下是修复后的代码：

```
c复制代码pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER; 
pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER; 
int mtInit = 0; 

Thread 1:: 
void init() { 
    ... 
    mThread = PR_CreateThread(mMain, ...); 

    // 发出信号，表示线程已经创建
    pthread_mutex_lock(&mtLock); 
    mtInit = 1; 
    pthread_cond_signal(&mtCond); 
    pthread_mutex_unlock(&mtLock); 
    ... 
} 

Thread 2:: 
void mMain(...) { 
    ... 
    // 等待线程初始化完成
    pthread_mutex_lock(&mtLock); 
    while (mtInit == 0) 
        pthread_cond_wait(&mtCond, &mtLock); 
    pthread_mutex_unlock(&mtLock); 

    mState = mThread->State; 
    ... 
} 
```

在这个修复方案中，增加了一个锁 `mtLock`、一个条件变量 `mtCond`，以及一个状态变量 `mtInit`。这样确保了线程 2 只在 `mThread` 被正确初始化后才会继续执行。

#### 非死锁缺陷：小结

Lu 等人的研究表明，绝大多数非死锁问题都是违反原子性和违反顺序这两种。因此，程序员在编写并发程序时，仔细研究这些错误模式，可以更好地避免这些问题。随着自动化代码检查工具的发展，这些工具也应该集中关注这两种错误类型，因为它们在实际开发中是非常常见的。

然而，并不是所有的缺陷都像我们举的例子一样容易修复。有些问题需要更深入的了解应用程序，以及进行大量的代码和数据结构调整。为了深入理解这些问题，推荐阅读 Lu 等人的研究论文。

### 32.3 死锁缺陷

死锁（deadlock）是并发系统中一个经典且复杂的问题，通常发生在多个线程争夺多个资源时。死锁的典型场景是一个线程持有锁 L1，并等待获取锁 L2，而另一个线程持有锁 L2，并等待锁 L1，如下所示：

```
c复制代码Thread 1:                Thread 2:
lock(L1);                lock(L2);
lock(L2);                lock(L1);
```

如果线程 1 和线程 2 都尝试获取对方持有的锁，就会陷入相互等待的状态，导致死锁。图 32.1 描绘了这种依赖关系的循环（cycle），其中的环路表明了死锁的形成。

#### 关键问题：如何对付死锁

在系统设计中，如何避免死锁，或者如何检测并恢复死锁，是一个关键问题。死锁通常是在多锁争用的复杂系统中产生的，以下是一些常见的死锁产生原因及处理方法。

#### 为什么发生死锁

1. **复杂的依赖关系**：在大型代码库中，组件之间的依赖可能非常复杂。例如，操作系统中的虚拟内存系统和文件系统之间的交互可能导致循环依赖，从而引发死锁。
2. **封装问题**：软件开发中的模块化设计可能会隐藏潜在的锁依赖问题。例如，Java 中 `Vector` 类的 `AddAll()` 方法可能会导致死锁，因为它同时需要获取两个向量的锁，而不同线程可能会以不同的顺序获取这些锁。

#### 产生死锁的条件

根据经典的死锁理论，产生死锁需要满足以下四个条件：

1. **互斥**：线程对资源的访问是互斥的（即一次只能一个线程持有锁）。
2. **持有并等待**：线程持有一个资源的同时，还在等待其他资源。
3. **非抢占**：线程持有的资源不能被抢占，只有线程自己可以释放资源。
4. **循环等待**：线程之间存在一个循环等待链，其中每个线程持有一个资源，并等待下一个线程持有的资源。

如果打破这四个条件中的任何一个，就可以避免死锁。

#### 预防死锁的方法

1. **避免循环等待**：通过为锁的获取设定一个全序或偏序，确保线程总是按照固定的顺序获取锁，从而避免循环等待。例如，如果所有线程总是先获取锁 L1 再获取锁 L2，则不会产生死锁。
2. **持有并等待的解决**：通过一次性获取所有所需的锁来避免持有并等待。可以引入一个预防锁（prevention lock），在获取所有其他锁之前，先获取预防锁。虽然这种方法有效，但它要求事先知道所有需要的锁，并且可能降低系统并发性。
3. **非抢占策略**：使用 `trylock()` 方法尝试获取锁，如果失败，则释放已经持有的锁并重试。这种方法虽然避免了死锁，但可能导致活锁（livelock），即系统忙于获取锁但没有进展。
4. **避免互斥**：通过使用无等待（wait-free）数据结构或原子操作，避免锁的使用。例如，使用硬件支持的比较并交换（compare-and-swap, CAS）指令可以实现无锁的原子操作，从而避免死锁。

#### 通过调度避免死锁

在某些场景下，可以通过聪明的线程调度策略来避免死锁。例如，如果知道某些线程需要获取相同的锁资源，可以确保它们不同时运行，从而避免死锁。虽然这种方法在某些嵌入式系统中有效，但一般情况下，它限制了系统的并发性。

#### 检查和恢复

另一种应对死锁的策略是允许死锁偶尔发生，然后通过检查和恢复机制来处理。许多数据库系统采用这种策略，它们会定期检查系统状态，发现死锁时，强制中止并恢复受影响的线程。虽然这种策略允许系统继续运行，但可能会对性能产生一定影响。

### 32.4 小结

在本章中，我们探讨了并发编程中的一些常见缺陷，尤其是非死锁缺陷和死锁问题。非死锁缺陷通常包括违反原子性和违反顺序两种，它们在现代代码中很常见，修复这些问题相对简单。相比之下，死锁问题则更加复杂，涉及多种预防、避免和恢复策略。

死锁问题随着并发编程的历史而发展，已有大量研究成果和解决方案。然而，在实际应用中，设计一种全新的无等待数据结构极其复杂，因此往往选择通过正确的锁顺序、聪明的调度策略或死锁检测与恢复机制来避免死锁。最终，随着并发编程模型的发展，如 MapReduce 这样的系统，可以让开发者在不使用锁的情况下完成并行计算，从而减少死锁问题的发生。