### 第十五章 机制：地址转换

在本章中，我们讨论了操作系统如何通过地址转换实现内存虚拟化，从而在保持系统高效和灵活的同时，确保对内存的控制。

#### 15.1 背景

实现CPU虚拟化的一般准则被称为**受限直接访问（Limited Direct Execution, LDE）**。这一原则的核心思想是让程序直接访问硬件，但在关键时刻（如系统调用或时钟中断）由操作系统介入，确保系统按预期运行。操作系统的目标是在实现高效虚拟化的同时，保持对硬件的控制。

在实现内存虚拟化时，操作系统采用了类似的策略：通过硬件支持，实现高效的地址转换，同时确保操作系统对内存的控制。操作系统必须管理内存，记录被占用和空闲的内存位置，并通过硬件介入来实现对内存访问的控制。最终目标是为每个程序提供一个虚拟的私有内存空间，尽管在物理上多个程序共享相同的内存资源。

#### 15.2 一个例子

为了更好地理解地址转换，我们来看一个简单的例子。假设一个进程的地址空间如图15.1所示。我们关注的是一小段代码，它从内存中加载一个值，对其加3，然后将结果存回内存。

这段代码在C语言中的形式如下：

```
c复制代码void func() { 
 int x; 
 x = x + 3; // 这是我们感兴趣的代码行 
}
```

编译器将这段代码转化为汇编指令，可能如下所示（假设x86架构）：

```
assembly复制代码128: movl 0x0(%ebx), %eax  ; 将ebx寄存器指向的内存内容加载到eax寄存器
132: addl $0x03, %eax      ; 将eax寄存器中的值加3
135: movl %eax, 0x0(%ebx)  ; 将eax寄存器中的值存回到ebx指向的内存
```

在这段代码中，变量`x`的地址被存储在寄存器`ebx`中，`movl`指令将该地址的内容加载到寄存器`eax`中，然后对`eax`中的值加3，最后将结果存回内存。

从程序的角度来看，它的地址空间从0开始，到16KB结束。程序中的所有内存引用都应当在这个范围内。然而，操作系统实际上希望将进程的地址空间放置在物理内存中的其他位置，而不是从地址0开始。

#### 15.3 地址重定位示例

图15.2展示了一个将进程地址空间重定位到物理内存的示例。在这个例子中，操作系统将第一块物理内存留给自己，并将进程的地址空间从32KB的物理地址开始重定位。剩下的两块物理内存区域（16KB-32KB和48KB-64KB）保持空闲状态。

这种重定位通过硬件支持的地址转换机制实现，使得程序认为自己拥有连续的地址空间，而实际上它的内存可能分布在物理内存的不同区域。这种机制提供了内存虚拟化所需的透明性，保证程序可以像在独占的物理内存上运行一样，而不会意识到底层内存的复杂布局。

### 小结

地址转换是内存虚拟化的关键机制，它通过硬件支持，将程序的虚拟地址空间映射到物理内存，确保多个程序可以同时、安全地共享系统内存。在接下来的内容中，我们将进一步探讨实现这种机制的具体方法和工具，如页表（page tables）和TLB（Translation Lookaside Buffer）。这些机制的正确实现，是现代操作系统能够提供高效、安全的虚拟内存服务的基础。

### 15.3 动态（基于硬件）重定位

在内存虚拟化的早期实现中，引入了一种简单而有效的技术，称为**基址加界限机制**（Base and Bound Mechanism），也称为**动态重定位**（Dynamic Relocation）。这种技术首次应用于20世纪50年代末的时分机器中。

#### 基址加界限机制

该机制依赖于两个硬件寄存器：**基址寄存器（Base Register）** 和 **界限寄存器（Bound Register）**，也称为**限制寄存器（Limit Register）**。这两个寄存器共同作用，使得程序的地址空间可以被放置在物理内存的任意位置，并且保证进程只能访问其自身的地址空间。

**地址转换** 在编写和编译程序时，程序的地址空间被假设从零开始。但在程序执行时，操作系统会决定程序实际加载到物理内存中的位置，并将其起始地址存入基址寄存器。例如，如果操作系统决定将进程加载到物理内存的32KB处，则基址寄存器被设置为32KB。在运行时，每当进程发出内存访问请求，硬件会将虚拟地址加上基址寄存器中的值，以生成对应的物理地址：

```
plaintext
复制代码
physical address = virtual address + base
```

**静态重定位** 在硬件支持动态重定位之前，一些系统采用了纯软件的静态重定位技术。加载程序（Loader）负责将可执行程序的地址重写到物理内存中的期望位置。虽然静态重定位可以实现基本的地址映射，但它无法提供有效的访问保护，并且一旦程序开始运行，难以重新定位内存。

#### 动态重定位的实现

在动态重定位过程中，每次内存访问都会通过硬件进行地址转换。例如，当程序计数器（PC）设置为128时，硬件会将其加上基址寄存器中的值（如32KB），得到物理地址32896，然后从该物理地址获取指令。

类似地，当进程从虚拟地址15KB加载数据时，硬件会将虚拟地址加上基址寄存器中的32KB，得到最终的物理地址47KB，并从该位置获取数据。这样的地址转换在程序运行的每一步都发生，以确保进程的内存访问被正确定位到物理内存中。

**界限寄存器的作用** 界限寄存器用于提供访问保护。如果进程尝试访问超出界限或为负数的地址，CPU会触发异常，可能导致进程终止。这种机制确保进程只能在其分配的地址范围内操作，从而保护系统的稳定性。

#### 示例

假设一个进程的地址空间大小为4KB，加载在物理内存的16KB处，表15.1展示了一些地址转换的结果：

**表 15.1 地址转换结果**

| 虚拟地址 | 物理地址     |
| -------- | ------------ |
| 0        | 16KB         |
| 1KB      | 17KB         |
| 3000     | 19384        |
| 4400     | 错误（越界） |

通过这种方式，虚拟地址通过与基址寄存器相加，轻松地转换为物理地址。如果虚拟地址超出界限，则会引发异常。

**补充：空闲列表** 操作系统需要记录哪些物理内存尚未使用，以便为进程分配内存。最简单的数据结构是**空闲列表（Free List）**，它记录当前可用的内存范围。

------

本节总结了动态重定位技术，它通过硬件的基址和界限寄存器，实现了虚拟地址到物理地址的映射，并提供了基本的内存访问保护。这种机制为操作系统的内存管理打下了基础，尽管随着技术的发展，内存管理机制变得更加复杂，但动态重定位仍然是内存虚拟化的重要里程碑。

### 15.4 硬件支持：总结

在本节中，我们总结了实现动态重定位（Dynamic Relocation）所需的硬件支持。这些硬件要求与我们在CPU虚拟化中讨论的内容类似，需要特定的CPU模式和寄存器来确保内存访问的正确性和安全性。

#### 硬件要求

**1. 特权模式** 操作系统必须运行在特权模式（Privileged Mode），也称为内核模式（Kernel Mode），以便可以访问整个机器资源。应用程序则运行在用户模式（User Mode），只能执行有限的操作。特权模式和用户模式的区分是通过处理器状态字（Processor Status Word）中的一个位来实现的。

**2. 基址和界限寄存器** 每个CPU都需要一对基址（Base）和界限（Bound）寄存器来支持地址转换和边界检查。基址寄存器存储的是进程在物理内存中的起始地址，而界限寄存器则定义了进程地址空间的大小或结束地址。

**3. 地址转换和边界检查** 硬件需要能够进行地址转换和边界检查。这些操作通过CPU内的电路完成，确保虚拟地址能够正确转换为物理地址，并且检查是否超出进程的合法地址范围。

**4. 特权指令** 硬件需要提供修改基址和界限寄存器的特权指令。操作系统在进程切换时必须能够设置这些寄存器的值，以确保新进程能够正确访问内存。如果普通用户进程能够随意修改这些寄存器，可能会导致严重的安全问题。

**5. 异常处理** CPU必须能够检测并处理异常情况，例如进程试图访问越界内存或执行特权指令时。操作系统必须提供异常处理程序（Exception Handler），在异常发生时执行正确的操作，通常是终止进程并释放其占用的资源。

#### 表 15.2 动态重定位的硬件要求

| **硬件要求**               | **解释**                                       |
| -------------------------- | ---------------------------------------------- |
| **特权模式**               | 防止用户模式进程执行特权操作                   |
| **基址/界限寄存器**        | 支持地址转换和边界检查                         |
| **地址转换与边界检查电路** | 负责完成地址转换和检查边界                     |
| **特权指令**               | 允许操作系统在进程切换时修改基址和界限寄存器   |
| **异常处理支持**           | 在进程试图访问非法内存或执行特权操作时触发异常 |

硬件的这些支持能够确保操作系统在切换进程时能够正确设置寄存器，并且在发生异常时能够及时处理，确保系统的稳定和安全。

### 15.5 操作系统的问题

硬件的支持使操作系统能够实施动态重定位，但这也引入了一些需要操作系统管理的新问题。

**1. 内存管理** 在进程创建时，操作系统需要为新进程分配内存，并在进程终止时回收其占用的内存。操作系统通常使用空闲列表（Free List）来管理内存，记录哪些物理内存块是空闲的，哪些是已被分配的。

**2. 基址/界限管理** 在上下文切换时，操作系统必须保存和恢复基址和界限寄存器的值。这意味着在进程切换时，操作系统需要保存当前进程的寄存器值，并在下一个进程开始执行时恢复这些值。

**3. 异常处理** 操作系统必须提供异常处理程序，以便在进程试图越界访问内存或执行非法指令时能够正确处理。通常情况下，操作系统会终止导致异常的进程，以确保系统的安全性和稳定性。

#### 表 15.3 动态重定位的操作系统职责

| **操作系统的职责** | **解释**                                 |
| ------------------ | ---------------------------------------- |
| **内存管理**       | 分配和回收内存，管理空闲列表             |
| **基址/界限管理**  | 上下文切换时正确设置基址和界限寄存器     |
| **异常处理**       | 提供异常处理程序，处理越界访问和非法指令 |

在操作系统的管理下，动态重定位机制能够有效运作，提供基本的内存虚拟化服务。

### 小结

本章介绍了地址转换机制，它扩展了受限直接访问的概念。利用基址和界限寄存器，操作系统能够控制进程的所有内存访问，并将虚拟地址转换为物理地址。这种机制的高效性依赖于硬件的支持，它在每次内存访问时迅速完成地址转换，并检查是否越界。

尽管动态重定位提供了基础的内存保护，但它也有一些缺点，如内存浪费和内部碎片化。为了更好地利用物理内存，避免碎片问题，我们需要更加复杂的机制，这将在后续章节中讨论。

### 15.4 硬件支持：总结

在本节中，我们总结了实现动态重定位所需的硬件支持。这些硬件组件和机制对于确保操作系统有效管理内存并实现虚拟内存至关重要。

**1. 特权模式（Privileged Mode）**

- **目的**：在CPU中实现两种模式：特权模式和用户模式。操作系统运行在特权模式下，可以访问所有硬件资源，而用户程序则运行在用户模式下，只能进行有限的操作。这一机制通过处理器状态字中的一个位来管理。
- **作用**：防止用户模式的进程执行特权操作，如修改基址和界限寄存器，确保系统安全。

**2. 基址和界限寄存器（Base and Bounds Registers）**

- **目的**：每个CPU都需要一对基址寄存器和界限寄存器，用于支持虚拟地址到物理地址的转换，并确保内存访问不超出界限。
- **作用**：基址寄存器将虚拟地址转换为物理地址，界限寄存器用于检查访问是否越界。

**3. 地址转换与边界检查电路**

- **目的**：硬件需要能够快速地完成地址转换，并检查地址是否在合法范围内。
- **作用**：保证每次内存访问都能正确映射到物理内存，同时确保进程不会访问非法地址。

**4. 特权指令**

- **目的**：提供一组特权指令，使操作系统能够在进程切换时修改基址和界限寄存器的值。这些指令只能在内核模式下执行，以防止用户进程篡改寄存器内容。
- **作用**：允许操作系统安全地管理每个进程的内存地址空间。

**5. 异常处理**

- **目的**：硬件必须能够在进程尝试非法内存访问时触发异常，并调用操作系统的异常处理程序。
- **作用**：当进程试图执行特权操作或访问越界内存时，CPU会触发异常，操作系统的异常处理程序负责终止或处理该进程，确保系统的稳定性和安全性。

### 表 15.2 动态重定位的硬件要求

| **硬件要求**           | **解释**                                             |
| ---------------------- | ---------------------------------------------------- |
| **特权模式**           | 需要，以防用户模式的进程执行特权操作                 |
| **基址/界限寄存器**    | 每个CPU需要一对寄存器来支持地址转换和界限检查        |
| **地址转换与检查电路** | 电路完成地址转换和界限检查，确保内存访问的正确性     |
| **特权指令**           | 允许操作系统在进程切换时修改基址和界限寄存器         |
| **异常处理**           | 在进程试图使用特权指令或越界访问内存时，硬件触发异常 |

### 15.5 操作系统的问题

在支持动态重定位的过程中，硬件添加了新的功能，这使得操作系统需要处理更多复杂的问题。

**1. 内存管理**

- **操作系统职责**：当进程创建时，操作系统需要为进程分配合适的内存空间。当进程终止时，操作系统需要回收并清理该进程占用的内存。这些操作通常通过空闲列表（Free List）来管理，记录哪些物理内存块是空闲的，哪些是已被分配的。

**2. 基址/界限管理**

- **操作系统职责**：在上下文切换时，操作系统需要保存和恢复基址和界限寄存器的值。每个进程的地址空间在物理内存中的位置不同，因此基址和界限寄存器的值也不同。操作系统必须确保在切换进程时正确设置这些寄存器。

**3. 异常处理**

- **操作系统职责**：操作系统必须提供异常处理程序（Exception Handler），在进程试图越界访问内存或执行非法指令时，硬件触发异常，操作系统介入处理。这通常会导致错误进程的终止。

### 表 15.3 动态重定位的操作系统职责

| **操作系统职责**  | **解释**                                           |
| ----------------- | -------------------------------------------------- |
| **内存管理**      | 分配新进程内存，回收终止进程的内存，管理空闲列表   |
| **基址/界限管理** | 在上下文切换时，正确设置和恢复基址/界限寄存器的值  |
| **异常处理**      | 当异常发生时执行相应的处理程序，通常终止犯错的进程 |

### 小结

通过动态重定位机制，操作系统能够有效控制内存访问，并确保每个进程只能访问其合法的内存区域。硬件支持在每次内存访问时快速转换虚拟地址到物理地址，同时检查地址是否越界。尽管这种机制简单高效，但它也存在一些缺点，如内存的内部碎片问题。为了解决这些问题，操作系统需要更复杂的内存管理机制，如分段和分页，将在后续章节中探讨。

这个总结对动态重定位的硬件支持和操作系统职责进行了详细归纳，强调了操作系统和硬件的协作对于实现虚拟内存的重要性。如果有更多需要总结的内容，请继续提供。