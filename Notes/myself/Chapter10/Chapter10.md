### 10.1 背景：多处理器架构

本节介绍了多处理器调度中的一些基本问题和概念，特别是当涉及到多核处理器时。多核处理器将多个 CPU 核心集成在一块芯片上，这种架构逐渐在个人电脑、笔记本电脑甚至移动设备上普及。

在单 CPU 系统中，缓存（cache）是用来加速程序运行的关键组件。缓存是较小但速度很快的存储器，用来保存最频繁访问的数据副本。通常，数据从内存加载到缓存中，后续的访问会更快，因为不需要每次都从较慢的内存中读取。

但在多 CPU 系统中，缓存的一致性（cache coherence）问题变得更加复杂。例如，如果一个 CPU 在缓存中修改了某个内存地址的数据，但没有立即写回内存，另一个 CPU 读取该地址时，可能会得到旧的、不一致的数据。

为了解决这个问题，现代系统使用了缓存一致性协议，例如总线窥探（bus snooping）。这种协议让每个 CPU 的缓存监视连接所有缓存和内存的总线，确保每个 CPU 在访问数据时都能获得最新的值。如果某个 CPU 修改了数据，其他 CPU 的缓存会使其本地副本无效或更新为新值。

这些机制保证了多处理器系统在并行运行时，数据的一致性和系统的稳定性。

### 10.2 别忘了同步

在多处理器系统中，即使硬件提供了缓存一致性，应用程序或操作系统仍然需要小心处理共享数据的访问，特别是在多个CPU上并发操作共享数据或数据结构时。为了保证数据的一致性和正确性，通常需要使用同步原语，如锁（mutex），来保护这些共享资源。

举例来说，假设多个CPU上的线程并发地访问一个共享链表（linked list），如果没有加锁，可能会导致多个线程同时修改链表，进而导致数据结构的损坏。具体表现为，一个线程在获取链表头的指针后，另一个线程也获取了同样的指针，导致两个线程试图删除同一个链表节点。这种情况下，程序可能会重复释放同一内存块，或返回错误的数据。

为了避免这种情况发生，程序应在访问和修改共享数据结构之前，先获取锁，从而确保只有一个线程能够执行这些操作。当操作完成后，再释放锁，允许其他线程继续操作。这种机制虽然能确保数据的正确性，但随着系统中CPU数量的增加，锁的争用可能会成为性能瓶颈。每次访问共享数据时获取和释放锁的操作都会增加系统开销，特别是在高并发环境下。

### 10.3 最后一个问题：缓存亲和度

多处理器调度中的另一个关键问题是缓存亲和度（cache affinity）。缓存亲和度指的是，当一个进程在某个CPU上运行一段时间后，其数据和指令会保留在该CPU的缓存中，这使得它在下次继续在同一CPU上运行时更快，因为数据已经在缓存中，无需重新从内存加载。

然而，如果该进程被调度到另一个CPU上运行，由于数据不在新CPU的缓存中，系统必须重新加载这些数据，导致性能下降。因此，调度程序在设计时应该考虑尽量将进程调度到它上次运行的CPU上，以利用缓存亲和性。这种策略可以减少缓存未命中（cache miss）次数，提高系统整体性能。

### 10.4 单队列调度

在多处理器调度中，一种简单的方法是使用单队列多处理器调度（Single Queue Multiprocessor Scheduling，SQMS）。在这种方法中，所有需要调度的进程被放入一个全局的单一队列中，各个CPU从这个队列中取出任务执行。

#### 优点：

- **简单性**：SQMS 简单易实现，直接复用单处理器调度策略即可。在这种架构下，所有CPU都从一个全局队列中取任务，保证了系统的调度一致性。

#### 缺点：

1. **扩展性问题**：随着CPU数量增加，多个CPU并发访问全局队列，必然需要加锁以保证操作的原子性。锁的争用会随着CPU数量的增加而显著增加，导致系统在锁竞争上浪费大量时间，从而降低整体性能。
2. **缓存亲和性问题**：SQMS的一个重大缺点是难以保持缓存亲和性。由于每个CPU从全局队列中获取下一个任务，可能导致任务频繁在不同CPU之间切换，这会导致缓存数据的失效，进而增加缓存未命中次数，降低系统性能。

为了缓解缓存亲和性问题，SQMS调度程序可以引入一些机制，使进程尽量在同一CPU上运行。然而，这种机制可能导致部分进程在负载不均衡的情况下不得不迁移，破坏缓存亲和性。这种负载均衡与缓存亲和性的矛盾是SQMS的一个典型问题。

### 10.5 多队列调度

由于单队列调度程序（SQMS）在多处理器环境中存在扩展性和缓存亲和度的问题，另一个解决方案被提出，即多队列多处理器调度（Multi-Queue Multiprocessor Scheduling，MQMS）。在MQMS中，每个CPU拥有一个独立的调度队列，各个CPU可以根据不同的调度规则（如轮转调度或其他算法）独立地选择要运行的任务。

#### 优点：

- **扩展性强**：由于每个CPU都有独立的调度队列，各CPU之间的调度是相互独立的，不需要对单一队列进行加锁，因此减少了锁的争用问题，极大地提高了系统的可扩展性。
- **缓存亲和度好**：在MQMS中，任务一般会被分配到固定的CPU上运行，因此这些任务可以很好地利用该CPU的缓存，从而提高执行效率。

#### 缺点：

- **负载不均**：MQMS中，每个CPU只从自己的队列中选择任务运行，这可能导致某些CPU的负载很重，而另一些CPU的负载较轻，从而出现负载不均的问题。例如，当某个任务（如任务C）完成后，如果其他队列中的任务没有迁移到这个CPU上，该CPU可能会闲置，而其他CPU可能因任务过多而负载过重。

#### 负载均衡的解决方案：

为了解决负载不均的问题，MQMS可以使用任务迁移（migration）技术。任务迁移的基本思想是，将任务从负载较重的CPU队列中移到负载较轻的CPU上，以实现负载均衡。

- **工作窃取（work stealing）**：工作窃取是一种常用的负载均衡策略，其中负载较轻的CPU会定期检查其他CPU的队列，并“窃取”任务以平衡负载。这种方法的优点是能够动态平衡负载，避免某些CPU过度闲置。然而，如果检查间隔设置不当，可能导致负载不均持续存在或频繁的任务迁移带来的额外开销。

### 总结：

多队列多处理器调度（MQMS）通过将任务分配到多个队列，从而提高了调度程序的扩展性和缓存亲和度。然而，负载均衡问题仍然是MQMS的一个主要挑战，需要通过任务迁移等技术来解决。选择合适的负载均衡策略（如工作窃取）至关重要，因为这会直接影响系统的整体性能。

### 10.6 Linux 多处理器调度

在实现多处理器调度方面，Linux 社区采用了多种不同的方法，主要有以下三种调度程序：

1. **O(1) 调度程序**：
   - **特点**：O(1)调度程序是一种基于优先级的调度算法，类似于之前讨论的多级反馈队列（MLFQ）。它通过时间推移来动态调整进程的优先级，以实现各种调度目标，特别是关注交互性。它的名称“O(1)”表明在任何时刻都可以在常数时间内做出调度决定。
   - **多队列架构**：O(1)调度程序采用了多队列架构，每个队列代表一个优先级，并且队列之间相互独立。
2. **完全公平调度程序（CFS）**：
   - **特点**：CFS 是一种基于公平性原则的比例份额调度方法，类似于步长调度。CFS 试图在所有任务之间公平地分配 CPU 时间，使用红黑树（红黑树是一种自平衡二叉搜索树）来管理任务，使调度决策可以在对数时间内完成。
   - **多队列架构**：CFS 也采用了多队列架构，不同的 CPU 可以独立进行调度决策。
3. **BFS（Brain Fuck Scheduler）**：
   - **特点**：BFS 主要针对桌面系统的交互性进行了优化，是一种简单但高效的调度算法。与 O(1) 和 CFS 不同，BFS 使用了单队列调度，这意味着所有任务共享一个全局队列。
   - **调度策略**：BFS 采用了最早最合适虚拟截止时间优先算法（EEVEF），这是一个更加复杂的调度方案，旨在为高响应性提供保障。

### 10.7 小结

本章探讨了多处理器调度的不同方法。关键在于如何在多个 CPU 上调度工作，以及如何在负载均衡和缓存亲和度之间找到平衡点。

- **单队列多处理器调度（SQMS）**：简单易实现，适合负载较小的系统，但在扩展性和缓存亲和度方面存在缺陷。
- **多队列多处理器调度（MQMS）**：通过为每个 CPU 分配独立的调度队列，提高了系统的扩展性和缓存亲和度，但可能导致负载不均，需要通过任务迁移（如工作窃取）来实现负载均衡。

Linux 的多处理器调度实现展示了不同方法的应用，其中 O(1) 和 CFS 使用了多队列架构，而 BFS 选择了单队列架构，每种方法都有其独特的优缺点。构建一个通用的多处理器调度程序是一项艰巨的任务，因为即使是微小的代码改动，也可能对系统的整体性能产生重大影响。